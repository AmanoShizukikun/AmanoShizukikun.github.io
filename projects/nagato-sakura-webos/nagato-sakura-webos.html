<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="天野靜樹的 OS 網頁模擬器">
    <meta name="author" content="天野靜樹">
    <meta name="keywords" content="天野靜樹">
    <title>天野靜樹 - WEB OS</title>
    <link rel="icon" href="../../assets/images/logo.png" type="image/png">
    
    <!-- 圖示庫 (Font Awesome) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- 全域樣式 (確保 header / settings-panel 使用全域樣式) -->
    <link rel="stylesheet" href="../../assets/css/core.css">
    <link rel="stylesheet" href="../../assets/css/components.css">
    <link rel="stylesheet" href="../../assets/css/animations.css">
    <!-- Calculator style (embedded: previously from win12-main/apps/style/calc.css) -->
    
    <!-- 字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* 顏色 */
            --primary-cyan: #00d4ff;
            --primary-magenta: #ff0080;
            --accent-cyan: #00ffff;
            --accent-pink: #ff69b4; 
            --accent-purple: #8b5cf6;
            --primary-yellow: #ffff00;
            
            --dark-bg: #0a0a0f;
            --darker-bg: #050507;
            
            /* 改良的毛玻璃/Mica效果 */
            --mica-bg: rgba(30, 30, 45, 0.7);
            --mica-bg-light: rgba(45, 45, 60, 0.7);
            --mica-bg-dark: rgba(20, 20, 30, 0.8);
            --mica-blur: 20px;
            
            /* 字體 */
            --font-display: 'Orbitron', monospace;
            --font-body: 'Rajdhani', sans-serif;
            --font-ui: 'Noto Sans TC', sans-serif;
            
            /* UI 尺寸 */
            --taskbar-height: 50px;
            --taskbar-icon-size: 24px; /* New: icon size used by both font & image icons */
            --window-border-radius: 8px;
            --z-taskbar: 1000;
            --z-window: 100;
            --z-start-menu: 1010;
            --z-context-menu: 1020;
            --z-loader: 9999;
            
            /* 新增：混合佈局尺寸 */
            --header-height: 60px;
            --sidebar-width: 280px;
            /* Compatibility variables used by win12-main calc.css */
            --text: #e6e6e6;            /* general text color */
            --card: rgba(255,255,255,0.03);
            --bd: rgba(0,0,0,0.2);
            --s3d: rgba(0,0,0,0.35);
            --mm: rgba(0,212,255,0.14);
            --theme-1: #00d4ff;
            --theme-2: #4caf50;
            /* 顯示/夜間光線控制 */
            --simulator-brightness: 1; /* 0.5 ~ 1.2 - controlled by亮度滑桿 */
            --nightlight-opacity: 0; /* 0~0.5 - controlled by夜間光線 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: var(--font-ui), sans-serif;
            background-color: var(--dark-bg);
            color: #f0f0f0;
            
            /* 新增：為混合佈局修改 */
            display: flex;
            flex-direction: column;
        }

        /* --- 新增：頁面佈局 (來自 win.html) --- */

        /* 1. 頂部導航欄 (use global header styles to match other pages) */
        /* Using the native <header> element ensures consistent layout across site. */
        /* NOTE: Remove the custom class to inherit global header CSS from components.css */
        /* custom cyber-header removed - rely on global header from components.css */
        .header-logo a {
            font-size: 1.5rem;
            color: var(--primary-cyan);
            text-decoration: none;
            font-weight: 700;
        }
        .header-nav a {
            color: #eee;
            text-decoration: none;
            margin-left: 25px;
            font-size: 0.9rem;
            font-family: var(--font-body);
            transition: color 0.2s ease;
        }
        .header-nav a:hover {
            color: var(--primary-cyan);
        }

        /* 2. 主內容包裝器 */
        .main-wrapper {
            display: flex;
            width: 100%;
            /* height: 100vh; */
            flex-grow: 1; /* 填滿剩餘空間 */
            /* padding-top: var(--header-height); 已改為使用 simulat or height 而非雙重 padding */
            min-height: calc(100vh - var(--header-height, 60px));
        }

        /* 3. 右側邊欄 */
        .cyber-sidebar {
            width: var(--sidebar-width);
            flex-shrink: 0;
            z-index: 5;
            z-index: 5;
            background: rgba(10, 10, 15, 0.7);
            backdrop-filter: blur(15px);
            border-left: 1px solid rgba(255, 255, 255, 0.1); /* 改為左邊框 */
            z-index: 1500;
            padding: 20px;
            font-family: var(--font-body);
            color: #ccc;
            overflow-y: auto;
        }
        .cyber-sidebar h3 {
            color: var(--primary-cyan);
            font-family: var(--font-display);
            margin-bottom: 15px;
            border-bottom: 1px solid var(--primary-cyan);
            padding-bottom: 5px;
        }
        .cyber-sidebar ul {
            list-style: none;
            padding: 0;
        }
        .cyber-sidebar li {
            padding: 12px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 1.1rem;
        }
        .cyber-sidebar li:hover {
            background: rgba(0, 212, 255, 0.1);
            color: #fff;
        }
        .cyber-sidebar li i {
            margin-right: 12px;
            width: 20px;
            text-align: center;
        }

        /* 4. 模擬器容器 */
        .simulator-container {
            flex-grow: 1;
            position: relative; /* 關鍵：使所有子元素相對於此定位 */
            height: calc(100vh - var(--header-height, 60px));
            overflow: hidden;
            margin-top: 0; /* 防止任何其他邊距導致空隙 */
            /* Apply overall brightness using CSS variable */
            filter: brightness(var(--simulator-brightness));
        }

        /* Night light overlay sits on top of simulator content but below menus/overlays */
        #nightlight-overlay {
            position: absolute;
            inset: 0 0 0 0; /* top/right/bottom/left */
            pointer-events: none;
            z-index: calc(var(--z-start-menu) - 1); /* just beneath start menu */
            background: rgba(255, 137, 73, var(--nightlight-opacity));
            mix-blend-mode: overlay;
            transition: opacity 0.18s ease, background 0.18s ease;
            opacity: 0;
        }

        /* --- 模擬器 CSS (來自 win_improved.html) --- */
        /* --- 已修改 position 為 absolute --- */

        /* 1. 啟動加載器 */
        #boot-loader {
            position: absolute; /* 修改 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: var(--z-loader);
            transition: opacity 0.5s ease-out;
        }
        #boot-logo {
            font-size: 8rem;
            color: var(--primary-cyan);
            margin-bottom: 2rem;
            animation: pulse 2s infinite ease-in-out;
        }
        #boot-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--primary-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #boot-status {
            margin-top: 2rem;
            font-family: var(--font-body);
            font-size: 1.2rem;
            color: #aaa;
        }

        /* 2. 桌面 */
            #desktop {
            position: absolute; /* 修改 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at bottom, #0a192f 0%, #05080f 100%);
            overflow: hidden;
            padding: 20px;
            /* 改為垂直排列，模擬 win.html 的桌面圖示佈局 */
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            gap: 15px;
            align-content: flex-start;
        }

        .desktop-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            width: 80px; /* 與 win.html 一致的寬度，確保垂直堆疊 */
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .desktop-icon:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .desktop-icon i {
            font-size: 2.5rem;
            margin-bottom: 8px;
            color: #fff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .desktop-icon span {
            font-size: 0.85rem;
            color: #f0f0f0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
            word-break: break-all;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* 3. 任務欄 */
        #taskbar {
            position: absolute; /* 修改 */
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--taskbar-height);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: var(--z-taskbar);
            
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        .taskbar-group {
            display: flex;
            height: 100%;
            align-items: center;
            padding: 0 4px; /* reduced outer padding for tighter layout */
            gap: 4px; /* reduce spacing between icon groups */
        }
        .taskbar-group.center {
            justify-content: center;
            flex-grow: 1;
            gap: 4px; /* tighter gap between center icons */
        }
        .taskbar-group.right {
            justify-content: flex-end;
        }

        .taskbar-icon {
            font-size: 1.2rem; /* baseline font for FA icons */
            color: #e0e0e0;
            /* shrink the clickable area and reduce spacing while maintaining tappable size */
            min-width: calc(var(--taskbar-icon-size) + 16px);
            padding: 0 4px; /* reduced horizontal padding, tighter spacing */
            height: 100%;
            display: inline-flex; /* inline to avoid full-width flex children issues */
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background-color 0.18s ease;
            cursor: pointer;
            box-sizing: border-box;
        }
        .taskbar-icon:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        /* Make sure FA icons and images match in size */
        .taskbar-icon i { font-size: var(--taskbar-icon-size); line-height: 1; display: inline-block; }
        .taskbar-icon img { width: var(--taskbar-icon-size); height: var(--taskbar-icon-size); display: inline-block; object-fit: contain; }
        /* For apps that are open (in background) */
        .taskbar-icon.open-app::after {
            content: '';
            position: absolute;
            bottom: 6px; /* keep gap from bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 3px; /* 較短 */
            background: var(--primary-cyan);
            opacity: 0.6;
            border-radius: 999px; /* pill */
            transition: all 0.15s ease;
        }

        /* For apps active in foreground */
        .taskbar-icon.active-app {
            background: rgba(255, 255, 255, 0.08);
        }
        .taskbar-icon.active-app::after {
            content: '';
            position: absolute;
            bottom: 6px; /* keep gap from bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 16px; /* 較長 */
            height: 3px;
            background: var(--primary-cyan);
            opacity: 1;
            border-radius: 999px; /* pill */
            box-shadow: 0 0 6px rgba(0, 212, 255, 0.15);
        }
        [data-theme="light"] .taskbar-icon.open-app::after {
            background: var(--primary-cyan);
            box-shadow: none;
        }
        [data-theme="light"] .taskbar-icon.active-app::after {
            box-shadow: none;
        }
        #start-button {
            font-size: 1.5rem;
            color: var(--primary-cyan);
            /* keep start button visually slightly larger but with consistent vertical sizing */
            padding: 0 8px;
            min-width: calc(var(--taskbar-icon-size) + 20px);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        /* Ensure the time widget fits exactly inside the taskbar and never stretches it.
           Use flexbox to vertically center the two lines (time/date) and limit height.
           Keep fonts/spacing unchanged to avoid altering displayed text sizes. */
        #taskbar-time {
            display: inline-flex;           /* make this a flex column so we can center vertically */
            flex-direction: column;         /* time above date */
            justify-content: center;        /* vertically center within taskbar */
            align-items: flex-end;          /* align text to the right */
            height: 100%;                   /* match parent taskbar height */
            max-height: 100%;
            box-sizing: border-box;         /* ensure padding included in height */
            font-family: var(--font-body);
            font-size: 0.9rem;
            text-align: right;
            padding: 0 10px;
            color: #e0e0e0;
            cursor: pointer;
            line-height: 1;                 /* avoid extra added height from default line height */
            overflow: hidden;               /* prevent overflowing elements from stretching it */
        }
        #taskbar-time:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Make sure the inner time/date elements do not have margins that increase height */
        #taskbar-time > div {
            margin: 0;
            padding: 0;
            line-height: 1;
            display: block;
            white-space: nowrap;
        }
        /* Keep AM/PM label same size as numbers and add spacing between them */
        #taskbar-time .ampm {
            margin-right: 3px; /* reduced spacing between AM/PM label and digits */
            /* Make the AM/PM label visually smaller than the numeric time
               while keeping good readability and alignment. Using em so
               it scales with the current font-size. */
            font-size: 0.8em;
            opacity: 0.95;
            line-height: 1; /* keep centered with the digits */
            display: inline-block;
            vertical-align: middle; /* align with digits */
            letter-spacing: 0.01em; /* keep label legible */
        }
        #taskbar-time .time-value {
            font-family: var(--font-body);
            font-size: inherit; /* preserve parent's font size */
            display: inline-block;
        }

        /* 4. 開始功能表 */
        #start-menu {
            position: absolute; /* 修改 */
            bottom: var(--taskbar-height);
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90vw;
            height: 500px;
            
            background: var(--mica-bg);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            
            border-radius: var(--window-border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            
            display: flex;
            flex-direction: column;
            overflow: hidden;
            
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(20px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: var(--z-start-menu);
        }
        #start-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* (省略開始功能表內部樣式... 保持不變) */
        .start-menu-header { padding: 15px 25px; }
        .search-bar { display: flex; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px; padding: 8px 15px; }
        .search-bar i { margin-right: 10px; color: #aaa; }
        .search-bar input { flex: 1; background: none; border: none; outline: none; color: #fff; font-family: var(--font-ui); font-size: 0.9rem; }
        .start-menu-body { flex: 1; padding: 10px 25px; overflow-y: auto; }
        .start-section-title { font-size: 0.9rem; font-weight: 500; color: #bbb; margin: 10px 0; }
        .pinned-apps { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 15px; }
        .app-icon { display: flex; flex-direction: column; align-items: center; padding: 10px 5px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; }
        .app-icon:hover { background: rgba(255, 255, 255, 0.1); }
        .app-icon i { font-size: 1.8rem; margin-bottom: 8px; }
        .app-icon span { font-size: 0.8rem; }
        .icon-settings { color: #9a9a9a; }
        .icon-nagato { color: var(--accent-pink); }
        /* Image-based app icons */
        .app-icon-img { width: 28px; height: 28px; object-fit: cover; border-radius: 6px; }
        .desktop-icon .app-icon-img { width: 56px; height: 56px; }
        .pinned-apps .app-icon .app-icon-img { width: 36px; height: 36px; }
        #taskbar .taskbar-icon .app-icon-img { width: var(--taskbar-icon-size); height: var(--taskbar-icon-size); }
        .window-title .app-icon-img { width: 18px; height: 18px; margin-right: 8px; }
        .icon-explorer { color: #f7d45f; }
        .icon-edge { color: #0078d7; }
        .icon-store { color: #00a4ef; }
        .recommended-list { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .recommended-item { display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; }
        .recommended-item:hover { background: rgba(255, 255, 255, 0.1); }
        .recommended-item i { font-size: 1.2rem; margin-right: 10px; color: #ccc; }
        .recommended-item-info { font-size: 0.85rem; }
        .recommended-item-info span { display: block; color: #aaa; font-size: 0.75rem; }
        .start-menu-footer { padding: 15px 25px; background: rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; }
        .user-profile { display: flex; align-items: center; cursor: pointer; }
        .user-profile i { font-size: 1.5rem; margin-right: 10px; background: var(--accent-purple); padding: 5px; border-radius: 50%; }
        /* Avatar image styles */
        .user-profile img.avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
            background-color: rgba(255, 255, 255, 0.03);
        }
        .power-button { font-size: 1.2rem; padding: 5px; cursor: pointer; border-radius: 4px; }
        .power-button:hover { background: rgba(255, 255, 255, 0.1); }


        /* 5. 視窗系統 */
        .window {
            position: absolute; /* 保持 absolute, 相對於 .simulator-container */
            width: 700px;
            height: 500px;
            min-width: 300px;
            min-height: 200px;
            
            background: rgba(25, 25, 40, 0.8);
            border-radius: var(--window-border-radius);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            
            display: flex;
            flex-direction: column;
            overflow: hidden;
            
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
        }
        .window.show { opacity: 1; visibility: visible; transform: scale(1); }
        /* Ensure active window stacks above other windows (calc for correct value) */
        .window.active { z-index: calc(var(--z-window) + 10); border-color: rgba(0, 212, 255, 0.5); }
        .window.minimized { display: none; }

        .window-header {
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px 0 15px;
            cursor: move;
            
            background: var(--mica-bg-light);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            flex-shrink: 0;
            /* Ensure the header (and its overlays like .snap-layouts) sits above window content (iframes/inputs) */
            position: relative;
            z-index: calc(var(--z-window) + 20);
        }
        .window-title { font-family: var(--font-body); font-weight: 500; font-size: 0.9rem; display: flex; align-items: center; }
        .window-title i { margin-right: 8px; font-size: 0.9rem; }

        .window-controls { display: flex; height: 100%; }
        .window-control-btn { width: 40px; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; cursor: pointer; transition: background-color 0.2s ease; position: relative; }
        .window-control-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .window-control-btn.close:hover { background: #e81123; }
        
        /* (省略貼齊佈局樣式... 保持不變) */
        /* Make sure snap layouts overlay remain on top of any inputs/iframes inside the window */
        .snap-layouts { position: absolute; top: calc(100% - 2px); right: 0; width: 130px; background: var(--mica-bg-dark); backdrop-filter: blur(var(--mica-blur)); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 6px; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; z-index: calc(var(--z-context-menu) + 2); pointer-events: auto; will-change: opacity; }
        /* Keep snap-layouts visible when the maximize button or the overlay itself is hovered/focused */
        .window-control-btn.maximize:hover .snap-layouts,
        .window-control-btn.maximize:focus-within .snap-layouts,
        .window-control-btn.maximize .snap-layouts:hover { opacity: 1; visibility: visible; }
        .snap-layout-option { height: 30px; border: 2px solid #888; border-radius: 4px; background: rgba(255, 255, 255, 0.1); cursor: pointer; pointer-events: auto; z-index: calc(var(--z-context-menu) + 3); }
        .snap-layout-option:hover { border-color: var(--primary-cyan); background: rgba(0, 212, 255, 0.2); }

        /* Snap preview overlay used when dragging windows near edges */
        #snap-preview {
            position: absolute;
            z-index: 1100; /* above windows but below start-menu overlays */
            background: rgba(0, 212, 255, 0.12);
            border: 2px dashed rgba(0, 212, 255, 0.35);
            border-radius: var(--window-border-radius);
            pointer-events: none;
            transition: opacity 0.12s ease, transform 0.12s ease;
            opacity: 0;
            visibility: hidden;
        }
        #snap-preview.show { opacity: 1; visibility: visible; }

        .window-content { flex: 1; padding: 15px; overflow: auto; font-family: var(--font-ui); font-size: 0.95rem; line-height: 1.6; }
        
        /* (省略調整大小 handle 樣式... 保持不變) */
          /* Keep resize handles present, but avoid placing them above interactive toolbar controls
              in the browser window; match behavior to win_b.html so the browsing input remains usable. */
          /* Ensure resize handles are above the window header so top-edge resizing works. Set
              z-index relative to the window layer value so it respects window stacking. */
          .resize-handle { position: absolute; background: transparent; z-index: calc(var(--z-window) + 30); pointer-events: auto; }
        .resize-handle.n { top: 0; left: 5px; right: 5px; height: 5px; cursor: n-resize; }
        .resize-handle.s { bottom: 0; left: 5px; right: 5px; height: 5px; cursor: s-resize; }
        .resize-handle.e { top: 5px; bottom: 5px; right: 0; width: 5px; cursor: e-resize; }
        .resize-handle.w { top: 5px; bottom: 5px; left: 0; width: 5px; cursor: w-resize; }
        .resize-handle.nw { top: 0; left: 0; width: 5px; height: 5px; cursor: nw-resize; }
        .resize-handle.ne { top: 0; right: 0; width: 5px; height: 5px; cursor: ne-resize; }
        .resize-handle.sw { bottom: 0; left: 0; width: 5px; height: 5px; cursor: sw-resize; }
        .resize-handle.se { bottom: 0; right: 0; width: 5px; height: 5px; cursor: se-resize; }


        /* 6. 應用程式內容 */
        /* (省略所有應用程式內容樣式... 保持不變) */
        .settings-content { display: flex; height: 100%; }
        .settings-sidebar { width: 200px; flex-shrink: 0; border-right: 1px solid rgba(255, 255, 255, 0.1); padding: 10px 0; }
        .settings-menu-item { display: flex; align-items: center; padding: 12px 20px; cursor: pointer; font-size: 0.9rem; }
        .settings-menu-item:hover { background: rgba(255, 255, 255, 0.05); }
        .settings-menu-item.active { background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--primary-cyan); padding-left: 17px; }
        .settings-menu-item i { margin-right: 15px; width: 20px; text-align: center; }
        .settings-main { flex: 1; padding: 20px; overflow-y: auto; }
        .setting-section { margin-bottom: 30px; }
        .setting-section h3 { font-family: var(--font-body); font-size: 1.5rem; color: var(--primary-cyan); border-bottom: 1px solid rgba(255, 255, 255, 0.2); padding-bottom: 10px; margin-bottom: 15px; }
        .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: rgba(0, 0, 0, 0.1); border-radius: 4px; }
        .setting-item-label { font-size: 0.9rem; }
        .setting-item-label span { display: block; font-size: 0.8rem; color: #aaa; }
        .nagato-content { display: flex; flex-direction: column; height: 100%; padding: 0; }
        .nagato-messages { flex: 1; padding: 15px; overflow-y: auto; background: rgba(0, 0, 0, 0.1); }
        .message { margin-bottom: 15px; padding: 10px 15px; border-radius: 10px; max-width: 80%; line-height: 1.5; }
        .message.user { background: var(--primary-cyan); color: #000; align-self: flex-end; margin-left: auto; border-bottom-right-radius: 2px; }
        .message.ai { background: rgba(255, 255, 255, 0.1); color: #f0f0f0; align-self: flex-start; border-bottom-left-radius: 2px; }
        .message-suggestions { margin-top: 8px; display: flex; gap: 6px; }
        .message-suggestions .suggestion-btn { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.04); color: #f0f0f0; padding: 6px 8px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; }
        .message-suggestions .suggestion-btn:hover { background: rgba(255,255,255,0.08); }
        .nagato-input-area { display: flex; padding: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .nagato-input-area textarea { flex: 1; padding: 10px; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; outline: none; color: #fff; font-family: var(--font-ui); resize: none; }
        .nagato-input-area button { background: var(--accent-pink); border: none; color: #000; padding: 0 15px; margin-left: 10px; border-radius: 4px; cursor: pointer; font-size: 1.1rem; }
        .nagato-input-area .clear-btn { background: transparent; border: none; color: #f0f0f0; padding: 0 10px; margin-left: 8px; border-radius: 6px; cursor: pointer; font-size: 1rem; height: 36px; align-self: center; }
        .nagato-input-area .clear-btn:hover { background: rgba(255,255,255,0.04); color: #fff; }
        .message.ai.typing { opacity: 0.9; }
        .typing-dots { display: inline-block; width: 36px; text-align: left; }
        .typing-dots span { display: inline-block; width: 6px; height: 6px; background: rgba(255,255,255,0.3); border-radius: 50%; margin: 0 2px; animation: dots 1.2s infinite; }
        .typing-dots span:nth-child(2) { animation-delay: 0.15s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.30s; }
        @keyframes dots { 0% { transform: translateY(0);} 50% { transform: translateY(-4px);} 100% { transform: translateY(0);} }
        .explorer-content { display: flex; height: 100%; padding: 0; background: #1e1e1e; }
        .explorer-sidebar { width: 220px; flex-shrink: 0; background: rgba(0, 0, 0, 0.1); padding: 10px; border-right: 1px solid rgba(255, 255, 255, 0.1); }
        .explorer-sidebar h4 { font-size: 0.9rem; color: #aaa; margin: 15px 0 5px 5px; }
        .explorer-item { display: flex; align-items: center; padding: 8px 10px; font-size: 0.9rem; border-radius: 4px; cursor: pointer; }
        .explorer-item:hover { background: rgba(255, 255, 255, 0.05); }
        .explorer-item i { margin-right: 10px; color: #ccc; }

        .explorer-main { flex: 1; padding: 15px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 20px; align-content: start; }
        /* 檔案總管滾動條箭頭 - 只顯示單一按鈕 */
        .explorer-main::-webkit-scrollbar-button:vertical:start:increment,
        .explorer-main::-webkit-scrollbar-button:vertical:end:decrement {
            display: none;
        }
        .folder-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
        .folder-icon i { font-size: 3rem; color: #f7d45f; margin-bottom: 5px; }
        .folder-icon span { font-size: 0.85rem; }
        .browser-content { padding: 0; overflow: hidden; display: flex; flex-direction: column; }
        /* Browser toolbar: slightly more compact to reduce vertical spacing to favorites bar below */
        /* Compact browser toolbar - reduce bottom margin to tighten spacing to favorites bar */
        .browser-toolbar { display: flex; align-items: center; padding: 6px 8px; background: rgba(0, 0, 0, 0.2); margin-bottom: 0; }
        .browser-toolbar input { flex: 1; padding: 5px 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; color: #fff; margin: 0 8px; font-size: 0.9rem; }
        .browser-toolbar i { padding: 5px; cursor: pointer; color: #ccc; }
        .browser-toolbar i.disabled { opacity: 0.35; cursor: not-allowed; }
        #bookmark-toggle { display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 8px; }
        #bookmark-toggle i.fa-solid { color: var(--primary-cyan); }
        /* Favorites bar (bookmarks) */
        /* Compact favorites bar - reduced height while keeping scroll capability; hide scrollbar visually */
        /* Compact favorites bar - smaller height and padding for tighter layout under the toolbar */
        /* Compact favorites bar - smaller padding and height for tighter layout under the toolbar */
        .favorites-bar { display: flex; gap: 6px; padding: 2px 8px; overflow-x: auto; align-items: center; height: 34px; background: rgba(0,0,0,0.08); border-bottom: 1px solid rgba(255,255,255,0.04); -ms-overflow-style: none; scrollbar-width: none; margin-top: 0; }
        .favorites-bar::-webkit-scrollbar { display: none; }
        .fav-item { display: inline-flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.02); color: #ddd; cursor: pointer; transition: background-color 0.15s ease; white-space: nowrap; border: 1px solid rgba(255,255,255,0.02); font-size: 0.9rem; }
        .fav-item:hover { background: rgba(255,255,255,0.06); }
        .fav-item i { font-size: 1rem; }
        .fav-item .title { font-size: 0.85rem; color: #f3f3f3; }
        /* Small favicon placeholder to the left of each fav item */
        .fav-item .favicon { width: 16px; height: 16px; display: inline-block; border-radius: 4px; object-fit: cover; background: rgba(255,255,255,0.04); }
        /* Edge-like tool bar (approximate from win12-main/apps/style/edge.css) */
        #win-edge { display: flex; flex-direction: column; height: 100%; }
        /* Edge-like toolbar: reduce padding and gap to make it more compact */
        /* Edge-like toolbar: reduce padding and gap to make it more compact */
        #win-edge > .tool { display: flex; gap: 6px; padding: 4px 6px; align-items: center; position: relative; z-index: 2; margin-bottom: 0; }
        #win-edge > .tool > .a { display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 6px; color: var(--text); cursor: pointer; transition: 50ms; background: transparent; text-decoration: none; }
        #win-edge > .tool > .a:hover { background-color: rgba(255,255,255,0.04); }
        #win-edge > .tool > .a.disabled { opacity: 0.25; pointer-events: none; }
        #win-edge > .tool > input.url { flex-grow: 1; background: rgba(255,255,255,0.03); padding: 6px 12px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.06); color: #fff; }
        /* Show/hide iframe depending on class 'show' to replicate edge.css pattern */
        #win-edge > iframe { width: calc(100% - 4px); flex-grow: 1; margin: 2px; border-radius: 10px; display: none; background: #ffffff; }
        #win-edge > iframe.show { display: block; }
        .browser-iframe { flex: 1; border: none; background: #fff; }
        .store-content { text-align: center; padding-top: 50px; }
        .store-content i { font-size: 4rem; color: var(--accent-purple); margin-bottom: 20px; }


        /* 7. 日曆彈窗 */
        #calendar-flyout {
            position: absolute; /* 修改 */
            bottom: var(--taskbar-height);
            right: 0;
            width: 320px;
            background: var(--mica-bg);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border-radius: var(--window-border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            padding: 15px;
            
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: var(--z-start-menu);
        }
        #calendar-flyout.show { opacity: 1; visibility: visible; transform: translateY(0); }
        
        /* (省略日曆內部樣式... 保持不變) */
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .calendar-header span { font-family: var(--font-body); font-size: 1.1rem; font-weight: 500; }
        .calendar-nav button { background: none; border: none; color: #f0f0f0; font-size: 1.2rem; cursor: pointer; padding: 5px; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-cell { text-align: center; padding: 8px; font-size: 0.85rem; border-radius: 50%; cursor: pointer; }
        .calendar-cell.day-name { font-weight: 600; color: #aaa; font-size: 0.75rem; cursor: default; }
        .calendar-cell.other-month { color: #666; }
        .calendar-cell.today { background: var(--primary-cyan); color: #000; font-weight: 700; }
        .calendar-cell:not(.day-name):not(.today):hover { background: rgba(255, 255, 255, 0.1); }


        /* 8. 小工具面板 (Widgets) */
        #widgets-panel {
            position: absolute; /* 修改 */
            top: 0;
            left: 0;
            width: 360px;
            height: 100%;
            
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.3);
            
            z-index: var(--z-start-menu);
            padding: 20px;
            padding-top: 50px;
            overflow-y: auto;
            
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #widgets-panel.show { transform: translateX(0); }

        /* (省略小工具內部樣式... 保持不變) */
        .widget { background: var(--mica-bg-light); border-radius: var(--window-border-radius); padding: 15px; margin-bottom: 20px; }
        .widget-header { font-family: var(--font-body); font-size: 1.1rem; font-weight: 500; margin-bottom: 10px; }
        .weather-widget { display: block; align-items: center; }
        .weather-controls { display:flex; gap:8px; margin-bottom:10px; }
        .weather-controls input[type="text"]{ flex:1; padding:8px 10px; border-radius:8px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); color: #fff; outline:none; }
        .weather-controls button{ background:transparent; border:none; color:var(--text); padding:6px 8px; border-radius:8px; cursor:pointer; }
        .weather-controls button[disabled]{ opacity: 0.6; cursor:not-allowed; }
        .weather-main{ display:flex; align-items:center; gap:12px; }
        .weather-visual #weather-icon { font-size: 3.2rem; color: var(--primary-yellow); }
        .weather-visual img{ width:56px; height:56px; object-fit:cover; border-radius:6px; }
        .weather-info .temp { font-size: 2rem; font-weight: 700; }
        .weather-info .desc { font-size: 0.9rem; color: #ccc; }
        .weather-info .meta { font-size: 0.8rem; color: #aaa; margin-top:4px; }
        .weather-forecast { display:flex; gap:8px; margin-top:12px; align-items:center; overflow-x:auto; }
        .weather-forecast .forecast-item { background: rgba(255,255,255,0.02); padding:8px; border-radius:6px; min-width:90px; text-align:center; }
        .weather-forecast .forecast-item .date{ font-size:0.8rem; color:#aaa; }
        .weather-forecast .forecast-item .temp{ font-weight:700; }
        .weather-info .temp { font-size: 2rem; font-weight: 700; }
        .weather-info .desc { font-size: 0.9rem; color: #ccc; }
        .news-item { display: flex; margin-bottom: 15px; }
        .news-item img { width: 60px; height: 60px; object-fit: cover; border-radius: 4px; margin-right: 10px; }
        .news-item-info { font-size: 0.85rem; }
        .news-item-info span { font-size: 0.75rem; color: #aaa; }

        /* ------------------------------------------------------------------ */
        /* Calc: Ensure calculator window does not show scrollbars when sized */
        /* - Use flexbox to let inner #win-calc fill the window-content area
           - Prevent min-height from causing overflow in flex children
           - Prevent inner scroll via overflow:hidden on the window content */
        /* ------------------------------------------------------------------ */
        #window-calculator .window-content {
            overflow: hidden;         /* prevent scrollbars */
            -ms-overflow-style: none; /* IE/Edge */
            scrollbar-width: none;    /* Firefox */
            display: flex;            /* create a flex container so children can scale */
            flex-direction: column;   /* stack input above keypad */
            padding: 10px;            /* slightly smaller padding for tighter fit */
        }

        /* Hide scrollbar on webkit-based browsers as extra precaution */
        #window-calculator .window-content::-webkit-scrollbar { display: none; }

        /* Make the win-calc element stretch to available height and be allowed to shrink */
        #window-calculator #win-calc {
            flex: 1 1 auto; /* grow and shrink to available space */
            min-height: 0;  /* allow shrinking inside flex container */
            display: flex;
            flex-direction: column;
        }

        /* Let keypad rows stretch proportionally so they always fit inside the
           window without forcing a scrollbar while keeping the buttons usable */
        #window-calculator #win-calc>.keyb {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, minmax(48px, 1fr)); /* use fractional rows to scale but keep minimum */
            gap: 6px;
        }

        /* Override fixed widths coming from calc.css to ensure responsive layout */
        #window-calculator #win-calc>.keyb>span { width: auto; margin: 0; height: auto; }

        /* Keep input area stable while allowing it to reduce when space is needed */
        #window-calculator #win-calc>.container {
            height: 90px; /* same as original win12-main, but flex layout prevents overflow */
            flex: 0 0 auto;
            display: flex;
            align-items: center;
        }

        /* Calc input tweaks */
        #window-calculator #calc-input {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: clamp(20px, 3.5vw, 35px);
            padding-right: 8px;
        }

        /* Ensure the calculator window can't be resized smaller than default size
           so the keypad never gets folded or clipped vertically. Also ensure the 
           minimum width is not larger than the default width (default inline width is 340px). */
        #window-calculator {
            min-height: 430px; /* match default window height so buttons won't be clipped */
            min-width: 320px;  /* smaller or equal to default width (340px) */
            width: 340px; /* set default width as desired; inline style already sets this */
        }

        /* Improve button look & feel for a tactile impression */
        #window-calculator #win-calc>.keyb>.b {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: auto; /* allow grid to control the height */
            min-height: 48px; /* keep buttons comfortably tappable */
            font-size: 1.05rem;
            padding: 0 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));
            box-shadow: 0 6px 12px rgba(0,0,0,0.35), inset 0 -2px 0 rgba(255,255,255,0.02);
            cursor: pointer;
            transition: transform 60ms ease, box-shadow 60ms ease, background 60ms ease;
            box-sizing: border-box; /* prevent padding from causing overflow */
            white-space: nowrap; /* prevent label wrapping */
            overflow: hidden; /* ensure text doesn't wrap and will be ellipsed */
            text-overflow: ellipsis;
        }
        #window-calculator #win-calc>.keyb>.b:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 18px rgba(0,0,0,0.42), inset 0 -2px 0 rgba(255,255,255,0.02);
        }
        #window-calculator #win-calc>.keyb>.b:active {
            transform: translateY(0);
            box-shadow: 0 3px 8px rgba(0,0,0,0.25), inset 0 -1px 0 rgba(255,255,255,0.01);
        }
        #window-calculator #win-calc>.keyb>.b:focus { outline: none; box-shadow: 0 0 0 3px rgba(0,212,255,0.12); }
        #window-calculator #win-calc>.keyb>.b { user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }

        /* Make special function keys visually distinct */
        #window-calculator #win-calc>.keyb>.b.u { background: linear-gradient(180deg, rgba(0,212,255,0.06), rgba(0,212,255,0.02)); }
        #window-calculator #win-calc>.keyb>.b.ans { background-image: linear-gradient(120deg, var(--theme-1), var(--theme-2)); color: #fff; border: none; }


        /* 9. 右鍵選單 */
        #context-menu {
            position: absolute; /* 修改 */
            width: 200px;
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.1s ease, transform 0.1s ease;
            z-index: var(--z-context-menu);
        }
        #context-menu.show { opacity: 1; visibility: visible; transform: scale(1); }
        
        /* (省略右鍵選單內部樣式... 保持不變) */
        .context-menu-item { display: flex; align-items: center; padding: 8px 12px; font-size: 0.9rem; border-radius: 4px; cursor: pointer; }
        .context-menu-item:hover { background: rgba(0, 212, 255, 0.2); }
        .context-menu-item i { width: 25px; text-align: center; margin-right: 8px; font-size: 0.9rem; }
        .context-menu-separator { height: 1px; background: rgba(255, 255, 255, 0.1); margin: 5px 0; }

        /* Start-menu-specific context menu */
        #start-context-menu {
            position: absolute;
            width: 220px;
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.1s ease, transform 0.1s ease, visibility 0.1s ease;
            z-index: var(--z-context-menu); /* higher than start menu */
            pointer-events: auto;
        }
        #start-context-menu.show { opacity: 1; visibility: visible; transform: scale(1); }


        /* --- 動畫 --- */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; color: var(--primary-cyan); }
            50% { opacity: 0.7; color: var(--accent-cyan); }
        }
        /* --- calculator embedded css (from win12-main/apps/style/calc.css) --- */
        @keyframes shine {
            0% { border-color: #111; }
            49% { border-color: #111; }
            51% { border-color: transparent; }
            98% { border-color: transparent; }
            100% { border-color: #111; }
        }

        /* Core calc layout */
        #win-calc { display: flex; flex-direction: column; padding: 5px; }
        #calc-input { border: none; border-right: 2px solid transparent; outline: none; background-color: transparent; font-size: 35px; text-align: end; color: var(--text); width: 100%; }
        #win-calc > .container { height: 90px; display: flex; align-items: center; }
        #calc-input:focus { border-color: #111; animation-name: shine; animation-duration: 1s; animation-iteration-count: infinite; }

        /* Key grid + button appearance */
        #win-calc > .keyb { flex-grow: 1; display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(5, minmax(48px, 1fr)); gap: 6px; }
        #win-calc > .keyb > .b { height: auto; min-height: 48px; font-size: 1.05rem; text-align: center; transition: transform 60ms ease, box-shadow 60ms ease, background 60ms ease; border-radius: 8px; border: 1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03)); box-shadow: 0 6px 12px rgba(0,0,0,0.35), inset 0 -2px 0 rgba(255,255,255,0.02); padding: 0 8px; }
        #win-calc > .keyb > .b:hover { transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.42), inset 0 -2px 0 rgba(255,255,255,0.02); }
        #win-calc > .keyb > .b:active { transform: translateY(0); box-shadow: 0 3px 8px rgba(0,0,0,0.25), inset 0 -1px 0 rgba(255,255,255,0.01); }
        #win-calc > .keyb > .b.ans { background-image: linear-gradient(120deg, var(--theme-1), var(--theme-2)); color: #fff; border: none; }
        #win-calc > .keyb > .b.u { padding-top: 5px; }
        #win-calc > .keyb > .b.checked { background-color: var(--mm) !important; }
        #win-calc > .keyb > span { width: auto; margin: 0; height: auto; }

        /* Make keypad accessible: clickable and keyboard focusable */
        #win-calc .b { cursor: pointer; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body>

    <!-- 1. 頂部導航 (使用全域 Header) -->
    <header>
        <a href="../../index.html">
            <div style="margin-left: 30px; font-family: 'Orbitron', sans-serif;">『 AMANO SHIZUKI 』</div>
        </a>
        <div class="nav-container">
            <ul class="nav-links">
                <div class="nav-header">
                    <h2 class="nav-title">選單導航</h2>
                </div>
                
                <div class="search-box">
                    <input type="text" id="navSearch" class="search-input" placeholder="搜尋頁面...">
                    <button class="search-btn" aria-label="Search">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="nav-section">
                    <h3 class="nav-section-title">主要頁面</h3>
                    <li><a href="../../pages/about.html" class="active">◆ ABOUT</a></li>
                    <li><a href="../../pages/experience.html">◆ EXPERIENCE</a></li>
                    <li><a href="../../pages/skills.html">◆ SKILLS</a></li>
                    <li><a href="../../pages/contact.html">◆ CONTACT</a></li>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">特別內容</h3>
                    <li><a href="../game-center/game-center.html">◆ GAME CENTER</a></li>
                    <li><a href="nagato-sakura-webos.html" class="active">◆ WEB OS</a></li>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">更多連結</h3>
                    <li>
                        <a href="https://www.youtube.com/@Amano_Shizuki_Kun" target="_blank" rel="noopener noreferrer" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                            </svg>
                            YouTube
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/AmanoShizukikun" target="_blank" rel="noopener noreferrer" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                            GitHub
                        </a>
                    </li>
                    <li>
                        <a href="https://discord.gg/jac8eAFzjz" target="_blank" rel="noopener noreferrer" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028c.462-.63.874-1.295 1.226-1.994a.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/>
                            </svg>
                            Discord
                        </a>
                    </li>
                    <li>
                        <a href="mailto:3b017128@gm.student.ncut.edu.tw" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                                <polyline points="22,6 12,13 2,6"></polyline>
                            </svg>
                            Email
                        </a>
                    </li>
                </div>
            </ul>
        </div>
        <div class="header-actions">
            <button class="settings-toggle" aria-label="Settings"></button>
            <button class="menu-toggle" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </header>

    <!-- 2. 主內容包裝器 (來自 win.html) -->
    <div class="main-wrapper">
        
        <!-- 3. 模擬器容器 (取代 main-content) -->
        <main class="simulator-container" id="simulator-container-main">
            <!-- Nightlight overlay: warm color overlay applied when nightlight enabled -->
            <div id="nightlight-overlay" aria-hidden="true"></div>
            
            <!-- 模擬器內容 (來自 win_improved.html) -->

            <!-- 1. 啟動加載器 -->
            <div id="boot-loader">
                <i id="boot-logo" class="fa-brands fa-windows"></i>
                <div id="boot-spinner"></div>
                <div id="boot-status">系統啟動中...</div>
            </div>

            <!-- start 的右鍵選單（開始設定） -->
            <div id="start-context-menu">
                <div class="context-menu-item" id="start-menu-settings"><i class="fa-solid fa-cog"></i> 開始設定</div>
            </div>

            <!-- 2. 桌面 -->
            <div id="desktop">
                <!-- 桌面圖示 -->
                <div class="desktop-icon" data-app="settings">
                    <i class="fa-solid fa-gear icon-settings"></i>
                    <span>設定</span>
                </div>
                <div class="desktop-icon" data-app="nagato">
                    <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img icon-nagato" loading="lazy">
                    <span>長門櫻</span>
                </div>
                <div class="desktop-icon" data-app="explorer">
                    <i class="fa-solid fa-folder icon-explorer"></i>
                    <span>檔案總管</span>
                </div>
                <div class="desktop-icon" data-app="browser">
                    <i class="fa-brands fa-edge icon-edge"></i>
                    <span>瀏覽器</span>
                </div>
                <div class="desktop-icon" data-app="store">
                    <i class="fa-solid fa-store icon-store"></i>
                    <span>應用商店</span>
                </div>
            </div>

            <!-- 3. 任務欄 -->
            <div id="taskbar">
                <div class="taskbar-group left">
                    <!-- 小工具按鈕 -->
                    <div class="taskbar-icon" id="widgets-button" title="小工具">
                        <i class="fa-solid fa-table-cells-large"></i>
                    </div>
                </div>
                
                <div class="taskbar-group center">
                    <!-- 開始按鈕 -->
                    <div class="taskbar-icon" id="start-button" title="開始">
                        <i class="fa-brands fa-windows"></i>
                    </div>
                    <!-- 搜尋 -->
                    <div class="taskbar-icon" id="search-button" title="搜尋">
                        <i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                    
                    <!-- 任務圖示 (動態) -->

                    <div class="taskbar-icon" id="taskbar-icon-nagato" data-app="nagato" data-pinned="true" title="長門櫻" role="button" tabindex="0" aria-pressed="false">
                        <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img" loading="lazy">
                    </div>
                    <div class="taskbar-icon" id="taskbar-icon-explorer" data-app="explorer" data-pinned="true" title="檔案總管" role="button" tabindex="0" aria-pressed="false">
                        <i class="fa-solid fa-folder icon-explorer"></i>
                    </div>
                    <div class="taskbar-icon" id="taskbar-icon-browser" data-app="browser" data-pinned="true" title="瀏覽器" role="button" tabindex="0" aria-pressed="false">
                        <i class="fa-brands fa-edge icon-edge"></i>
                    </div>
                    <div class="taskbar-icon" id="taskbar-icon-store" data-app="store" data-pinned="true" title="應用商店" role="button" tabindex="0" aria-pressed="false">
                        <i class="fa-solid fa-store icon-store"></i>
                    </div>
                </div>
                
                <div class="taskbar-group right">
                    <!-- 時間日期 -->
                    <div id="taskbar-time">
                        <div id="time"><span class="ampm">午前</span><span class="time-value">00:00</span></div>
                        <div id="date">YYYY/MM/DD</div>
                    </div>
                </div>
            </div>

            <!-- 4. 開始功能表 -->
            <div id="start-menu">
                <div class="start-menu-header">
                    <div class="search-bar">
                        <i class="fa-solid fa-magnifying-glass"></i>
                        <input type="text" placeholder="在這裡搜尋應用程式、設定和文件">
                    </div>
                </div>
                
                <div class="start-menu-body">
                    <div class="start-section-title">已釘選</div>
                    <div class="pinned-apps">
                        <div class="app-icon" data-app="settings">
                            <i class="fa-solid fa-gear icon-settings"></i>
                            <span>設定</span>
                        </div>
                        <div class="app-icon" data-app="nagato">
                            <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img" loading="lazy">
                            <span>長門櫻</span>
                        </div>
                        <div class="app-icon" data-app="explorer">
                            <i class="fa-solid fa-folder icon-explorer"></i>
                            <span>檔案總管</span>
                        </div>
                        <div class="app-icon" data-app="browser">
                            <i class="fa-brands fa-edge icon-edge"></i>
                            <span>瀏覽器</span>
                        </div>
                        <div class="app-icon" data-app="store">
                            <i class="fa-solid fa-store icon-store"></i>
                            <span>商店</span>
                        </div>
                        <div class="app-icon" data-app="calculator">
                            <i class="fa-solid fa-calculator" style="color: #4caf50;"></i>
                            <span>計算機</span>
                        </div>
                    </div>
                    
                    <div class="start-section-title">建議</div>
                    <div class="recommended-list">
                        <div class="recommended-item">
                            <i class="fa-solid fa-file-word" style="color: #2b579a;"></i>
                            <div class="recommended-item-info">
                                專案報告.docx
                                <span>15 分鐘前</span>
                            </div>
                        </div>
                        <div class="recommended-item">
                            <i class="fa-solid fa-image" style="color: #e81123;"></i>
                            <div class="recommended-item-info">
                                設計原型.png
                                <span>1 小時前</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="start-menu-footer">
                    <div class="user-profile">
                        <img src="../../assets/images/avatar.jpg" alt="天野靜樹" class="avatar" width="36" height="36" loading="lazy">
                        <span>天野靜樹</span>
                    </div>
                    <div class="power-button" title="電源">
                        <i class="fa-solid fa-power-off"></i>
                    </div>
                </div>
            </div>

            <!-- 5. 視窗 (多個) -->

            <!-- 5.1 設定視窗 -->
            <div class="window" id="window-settings" data-app="settings">
                <!-- 調整大小 Handles -->
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>

                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-gear icon-settings"></i>
                        <span>設定</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize" title="最小化">
                            <i class="fa-solid fa-minus"></i>
                        </div>
                        <div class="window-control-btn maximize" title="最大化">
                            <i class="fa-regular fa-square"></i>
                            <!-- 貼齊佈局 (新增) -->
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close" title="關閉">
                            <i class="fa-solid fa-xmark"></i>
                        </div>
                    </div>
                </div>
                <div class="window-content settings-content">
                    <div class="settings-sidebar">
                        <div class="settings-menu-item active">
                            <i class="fa-solid fa-display"></i> 顯示
                        </div>
                        <div class="settings-menu-item">
                            <i class="fa-solid fa-palette"></i> 個人化
                        </div>
                         <div class="settings-menu-item">
                            <i class="fa-solid fa-wifi"></i> 網路
                        </div>
                        <div class="settings-menu-item">
                            <i class="fa-solid fa-shield-halved"></i> 隱私權
                        </div>
                        <div class="settings-menu-item">
                            <i class="fa-solid fa-circle-info"></i> 關於
                        </div>
                    </div>
                    <div class="settings-main">
                        <div class="setting-section">
                            <h3>顯示</h3>
                            <div class="setting-item">
                                    <div class="setting-item-label">
                                        亮度
                                        <span>調整內建顯示器的亮度</span>
                                    </div>
                                    <div class="slider-control">
                                        <div class="slider-value" id="brightnessValue">70%</div>
                                        <input type="range" class="slider-range" id="displayBrightness" min="0" max="100" value="70" step="1" aria-label="顯示亮度">
                                    </div>
                                </div>
                            <div class="setting-item" id="nightlightItem" role="button" tabindex="0" aria-pressed="false">
                                <div class="setting-item-label">
                                    夜間光線
                                    <span>使用較暖的色彩以協助睡眠</span>
                                </div>
                                <div class="toggle-switch" id="nightLightToggle" role="switch" aria-checked="false" tabindex="0"></div>
                            </div>
                        </div>
                        <!-- Nightlight subpage: hidden by default -->
                        <div id="nightlight-settings" class="settings-subpage" style="display:none;">
                            <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                <button id="nightlight-back" style="padding:6px 8px; background:transparent; border:1px solid rgba(255,255,255,0.06); color:#f0f0f0; border-radius:6px;">← 返回</button>
                                <h3 style="margin:0;">夜間光線設定</h3>
                            </div>

                            <div class="setting-item">
                                <div class="setting-item-label">開關
                                    <span>在此啟用或停用夜間光線</span>
                                </div>
                                <div class="toggle-switch" id="nightlightSubToggle" role="switch" aria-checked="false" tabindex="0"></div>
                            </div>

                            <div class="setting-item">
                                <div class="setting-item-label">強度
                                    <span>調整夜間光線強度</span>
                                </div>
                                <div class="slider-control">
                                    <div class="slider-value" id="nightlightStrengthValue">50%</div>
                                    <input type="range" class="slider-range" id="nightlightStrength" min="0" max="100" value="50" step="1" aria-label="夜間光線強度">
                                </div>
                            </div>

                            <div class="setting-item">
                                <div class="setting-item-label">排程
                                    <span>設定自動開啟夜間光線的時間區間</span>
                                </div>
                                <div style="display:flex;align-items:center;gap:8px;">
                                    <div class="toggle-switch" id="nightlightScheduleToggle" role="switch" aria-checked="false" tabindex="0"></div>
                                </div>
                            </div>

                            <div id="nightlight-schedule-controls" style="display:none; margin-top:6px;">
                                <div class="setting-item">
                                    <div class="setting-item-label">開始時間
                                        <span>選擇要開始啟用夜間光線的時間</span>
                                    </div>
                                    <input type="time" id="nightlightStart" value="22:00" aria-label="夜間光線開始時間">
                                </div>
                                <div class="setting-item">
                                    <div class="setting-item-label">結束時間
                                        <span>選擇結束夜間光線的時間</span>
                                    </div>
                                    <input type="time" id="nightlightEnd" value="06:00" aria-label="夜間光線結束時間">
                                </div>
                            </div>
                        </div>
                        <div class="setting-section">
                            <h3>個人化</h3>
                            <div class="setting-item">
                                <div class="setting-item-label">
                                    主題
                                    <span>選擇深色或淺色模式</span>
                                </div>
                                <button style="padding: 5px 10px;">切換</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5.2 長門櫻 視窗 -->
            <div class="window" id="window-nagato" data-app="nagato" style="width: 400px; height: 600px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img" loading="lazy">
                        <span>長門櫻</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content nagato-content">
                    <div class="nagato-messages">
                        <div class="message ai">主人您好！我叫長門櫻，您的專屬女僕。請問您有什麼需要長門櫻為您效勞的嗎？</div>
                    </div>
                    <div class="nagato-input-area">
                        <textarea id="nagato-input" rows="1" placeholder="在這裡輸入..." aria-label="輸入訊息"></textarea>
                        <button id="nagato-clear" class="clear-btn" title="清除對話" aria-label="清除對話"><i class="fa-solid fa-trash"></i></button>
                        <button id="nagato-send" title="傳送"><i class="fa-solid fa-paper-plane"></i></button>
                    </div>
                </div>
            </div>
            
            <!-- 5.3 檔案總管視窗 (新增) -->
            <div class="window" id="window-explorer" data-app="explorer" style="width: 800px; height: 550px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-folder icon-explorer"></i>
                        <span>檔案總管</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content explorer-content">
                    <div class="explorer-sidebar">
                        <h4>快速存取</h4>
                        <div class="explorer-item"><i class="fa-solid fa-desktop"></i> 桌面</div>
                        <div class="explorer-item"><i class="fa-solid fa-download"></i> 下載</div>
                        <div class="explorer-item"><i class="fa-solid fa-file-lines"></i> 文件</div>
                        <h4>本機</h4>
                        <div class="explorer-item"><i class="fa-solid fa-hard-drive"></i> (C:)</div>
                    </div>
                    <div class="explorer-main">
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>文件</span></div>
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>下載</span></div>
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>音樂</span></div>
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>圖片</span></div>
                    </div>
                </div>
            </div>
            
            <!-- 5.4 瀏覽器視窗 (新增) -->
            <div class="window" id="window-browser" data-app="browser" style="width: 900px; height: 600px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-brands fa-edge icon-edge"></i>
                        <span>瀏覽器 (模擬)</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content browser-content">
                        <!-- 使用 Win12 Edge 風格的 toolbar 和 favorites bar -->
                        <div id="win-edge">
                            <div class="tool">
                                <a class="a" id="browser-back" title="上一頁"><i class="fa-solid fa-arrow-left"></i></a>
                                <a class="a" id="browser-forward" title="下一頁"><i class="fa-solid fa-arrow-right"></i></a>
                                <a class="a" id="browser-refresh" title="重新整理"><i class="fa-solid fa-rotate-right"></i></a>
                                <input id="browser-url-input" class="url" type="text" value="https://amanoshizukikun.github.io/" aria-label="網址列">
                                <a class="a" id="bookmark-toggle" title="管理最愛" aria-pressed="false"><i class="fa-regular fa-star"></i></a>
                            </div>

                            <!-- 最愛列 (Favorites bar) - 可滾動的按鈕列 -->
                            <div class="favorites-bar" id="favorites-bar" role="navigation" aria-label="最愛列">
                                <!-- JS will populate favorite items here -->
                            </div>
                        <iframe class="browser-iframe" src="about:blank" sandbox="allow-scripts allow-same-origin"></iframe>
                        </div>
                </div>
            </div>
            
            <!-- 5.5 應用商店視窗 (新增) -->
            <div class="window" id="window-store" data-app="store" style="width: 800px; height: 600px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-store icon-store"></i>
                        <span>應用商店</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content store-content">
                    <i class="fa-solid fa-shop"></i>
                    <h3>應用商店即將上線</h3>
                    <p>正在準備更多精彩的應用程式...</p>
                </div>
            </div>
            <!-- 5.6 計算機視窗 (新增) -->
            <div class="window" id="window-calculator" data-app="calculator" data-min-width="320" data-min-height="430" style="width: 340px; height: 430px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-calculator icon-calculator" style="color: #4caf50;"></i>
                        <span>計算機</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize" title="最小化"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize" title="最大化">
                            <i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close" title="關閉"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content" id="win-calc">
                    <div class="container">
                        <input id="calc-input" aria-label="計算機輸入" readonly="true" value="0" onkeydown="
                            switch (event.key) {
                                case '+':
                                    appCalculator.func_key(1);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.jia'));
                                    break;
                                case '-':
                                    appCalculator.func_key(2);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.jian'));
                                    break;
                                case '*':
                                    appCalculator.func_key(3);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.cheng'));
                                    break;
                                case '/':
                                    appCalculator.func_key(4);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.chu'));
                                    break;
                                case '=':
                                case 'Enter':
                                    appCalculator.eq();
                                    break;
                                case 'Backspace':
                                    appCalculator.backspace();
                                    break;
                                case '.':
                                    appCalculator.point();
                                    break;
                            }
                            if (!isNaN(event.key)) {
                                appCalculator.number_key(Number(event.key));
                            }
                        " />
                    </div>
                    <div class="keyb">
                        <a class="a b" onclick="appCalculator.square()">𝑥²</a>
                        <a class="a b" onclick="appCalculator.squareRoot()">√𝑥</a>
                        <a class="a b" onclick="appCalculator.clear_num()">C</a>
                        <a class="a b u jia" onclick="appCalculator.func_key(1); appCalculator.check(this);">+</a>
                        <a class="a b" onclick="appCalculator.number_key(7);">7</a>
                        <a class="a b" onclick="appCalculator.number_key(8);">8</a>
                        <a class="a b" onclick="appCalculator.number_key(9);">9</a>
                        <a class="a b u jian" onclick="appCalculator.func_key(2); appCalculator.check(this);">-</a>
                        <a class="a b" onclick="appCalculator.number_key(4);">4</a>
                        <a class="a b" onclick="appCalculator.number_key(5);">5</a>
                        <a class="a b" onclick="appCalculator.number_key(6);">6</a>
                        <a class="a b u cheng" onclick="appCalculator.func_key(3); appCalculator.check(this);">×</a>
                        <a class="a b" onclick="appCalculator.number_key(1);">1</a>
                        <a class="a b" onclick="appCalculator.number_key(2);">2</a>
                        <a class="a b" onclick="appCalculator.number_key(3);">3</a>
                        <a class="a b u chu" onclick="appCalculator.func_key(4); appCalculator.check(this);">÷</a>
                        <a class="a b" onclick="appCalculator.point()">.</a>
                        <a class="a b" onclick="appCalculator.number_key(0);">0</a>
                        <a class="a b" onclick="appCalculator.backspace()"><i class="fa-solid fa-delete-left"></i></a>
                        <a class="a b ans u" onclick="if(!appCalculator.eq()){ appCalculator.clear_num(); }">=</a>
                    </div>
                </div>
            </div>

            <!-- 6. 日曆彈窗 -->
            <div id="calendar-flyout">
                <div class="calendar-header">
                    <span id="calendar-month-year"></span>
                    <div class="calendar-nav">
                        <button id="calendar-prev"><i class="fa-solid fa-chevron-left"></i></button>
                        <button id="calendar-next"><i class="fa-solid fa-chevron-right"></i></button>
                    </div>
                </div>
                <div class="calendar-grid" id="calendar-grid">
                    <!-- 由 JS 生成 -->
                </div>
            </div>
            
            <!-- 7. 小工具面板 (新增) -->
            <div id="widgets-panel">
                <div class="widget weather-widget" id="widget-weather">
                    <div class="widget-header">天氣 <span id="weather-location" class="small">台北市</span></div>
                    <div class="weather-controls">
                        <input id="weather-city-input" type="text" aria-label="城市" placeholder="城市 (例如：Taipei / 台北)" />
                        <button id="weather-refresh" aria-label="刷新天氣" title="刷新"><i class="fa-solid fa-rotate-right"></i></button>
                        <button id="weather-geolocate" aria-label="使用定位" title="使用定位"><i class="fa-solid fa-location-crosshairs"></i></button>
                    </div>
                    <div class="weather-main">
                        <div class="weather-visual"><i id="weather-icon" class="fa-solid fa-cloud-sun"></i></div>
                        <div class="weather-info">
                            <div class="temp" id="weather-temp">--°C</div>
                            <div class="desc" id="weather-desc">載入中...</div>
                            <div class="meta"><span id="weather-humidity"></span> <span id="weather-feels"></span> <span id="weather-updated" style="margin-left:8px;color:#9aa; font-size:0.8rem"></span></div>
                        </div>
                    </div>
                    <div class="weather-forecast" id="weather-forecast"></div>
                </div>
                <div class="widget news-widget">
                    <div class="widget-header">頭條新聞</div>
                    <div class="news-item">
                        <img src="https://placehold.co/100x100/333/fff?text=NEWS" alt="News">
                        <div class="news-item-info">
                            這是一條模擬的新聞標題...
                            <span>2 小時前</span>
                        </div>
                    </div>
                    <div class="news-item">
                        <img src="https://placehold.co/100x100/555/fff?text=TECH" alt="Tech">
                        <div class="news-item-info">
                            關於網頁技術的最新進展...
                            <span>3 小時前</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 8. 右鍵選單 (新增) -->
            <div id="context-menu">
                <div class="context-menu-item"><i class="fa-solid fa-eye"></i> 檢視</div>
                <div class="context-menu-item"><i class="fa-solid fa-arrow-down-a-z"></i> 排序方式</div>
                <div class="context-menu-item"><i class="fa-solid fa-rotate-right"></i> 重新整理</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item"><i class="fa-solid fa-folder-plus"></i> 新增</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item"><i class="fa-solid fa-display"></i> 顯示設定</div>
                <div class="context-menu-item"><i class="fa-solid fa-palette"></i> 個人化</div>
            </div>

        </main>
        
        <!-- 4. 右側設定面板 (使用全域 Settings Panel) -->
        <div class="settings-panel">
            <div class="settings-header">
                <h2 class="settings-title">系統設定</h2>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-title">顯示設定</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>固定導航欄</span>
                        <span class="setting-description">保持導航欄在頂部固定</span>
                    </div>
                    <div class="toggle-switch" id="headerFixed"></div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>導航欄高度</span>
                        <span class="setting-description">調整頂部導航欄的高度</span>
                    </div>
                    <div class="slider-control">
                        <div class="slider-value" id="headerHeightValue">75px</div>
                        <input type="range" class="slider-range" id="headerHeight" min="50" max="100" value="75" step="5">
                        <div class="slider-marks">
                            <span data-value="50">小</span>
                            <span data-value="75">中</span>
                            <span data-value="100">大</span>
                        </div>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>視窗越界允許</span>
                        <span class="setting-description">允許視窗部分移出畫面的百分比 (左右/下方)</span>
                    </div>
                    <div class="slider-control">
                        <div class="slider-value" id="offscreenRatioValue">90%</div>
                        <input type="range" class="slider-range" id="offscreenRatio" min="0" max="100" value="90" step="5">
                        <div class="slider-marks">
                            <span data-value="0">0%</span>
                            <span data-value="50">50%</span>
                            <span data-value="100">100%</span>
                        </div>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>側邊欄文字顯示</span>
                        <span class="setting-description">是否持續顯示側邊欄文字標題</span>
                    </div>
                    <div class="toggle-switch active" id="sideNavTextVisible"></div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>主題模式</span>
                        <span class="setting-description">切換深色/淺色模式</span>
                    </div>
                    <div class="select-control">
                        <select id="themeMode">
                            <option value="dark">深色模式</option>
                            <option value="light">淺色模式</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-title">效能設定</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>動畫強度</span>
                        <span class="setting-description">調整頁面動畫效果強度</span>
                    </div>
                    <div class="slider-control">
                        <div class="slider-value" id="animationValue">強</div>
                        <input type="range" class="slider-range" id="animationStrength" min="0" max="2" value="2" step="1">
                        <div class="slider-marks">
                            <span data-value="0">關</span>
                            <span data-value="1">低</span>
                            <span data-value="2">強</span>
                        </div>
                    </div>
                </div>

                <div class="setting-item fps-monitor">
                    <div class="setting-label">
                        <span>幀數監控</span>
                        <span class="setting-description">即時顯示頁面渲染幀率</span>
                    </div>
                    <div class="fps-display">
                        <span class="fps-value" id="fpsValue">000</span>
                        <span class="fps-unit">FPS</span>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-title">音效設定</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>音效開關</span>
                        <span class="setting-description">啟用/關閉互動音效</span>
                    </div>
                    <div class="toggle-switch active" id="soundEnabled"></div>
                </div>
            </div>
        </div>

    </div>


    <script src="../../assets/js/core.js"></script>
    <script src="../../assets/js/navigation.js"></script>
    <script src="../../assets/js/animations.js"></script>

    <!-- Calc dependencies: jQuery (for the kernel), Big.js (arbitrary precision), and calculator kernel script -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/big.js/6.2.1/big.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- 0. 獲取 DOM 元素 ---
            // 修改：獲取模擬器容器
            const simulatorContainer = document.getElementById('simulator-container-main');
            
            const bootLoader = document.getElementById('boot-loader');
            const desktop = document.getElementById('desktop');
            const taskbar = document.getElementById('taskbar');
            const startButton = document.getElementById('start-button');
            const startMenu = document.getElementById('start-menu');
            const taskbarTime = document.getElementById('taskbar-time');
            const timeEl = document.getElementById('time');
            const timeAmpmEl = timeEl.querySelector('.ampm');
            const timeValueEl = timeEl.querySelector('.time-value');
            const dateEl = document.getElementById('date');
            const calendarFlyout = document.getElementById('calendar-flyout');
            const calendarGrid = document.getElementById('calendar-grid');
            const calendarMonthYear = document.getElementById('calendar-month-year');
            const calendarPrev = document.getElementById('calendar-prev');
            const calendarNext = document.getElementById('calendar-next');
            const widgetsButton = document.getElementById('widgets-button');
            const widgetsPanel = document.getElementById('widgets-panel');
            const contextMenu = document.getElementById('context-menu');
            
            const windows = document.querySelectorAll('.window');
            // Keep a NodeList of pinned icons (static), but we will dynamically create temporary icons for apps opened
            const pinnedTaskbarIcons = document.querySelectorAll('.taskbar-icon[data-app][data-pinned]');
            function getAllTaskbarIcons() { return document.querySelectorAll('.taskbar-icon[data-app]'); }
            const desktopIcons = document.querySelectorAll('.desktop-icon[data-app]');
            
            let calendarDate = new Date();
            let activeWindow = null;
            let highestZIndex = 100;

            /* Calculator class (embedded) - previously loaded from win12-main/scripts/calculator_kernel.js */
            class Calculator {
                constructor(inputSelector, keysContainerSelector) {
                    this.eltSelector = inputSelector;
                    this.elt = document.querySelector(inputSelector);
                    this.num1 = null;
                    this.num2 = null;
                    this.keysContainer = document.querySelector(keysContainerSelector);
                    this.operator = 0;
                    this.preview = false;
                }

                get_num() { return Big(this.elt.value); }

                number_key(key) {
                    if (!this.elt) return;
                    if (this.elt.value === '0' || this.preview) {
                        this.elt.value = '';
                        this.preview = false;
                    }
                    this.elt.value += key;
                    this.uncheck();
                }

                func_key(key) {
                    if (!this.elt) return;
                    if (!this.isCheck()) {
                        if (this.num1 != null) {
                            this.num2 = Big(this.elt.value);
                            this.num1 = Big(this._calc(this.num1, this.num2, this.operator));
                            this.elt.value = this.num1;
                            this.preview = true;
                        } else {
                            this.num1 = Big(this.elt.value);
                            this.elt.value = this.num1;
                            this.preview = true;
                        }
                    }
                    this.operator = key;
                }

                check(elt) {
                    this.uncheck();
                    if (elt) elt.classList.add('checked');
                }

                uncheck() {
                    if (!this.keysContainer) return;
                    for (const elt of this.keysContainer.children) {
                        elt.classList.remove('checked');
                    }
                }

                isCheck() { if (!this.keysContainer) return false; for (const elt of this.keysContainer.children) { if (elt.classList.contains('checked')) return true; } return false; }

                point() { if (!this.elt) return; if (this.elt.value === '') this.elt.value = '0'; if (!this.elt.value.includes('.')) this.elt.value += '.'; }

                square() { if (!this.elt) return; this.elt.value = (Number(this.get_num().toString()) ** 2).toString(); }
                squareRoot() { if (!this.elt) return; this.elt.value = Math.sqrt(Number(this.get_num().toString())); }

                backspace() { if (!this.elt) return; if (this.elt.value.length > 0) { this.elt.value = this.elt.value.substring(0, this.elt.value.length - 1); } if (this.elt.value === '') this.elt.value = '0'; }

                clear_num() { if (!this.elt) return; this.elt.value = '0'; this.num1 = null; this.num2 = null; this.operator = 0; this.uncheck(); }

                eq() {
                    if (!this.elt) return true;
                    this.uncheck();
                    if (this.operator === 0) return true;
                    this.num2 = Big(this.elt.value);
                    var num = this._calc(this.num1, this.num2, this.operator);
                    this.clear_num();
                    if (num != null) { this.elt.value = num; return true; }
                    // division by zero or other calculation error: show user-friendly error
                    try { this.elt.value = '錯誤'; this.preview = true; setTimeout(() => { if (this.elt) this.elt.value = '0'; }, 1400); } catch (e) {}
                    return false;
                }

                _calc(n1, n2, c) {
                    try {
                        switch (c) {
                            case 1: return n1.plus(n2).toString();
                            case 2: return n1.minus(n2).toString();
                            case 3: return n1.times(n2).toString();
                            case 4: return (n2 != 0) ? n1.div(n2).toString() : null;
                        }
                    } catch (err) { console.error('Calculation error', err); return null; }
                }
            }

            // --- Display settings: brightness + nightlight ---
            const displayBrightness = document.getElementById('displayBrightness');
            const brightnessValue = document.getElementById('brightnessValue');
            const nightLightToggle = document.getElementById('nightLightToggle');
            const nightlightOverlay = document.getElementById('nightlight-overlay');
            // Subpage controls
            const nightlightItem = document.getElementById('nightlightItem');
            const nightlightSubpage = document.getElementById('nightlight-settings');
            const nightlightBack = document.getElementById('nightlight-back');
            const nightlightStrength = document.getElementById('nightlightStrength');
            const nightlightStrengthValue = document.getElementById('nightlightStrengthValue');
            const nightlightScheduleToggle = document.getElementById('nightlightScheduleToggle');
            const nightlightSubToggle = document.getElementById('nightlightSubToggle');
            const nightlightStartInput = document.getElementById('nightlightStart');
            const nightlightEndInput = document.getElementById('nightlightEnd');

            const DISPLAY_STORAGE_KEY = 'webos_display_settings';

            function mapSliderToBrightness(val) {
                // Map 0..100 slider to 0.6..1.2 brightness range
                const v = parseFloat(val);
                const min = 0.6;
                const max = 1.2;
                return (min + (v / 100) * (max - min)).toFixed(3);
            }

            function mapSliderToNightlightOpacity(val) {
                const v = parseFloat(val);
                const maxOpacity = 0.5; // maximum warm overlay alpha (increased for stronger effect)
                return (v / 100 * maxOpacity).toFixed(3);
            }

            function applyDisplaySettings(settings) {
                const brightVal = (settings && typeof settings.brightness !== 'undefined') ? settings.brightness : Number(displayBrightness.value || 70);
                const night = settings && !!settings.nightLight;
                const nightStrength = settings && typeof settings.nightlightStrength !== 'undefined' ? settings.nightlightStrength : (nightlightStrength ? Number(nightlightStrength.value) : 50);
                const scheduleEnabled = settings && !!settings.nightlightScheduleEnabled;
                const scheduleStart = settings && settings.nightlightScheduleStart ? settings.nightlightScheduleStart : (nightlightStartInput ? nightlightStartInput.value : '22:00');
                const scheduleEnd = settings && settings.nightlightScheduleEnd ? settings.nightlightScheduleEnd : (nightlightEndInput ? nightlightEndInput.value : '06:00');

                // Update UI controls
                if (displayBrightness) {
                    displayBrightness.value = brightVal;
                    if (brightnessValue) brightnessValue.textContent = `${brightVal}%`;
                    const bFactor = mapSliderToBrightness(brightVal);
                    document.documentElement.style.setProperty('--simulator-brightness', bFactor);
                }

                if (nightLightToggle && nightlightOverlay) {
                    if (night) {
                        nightLightToggle.classList.add('active');
                        nightLightToggle.setAttribute('aria-checked', 'true');
                        // use opacity 0.12 as a gentle warm overlay
                        nightlightOverlay.style.opacity = '1';
                        document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(nightStrength));
                    } else {
                        nightLightToggle.classList.remove('active');
                        nightLightToggle.setAttribute('aria-checked', 'false');
                        nightlightOverlay.style.opacity = '0';
                        document.documentElement.style.setProperty('--nightlight-opacity', '0');
                    }
                    // sync subpage toggle as well (if present)
                    if (nightlightSubToggle) {
                        if (night) {
                            nightlightSubToggle.classList.add('active');
                            nightlightSubToggle.setAttribute('aria-checked', 'true');
                        } else {
                            nightlightSubToggle.classList.remove('active');
                            nightlightSubToggle.setAttribute('aria-checked', 'false');
                        }
                    }
                }

                // Apply strength UI
                if (nightlightStrength && nightlightStrengthValue) {
                    nightlightStrength.value = nightStrength;
                    nightlightStrengthValue.textContent = `${nightStrength}%`;
                    document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(nightStrength));
                }

                // Schedule UI
                if (nightlightScheduleToggle) {
                    if (scheduleEnabled) {
                        nightlightScheduleToggle.classList.add('active');
                        nightlightScheduleToggle.setAttribute('aria-checked', 'true');
                        if (nightlightStartInput && nightlightEndInput) {
                            nightlightStartInput.value = scheduleStart;
                            nightlightEndInput.value = scheduleEnd;
                        }
                        if (document.getElementById('nightlight-schedule-controls')) document.getElementById('nightlight-schedule-controls').style.display = 'block';
                    } else {
                        nightlightScheduleToggle.classList.remove('active');
                        nightlightScheduleToggle.setAttribute('aria-checked', 'false');
                        if (document.getElementById('nightlight-schedule-controls')) document.getElementById('nightlight-schedule-controls').style.display = 'none';
                    }
                }
            }

            function saveDisplaySettings() {
                const settings = {
                    brightness: Number(displayBrightness ? displayBrightness.value : 70),
                    nightLight: nightLightToggle ? nightLightToggle.classList.contains('active') : false,
                    nightlightStrength: nightlightStrength ? Number(nightlightStrength.value) : 50,
                    nightlightScheduleEnabled: nightlightScheduleToggle ? nightlightScheduleToggle.classList.contains('active') : false,
                    nightlightScheduleStart: nightlightStartInput ? nightlightStartInput.value : '22:00',
                    nightlightScheduleEnd: nightlightEndInput ? nightlightEndInput.value : '06:00'
                };
                try { localStorage.setItem(DISPLAY_STORAGE_KEY, JSON.stringify(settings)); } catch (e) { /* ignore */ }
            }

            // Initialize from localStorage
            try {
                const saved = JSON.parse(localStorage.getItem(DISPLAY_STORAGE_KEY) || 'null');
                applyDisplaySettings(saved || null);
            } catch (err) {
                applyDisplaySettings(null);
            }
            // Apply schedule immediately on load in case scheduling should enable/disable nightlight
            try { applyScheduleIfNeeded(); } catch (e) { /* ignore */ }

            // Hook up brightness slider
            if (displayBrightness) {
                displayBrightness.addEventListener('input', (e) => {
                    const val = e.target.value;
                    if (brightnessValue) brightnessValue.textContent = `${val}%`;
                    const bFactor = mapSliderToBrightness(val);
                    document.documentElement.style.setProperty('--simulator-brightness', bFactor);
                    saveDisplaySettings();
                });
            }

            // Hook up nightlight toggle
            if (nightLightToggle) {
                nightLightToggle.addEventListener('click', (e) => {
                    const enabled = nightLightToggle.classList.toggle('active');
                    nightLightToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    if (nightlightOverlay) {
                        if (enabled) {
                            nightlightOverlay.style.opacity = '1';
                            const curr = nightlightStrength ? nightlightStrength.value : 50;
                            document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(curr));
                            // sync sub toggle
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.add('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'true');
                            }
                        } else {
                            nightlightOverlay.style.opacity = '0';
                            document.documentElement.style.setProperty('--nightlight-opacity', '0');
                            // sync sub toggle
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.remove('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'false');
                            }
                        }
                    }
                    saveDisplaySettings();
                });
                nightLightToggle.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        nightLightToggle.click();
                    }
                });
            }

            // Subpage toggle: synchronize with main nightLightToggle
            if (nightlightSubToggle) {
                // initial sync
                if (nightLightToggle && nightLightToggle.classList.contains('active')) {
                    nightlightSubToggle.classList.add('active');
                    nightlightSubToggle.setAttribute('aria-checked', 'true');
                }
                nightlightSubToggle.addEventListener('click', () => {
                    const enabled = nightlightSubToggle.classList.toggle('active');
                    nightlightSubToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    // propagate to main toggle
                    if (nightLightToggle) {
                        if (enabled) nightLightToggle.classList.add('active'); else nightLightToggle.classList.remove('active');
                        nightLightToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    }
                    if (nightlightOverlay) {
                        if (enabled) {
                            nightlightOverlay.style.opacity = '1';
                            const curr = nightlightStrength ? nightlightStrength.value : 50;
                            document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(curr));
                        } else {
                            nightlightOverlay.style.opacity = '0';
                            document.documentElement.style.setProperty('--nightlight-opacity', '0');
                        }
                    }
                    saveDisplaySettings();
                });
                nightlightSubToggle.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); nightlightSubToggle.click(); } });
            }

            // Show / open subpage when clicking the setting-item (not the toggle)
            if (nightlightItem && nightlightSubpage) {
                const settingsSections = Array.from(document.querySelectorAll('.setting-section'));
                function openNightlightSubpage() {
                    settingsSections.forEach(s=>s.style.display = 'none');
                    nightlightSubpage.style.display = 'block';
                }
                function closeNightlightSubpage() {
                    settingsSections.forEach(s=>s.style.display = 'block');
                    nightlightSubpage.style.display = 'none';
                }
                nightlightItem.addEventListener('click', (e) => {
                    // if clicked on the toggle or on interactive elements inside, ignore — toggle handled separately
                    if (e.target === nightLightToggle || nightLightToggle.contains(e.target)) return;
                    openNightlightSubpage();
                });
                nightlightItem.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); nightlightItem.click(); } });
                // Back button
                if (nightlightBack) {
                    nightlightBack.addEventListener('click', (e) => { e.preventDefault(); closeNightlightSubpage(); });
                }
            }

            // Nightlight strength slider
            if (nightlightStrength) {
                nightlightStrength.addEventListener('input', (e) => {
                    const val = e.target.value;
                    if (nightlightStrengthValue) nightlightStrengthValue.textContent = `${val}%`;
                    const opacity = mapSliderToNightlightOpacity(val);
                    document.documentElement.style.setProperty('--nightlight-opacity', opacity);
                    // If toggle on, ensure overlay visible
                    if (nightLightToggle && nightLightToggle.classList.contains('active')) {
                        nightlightOverlay.style.opacity = '1';
                    }
                    saveDisplaySettings();
                });
            }

            // Schedule toggle & controls
            function isTimeInRange(startHHMM, endHHMM, now = new Date()) {
                if (!startHHMM || !endHHMM) return false;
                const [sh, sm] = startHHMM.split(':').map(Number);
                const [eh, em] = endHHMM.split(':').map(Number);
                const start = new Date(now);
                start.setHours(sh, sm, 0, 0);
                const end = new Date(now);
                end.setHours(eh, em, 0, 0);
                if (start.getTime() === end.getTime()) return true;
                if (start < end) {
                    return now >= start && now <= end;
                } else {
                    // wraps overnight
                    return now >= start || now <= end;
                }
            }

            function applyScheduleIfNeeded() {
                try {
                    const raw = localStorage.getItem(DISPLAY_STORAGE_KEY) || 'null';
                    const saved = JSON.parse(raw);
                    if (!saved) return;
                    const enabled = !!saved.nightlightScheduleEnabled;
                    const start = saved.nightlightScheduleStart;
                    const end = saved.nightlightScheduleEnd;
                    if (!enabled) return; // nothing to auto-apply
                    const nowShouldBeOn = isTimeInRange(start, end, new Date());
                    if (nightLightToggle && nightLightToggle.classList.contains('active') !== nowShouldBeOn) {
                        if (nowShouldBeOn) {
                            nightLightToggle.classList.add('active');
                            nightLightToggle.setAttribute('aria-checked', 'true');
                            nightlightOverlay.style.opacity = '1';
                            // ensure CSS property set according to strength
                            const curr = nightlightStrength ? nightlightStrength.value : 50;
                            document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(curr));
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.add('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'true');
                            }
                            saveDisplaySettings();
                        } else {
                            nightLightToggle.classList.remove('active');
                            nightLightToggle.setAttribute('aria-checked', 'false');
                            nightlightOverlay.style.opacity = '0';
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.remove('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'false');
                            }
                            saveDisplaySettings();
                        }
                    }
                } catch (err) {
                    /* ignore errors */
                }
            }

            if (nightlightScheduleToggle) {
                nightlightScheduleToggle.addEventListener('click', () => {
                    const enabled = nightlightScheduleToggle.classList.toggle('active');
                    nightlightScheduleToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    if (document.getElementById('nightlight-schedule-controls')) document.getElementById('nightlight-schedule-controls').style.display = enabled ? 'block' : 'none';
                    saveDisplaySettings();
                    if (enabled) applyScheduleIfNeeded();
                });
                nightlightScheduleToggle.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); nightlightScheduleToggle.click(); } });
            }

            if (nightlightStartInput) nightlightStartInput.addEventListener('change', () => { saveDisplaySettings(); if (nightlightScheduleToggle && nightlightScheduleToggle.classList.contains('active')) applyScheduleIfNeeded(); });
            if (nightlightEndInput) nightlightEndInput.addEventListener('change', () => { saveDisplaySettings(); if (nightlightScheduleToggle && nightlightScheduleToggle.classList.contains('active')) applyScheduleIfNeeded(); });

            // Check schedule every minute
            setInterval(applyScheduleIfNeeded, 60 * 1000);

            // Global drag/resize state (one set of handlers for all windows)
            // Implementation notes:
            // - Uses `actionState` to track the current operation (drag/resize)
            // - Pointer events are supported via pointerdown/pointermove/pointerup
            // - requestAnimationFrame is used to throttle DOM updates for smoother dragging/resizing
            // - When resizing from 'left' or 'top', the opposite edge (right/bottom) is anchored
            //   to prevent the window from shifting its position unexpectedly.
            const actionState = {
                type: null, // 'drag' | 'resize'
                windowEl: null,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0,
                startWidth: 0,
                startHeight: 0,
                direction: ''
                ,pointerId: null,
                captureTarget: null,
                restoreOnDrag: false
            };
            function initBootSequence() {
                const status = document.getElementById('boot-status');
                setTimeout(() => {
                    status.textContent = '載入核心模組...';
                }, 1000);
                setTimeout(() => {
                    status.textContent = '啟動使用者介面...';
                }, 2000);
                setTimeout(() => {
                    bootLoader.style.opacity = '0';
                    setTimeout(() => {
                        bootLoader.remove();
                    }, 500);
                }, 3000);
            }

            // --- 2. 時間與日期 ---
            function updateTime() {
                const now = new Date();
                // Manual 12-hour formatting with localized AM/PM labels (午前/午後).
                const hours24 = now.getHours();
                const minutes = now.getMinutes();
                const isAM = hours24 < 12;
                const ampmLabel = isAM ? '午前' : '午後';
                // Convert to 12-hour clock (show 12 instead of 0)
                let hours12 = hours24 % 12;
                if (hours12 === 0) hours12 = 12;
                const hh = String(hours12).padStart(2, '0');
                const mm = String(minutes).padStart(2, '0');
                // Update the separate elements so we can style them independently and keep spacing consistent.
                if (timeAmpmEl) timeAmpmEl.textContent = ampmLabel;
                if (timeValueEl) timeValueEl.textContent = `${hh}:${mm}`;
                // Keep the date in zh-TW format as before.
                dateEl.textContent = now.toLocaleDateString('zh-TW');
            }
            setInterval(updateTime, 1000);
            updateTime();

            // --- 3. 日曆 ---
            function renderCalendar() {
                calendarGrid.innerHTML = '';
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                calendarMonthYear.textContent = `${year}年 ${month + 1}月`;
                
                // 星期
                const days = ['日', '一', '二', '三', '四', '五', '六'];
                days.forEach(day => {
                    const cell = document.createElement('div');
                    cell.classList.add('calendar-cell', 'day-name');
                    cell.textContent = day;
                    calendarGrid.appendChild(cell);
                });

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const today = new Date();

                // 上個月的日期
                for (let i = 0; i < firstDay; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('calendar-cell', 'other-month');
                    calendarGrid.appendChild(cell);
                }

                // 這個月的日期
                for (let i = 1; i <= daysInMonth; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('calendar-cell');
                    cell.textContent = i;
                    if (i === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
                        cell.classList.add('today');
                    }
                    calendarGrid.appendChild(cell);
                }
            }
            calendarPrev.addEventListener('click', () => {
                calendarDate.setMonth(calendarDate.getMonth() - 1);
                renderCalendar();
            });
            calendarNext.addEventListener('click', () => {
                calendarDate.setMonth(calendarDate.getMonth() + 1);
                renderCalendar();
            });
            taskbarTime.addEventListener('click', (e) => {
                e.stopPropagation();
                calendarFlyout.classList.toggle('show');
                startMenu.classList.remove('show');
                widgetsPanel.classList.remove('show');
            });

            // --- 4. 開始功能表 ---
            startButton.addEventListener('click', (e) => {
                e.stopPropagation();
                startMenu.classList.toggle('show');
                calendarFlyout.classList.remove('show');
                widgetsPanel.classList.remove('show');
            });
            
            // --- 5. 小工具面板 ---
            widgetsButton.addEventListener('click', (e) => {
                e.stopPropagation();
                widgetsPanel.classList.toggle('show');
                startMenu.classList.remove('show');
                calendarFlyout.classList.remove('show');
            });

            // --- 6. 全域點擊 (隱藏彈窗) ---
            // 修改：只在模擬器容器內點擊時觸發
            simulatorContainer.addEventListener('click', (e) => {
                if (!startMenu.contains(e.target) && e.target !== startButton) {
                    startMenu.classList.remove('show');
                }
                if (!calendarFlyout.contains(e.target) && e.target !== taskbarTime) {
                    calendarFlyout.classList.remove('show');
                }
                if (!widgetsPanel.contains(e.target) && e.target !== widgetsButton) {
                    widgetsPanel.classList.remove('show');
                }
                contextMenu.classList.remove('show');
                // Hide start menu context if visible
                const startCtx = document.getElementById('start-context-menu');
                if (startCtx) startCtx.classList.remove('show');
            });
            // 點擊模擬器外部也隱藏
             document.addEventListener('click', (e) => {
                if (!simulatorContainer.contains(e.target)) {
                    startMenu.classList.remove('show');
                    calendarFlyout.classList.remove('show');
                    widgetsPanel.classList.remove('show');
                    contextMenu.classList.remove('show');
                    const startCtx2 = document.getElementById('start-context-menu');
                    if (startCtx2) startCtx2.classList.remove('show');
                }
            });
            
            // --- 7. 右鍵選單 ---
            desktop.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                
                // 修改：計算相對於 desktop 的位置
                const desktopRect = desktop.getBoundingClientRect();
                const styleTop = e.clientY - desktopRect.top;
                const styleLeft = e.clientX - desktopRect.left;
                
                // 邊界檢查，防止選單超出桌面
                const menuWidth = contextMenu.offsetWidth || 200;
                const menuHeight = contextMenu.offsetHeight || 200;
                
                let finalLeft = styleLeft;
                let finalTop = styleTop;

                if (styleLeft + menuWidth > desktop.clientWidth) {
                    finalLeft = desktop.clientWidth - menuWidth;
                }
                if (styleTop + menuHeight > desktop.clientHeight) {
                    finalTop = desktop.clientHeight - menuHeight;
                }

                contextMenu.style.top = `${finalTop}px`;
                contextMenu.style.left = `${finalLeft}px`;
                contextMenu.classList.add('show');
                // Hide any start-context-menu if visible
                const startCtx = document.getElementById('start-context-menu');
                if (startCtx) startCtx.classList.remove('show');
            });

            // Start-menu body right-click: open a start-specific context menu (positioned at mouse location)
            const startMenuBodyEl = document.querySelector('#start-menu .start-menu-body');
            const startContextMenu = document.getElementById('start-context-menu');
            if (startMenuBodyEl && startContextMenu) {
                startMenuBodyEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Position relative to the simulator container (same as desktop context menu)
                    const containerRect = simulatorContainer.getBoundingClientRect();
                    let styleTop = e.clientY - containerRect.top;
                    let styleLeft = e.clientX - containerRect.left;

                    const menuWidth = startContextMenu.offsetWidth || 220;
                    const menuHeight = startContextMenu.offsetHeight || 100;

                    if (styleLeft + menuWidth > simulatorContainer.clientWidth) {
                        styleLeft = simulatorContainer.clientWidth - menuWidth;
                        if (styleLeft < 0) styleLeft = 0;
                    }
                    if (styleTop + menuHeight > simulatorContainer.clientHeight) {
                        styleTop = simulatorContainer.clientHeight - menuHeight;
                        if (styleTop < 0) styleTop = 0;
                    }

                    startContextMenu.style.left = `${styleLeft}px`;
                    startContextMenu.style.top = `${styleTop}px`;
                    startContextMenu.classList.add('show');
                    // ensure we hide the global desktop context menu
                    contextMenu.classList.remove('show');
                });

                // Close it when clicking the Start menu header or anywhere else inside the start menu but not the menu itself
                startMenu.addEventListener('click', (e) => {
                    if (!startContextMenu.contains(e.target)) startContextMenu.classList.remove('show');
                });
            }

            // --- 8. 視窗管理 ---
            
            // 8.1 設為活躍
            function focusWindow(windowEl) {
                // If the window is minimized, restore it first
                if (windowEl && windowEl.classList.contains('minimized')) {
                    openWindow(windowEl.dataset.app);
                    return;
                }
                if (activeWindow === windowEl) return;
                if (activeWindow) {
                    activeWindow.classList.remove('active');
                }
                windows.forEach(w => w.classList.remove('active'));
                
                activeWindow = windowEl;
                activeWindow.classList.add('active');
                highestZIndex++;
                activeWindow.style.zIndex = highestZIndex;
                
                updateTaskbarActive(activeWindow.dataset.app);
            }

            // 8.2 更新任務欄
            function updateTaskbarActive(appId) {
                getAllTaskbarIcons().forEach(icon => {
                    // Update active-app state (foreground)
                    const isActive = icon.dataset.app === appId;
                    icon.classList.toggle('active-app', isActive);
                    // Accessibility: set aria-pressed for the taskbar button to reflect active state
                    icon.setAttribute('aria-pressed', String(!!isActive));
                    // Update open-app based on whether the window is currently showing (foreground),
                    // or minimized (app still running in background). Treat minimized windows as open-app.
                    const winEl = document.getElementById(`window-${icon.dataset.app}`);
                    if (winEl && (winEl.classList.contains('show') || winEl.classList.contains('minimized'))) {
                        icon.classList.add('open-app');
                    } else {
                        icon.classList.remove('open-app');
                    }
                });
            }

            // Utility: ensure a taskbar icon exists for an app. If not, create a temporary icon for running (non-pinned) apps.
            function createTaskbarIconIfMissing(appId) {
                if (!appId) return null;
                let existing = document.getElementById(`taskbar-icon-${appId}`);
                if (existing) return existing;
                const centerGroup = document.querySelector('#taskbar .taskbar-group.center');
                if (!centerGroup) return null;
                const el = document.createElement('div');
                el.className = 'taskbar-icon';
                el.id = `taskbar-icon-${appId}`;
                el.dataset.app = appId;
                el.setAttribute('role', 'button');
                el.setAttribute('tabindex', '0');
                el.setAttribute('aria-pressed', 'false');
                // mark as temporary (not pinned) so it can be removed on close
                el.setAttribute('data-temporary', 'true');
                // Choose proper icon markup (use image for nagato, otherwise FA icons)
                switch (appId) {
                    case 'nagato':
                        el.innerHTML = `<img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img icon-nagato" loading="lazy">`;
                        el.title = '長門櫻';
                        break;
                    case 'settings':
                        el.innerHTML = `<i class="fa-solid fa-gear icon-settings"></i>`;
                        el.title = '設定';
                        break;
                    case 'explorer':
                        el.innerHTML = `<i class="fa-solid fa-folder icon-explorer"></i>`;
                        el.title = '檔案總管';
                        break;
                    case 'browser':
                        el.innerHTML = `<i class="fa-brands fa-edge icon-edge"></i>`;
                        el.title = '瀏覽器';
                        break;
                    case 'store':
                        el.innerHTML = `<i class="fa-solid fa-store icon-store"></i>`;
                        el.title = '應用商店';
                        break;
                    case 'calculator':
                        el.innerHTML = `<i class="fa-solid fa-calculator" style="color: #4caf50;"></i>`;
                        el.title = '計算機';
                        break;
                    default:
                        el.innerHTML = `<i class="fa-solid fa-square"></i>`;
                        el.title = appId;
                        break;
                }
                // Insert icons before the right side of center group (i.e., append to center by default)
                centerGroup.appendChild(el);
                return el;
            }

            // 8.3 開啟視窗
            function openWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (!windowEl) return;
                const wasMinimized = windowEl.classList.contains('minimized');
                windowEl.classList.add('show');
                windowEl.classList.remove('minimized');
                // Taskbar icon should be marked as open (background/foreground)
                let tbIcon = document.getElementById(`taskbar-icon-${appId}`);
                if (!tbIcon) tbIcon = createTaskbarIconIfMissing(appId);
                if (tbIcon) tbIcon.classList.add('open-app');
                // If the window has not been placed yet (no inline position), center it within the desktop
                // only when it is not maximized/snapped. This prevents re-centering restorations.
                try {
                    const desktopEl = document.getElementById('desktop');
                    const taskbarEl = document.getElementById('taskbar');
                    if (desktopEl && taskbarEl && !windowEl.dataset.placed && !windowEl.dataset.isSnapped && !windowEl.dataset.isMaximized) {
                        // Ensure the window is shown first so offsetWidth/offsetHeight are reliable
                        const tbHeight = taskbarEl.offsetHeight || 0;
                        const containerWidth = desktopEl.clientWidth;
                        const containerHeight = desktopEl.clientHeight - tbHeight;
                        const winWidth = windowEl.offsetWidth || parseFloat(window.getComputedStyle(windowEl).width) || 400;
                        const winHeight = windowEl.offsetHeight || parseFloat(window.getComputedStyle(windowEl).height) || 300;
                        let left = Math.max(0, Math.round((containerWidth - winWidth) / 2));
                        let top = Math.max(0, Math.round((containerHeight - winHeight) / 2));
                        // If the window was created with top/left inline, don't override
                        const hasInlineLeft = windowEl.style.left && windowEl.style.left !== '' && windowEl.style.left !== 'auto';
                        const hasInlineTop = windowEl.style.top && windowEl.style.top !== '' && windowEl.style.top !== 'auto';
                        if (!hasInlineLeft) windowEl.style.left = `${left}px`;
                        if (!hasInlineTop) windowEl.style.top = `${top}px`;
                        // Mark placed so future opens do not re-center
                        windowEl.dataset.placed = 'true';
                    }
                } catch (err) {
                    console.error('Failed to auto-center window', err);
                }
                focusWindow(windowEl);
                
                if (appId === 'browser') {
                    const iframe = windowEl.querySelector('iframe');
                    // By default, when opening the browser, use the user-customized url if available
                    const desired = (document.getElementById('browser-url-input')?.value || iframe.src || '').trim();
                    const urlToSet = (!desired || desired === 'about:blank') ? 'https://amanoshizukikun.github.io/' : desired;
                    // If we are restoring from minimized state, avoid forcing a reload or pushing history
                    setBrowserUrl(urlToSet, !wasMinimized);
                    // Ensure iframe is visible as it uses the 'show' class to display in Edge-like UI
                    iframe.classList.add('show');
                }
                if (appId === 'nagato') {
                    // Focus input and refresh messages when opening the assistant
                    setTimeout(() => {
                        const inputEl = document.getElementById('nagato-input');
                        if (inputEl) { inputEl.focus(); }
                        try { renderNagatoMessages(); } catch (e) {}
                    }, 50);
                }
                if (appId === 'calculator') {
                    const calcInput = document.getElementById('calc-input');
                    if (calcInput) {
                        // Delay slightly so that the window becomes focusable first
                        setTimeout(() => { calcInput.focus(); }, 0);
                    }
                }
            }
            
            // 8.4 關閉視窗
            function closeWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (windowEl) {
                    windowEl.classList.remove('show');
                }
                const tbIconClose = document.getElementById(`taskbar-icon-${appId}`);
                if (tbIconClose) {
                    // If temporary (creator-created) icon, remove it when the app closes
                    if (tbIconClose.hasAttribute('data-temporary')) {
                        tbIconClose.remove();
                    } else {
                        // pinned: just clear state
                        tbIconClose.classList.remove('active-app');
                        tbIconClose.classList.remove('open-app');
                        tbIconClose.setAttribute('aria-pressed', 'false');
                    }
                }
                if (activeWindow === windowEl) {
                    activeWindow = null;
                    // If there are other visible windows, focus the top-most (highest z-index)
                    const visibleWindows = Array.from(document.querySelectorAll('.window.show')).filter(w => !w.classList.contains('minimized') && w !== windowEl);
                    if (visibleWindows.length > 0) {
                        visibleWindows.sort((a, b) => (parseInt(b.style.zIndex, 10) || 0) - (parseInt(a.style.zIndex, 10) || 0));
                        focusWindow(visibleWindows[0]);
                    }
                }
            }
            
            // 8.5 最小化視窗
            function minimizeWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (windowEl) {
                    windowEl.classList.add('minimized');
                    windowEl.classList.remove('show', 'active');
                    // Keep the taskbar icon as open (app still running in background). Remove 'active-app'.
                    const tbIconMin = document.getElementById(`taskbar-icon-${appId}`);
                    if (tbIconMin) {
                        tbIconMin.classList.remove('active-app');
                        tbIconMin.classList.add('open-app'); // keep as open while minimized
                        tbIconMin.setAttribute('aria-pressed', 'false');
                    }
                }
                if (activeWindow === windowEl) {
                    activeWindow = null;
                }
                // Update taskbar icons to ensure active state is consistent
                updateTaskbarActive(null);
            }

            // 8.6 最大化/還原 視窗
            function maximizeWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (windowEl) {
                    if (!windowEl.dataset.isMaximized) {
                        const cs = window.getComputedStyle(windowEl);
                        windowEl.dataset.oldX = windowEl.style.left || cs.left;
                        windowEl.dataset.oldY = windowEl.style.top || cs.top;
                        windowEl.dataset.oldW = windowEl.style.width || cs.width;
                        windowEl.dataset.oldH = windowEl.style.height || cs.height;
                        
                        windowEl.style.left = '0';
                        windowEl.style.top = '0';
                        windowEl.style.width = '100%';
                        // 高度 100% 減去任務欄高度 (相對於 .simulator-container)
                        windowEl.style.height = `calc(100% - ${taskbar.offsetHeight}px)`;
                        windowEl.dataset.isMaximized = 'true';
                    } else {
                        // 還原
                        windowEl.style.left = windowEl.dataset.oldX || '100px';
                        windowEl.style.top = windowEl.dataset.oldY || '100px';
                        windowEl.style.width = windowEl.dataset.oldW || '700px';
                        windowEl.style.height = windowEl.dataset.oldH || '500px';
                        windowEl.dataset.isMaximized = '';
                    }
                    focusWindow(windowEl);
                }
            }

            // 8.7 Snap windows to left/right or corners
            function snapWindow(windowEl, mode) {
                if (!windowEl) return;
                // save previous rect if not already saved
                if (!windowEl.dataset.oldW) {
                    const cs = window.getComputedStyle(windowEl);
                    windowEl.dataset.oldX = windowEl.style.left || cs.left;
                    windowEl.dataset.oldY = windowEl.style.top || cs.top;
                    windowEl.dataset.oldW = windowEl.style.width || cs.width;
                    windowEl.dataset.oldH = windowEl.style.height || cs.height;
                }
                const contentBoxWidth = desktop.clientWidth;
                const contentBoxHeight = desktop.clientHeight;
                const taskbarHeight = taskbar.offsetHeight;
                let newLeft = 0;
                let newTop = 0;
                let newWidth = windowEl.offsetWidth;
                let newHeight = contentBoxHeight - taskbarHeight;

                switch (mode) {
                    case 'left':
                        newLeft = 0;
                        newWidth = Math.floor(contentBoxWidth / 2);
                        break;
                    case 'right':
                        newLeft = Math.ceil(contentBoxWidth / 2);
                        newWidth = Math.floor(contentBoxWidth / 2);
                        break;
                    case 'left-top':
                        newLeft = 0;
                        newTop = 0;
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    case 'right-top':
                        newLeft = Math.ceil(contentBoxWidth / 2);
                        newTop = 0;
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    case 'left-bottom':
                        newLeft = 0;
                        newTop = Math.ceil((contentBoxHeight - taskbarHeight) / 2);
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    case 'right-bottom':
                        newLeft = Math.ceil(contentBoxWidth / 2);
                        newTop = Math.ceil((contentBoxHeight - taskbarHeight) / 2);
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    default:
                        return;
                }

                windowEl.style.left = `${newLeft}px`;
                windowEl.style.top = `${newTop}px`;
                windowEl.style.width = `${newWidth}px`;
                windowEl.style.height = `${newHeight}px`;
                // mark snapped state
                windowEl.dataset.isSnapped = mode;
                // ensure not maximized
                windowEl.dataset.isMaximized = '';
                focusWindow(windowEl);
            }

            // --- 9. 視窗事件綁定 (拖動, 調整大小, 控制按鈕) ---
            windows.forEach(windowEl => {
                const header = windowEl.querySelector('.window-header');
                const appId = windowEl.dataset.app;

                // 9.1 點擊視窗時設為 Active
                windowEl.addEventListener('mousedown', () => {
                    focusWindow(windowEl);
                }, true);
                windowEl.addEventListener('pointerdown', (e) => {
                    focusWindow(windowEl);
                }, true);

                // 9.2 拖動 (使用全域 actionState)
                header.addEventListener('mousedown', (e) => {
                    // ignore if the click comes from a resize handle that sits above the header
                    if (e.target.closest && e.target.closest('.resize-handle')) return;
                    if (e.target.closest('.window-control-btn')) return;
                    // If the window is maximized, we no longer restore immediately on mousedown.
                    // Instead, enable restore-on-drag: only when user moves the cursor beyond a
                    // small threshold (i.e. starts to drag) do we restore and continue dragging.
                    actionState.restoreOnDrag = (windowEl.dataset.isMaximized === 'true');
                    // Restore if window was snapped
                    if (windowEl.dataset.isSnapped) {
                        const cs = window.getComputedStyle(windowEl);
                        const oldX = parseFloat(windowEl.dataset.oldX) || parseFloat(cs.left) || 100;
                        const oldY = parseFloat(windowEl.dataset.oldY) || parseFloat(cs.top) || 100;
                        const oldW = parseFloat(windowEl.dataset.oldW) || windowEl.offsetWidth;
                        const oldH = parseFloat(windowEl.dataset.oldH) || windowEl.offsetHeight;
                        windowEl.style.width = `${oldW}px`;
                        windowEl.style.height = `${oldH}px`;
                        windowEl.style.left = `${oldX}px`;
                        windowEl.style.top = `${oldY}px`;
                        windowEl.dataset.isSnapped = '';
                    }
                    // If window was snapped (left/right), restoring to previous size so dragging feels natural
                    if (windowEl.dataset.isSnapped) {
                        const cs = window.getComputedStyle(windowEl);
                        const oldX = parseFloat(windowEl.dataset.oldX) || parseFloat(cs.left) || 100;
                        const oldY = parseFloat(windowEl.dataset.oldY) || parseFloat(cs.top) || 100;
                        const oldW = parseFloat(windowEl.dataset.oldW) || windowEl.offsetWidth;
                        const oldH = parseFloat(windowEl.dataset.oldH) || windowEl.offsetHeight;
                        windowEl.style.width = `${oldW}px`;
                        windowEl.style.height = `${oldH}px`;
                        windowEl.style.left = `${oldX}px`;
                        windowEl.style.top = `${oldY}px`;
                        windowEl.dataset.isSnapped = '';
                    }
                    focusWindow(windowEl);
                    const rect = windowEl.getBoundingClientRect();
                    const parentRect = desktop.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(desktop);
                    const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                    const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                    const parentOriginX = parentRect.left + parentPaddingLeft;
                    const parentOriginY = parentRect.top + parentPaddingTop;

                    actionState.type = 'drag';
                    actionState.windowEl = windowEl;
                    actionState.startX = e.clientX;
                    actionState.startY = e.clientY;
                    // Prefer explicit style.left/style.top if present, otherwise compute from rect
                    const explicitLeft = parseFloat(windowEl.style.left);
                    const explicitTop = parseFloat(windowEl.style.top);
                    actionState.startLeft = Number.isFinite(explicitLeft) ? explicitLeft : (rect.left - parentOriginX);
                    actionState.startTop = Number.isFinite(explicitTop) ? explicitTop : (rect.top - parentOriginY);
                    actionState.pointerId = e.pointerId || null;
                    actionState.captureTarget = header || e.target || null;

                    // prevent text selection during drag
                    document.body.style.userSelect = 'none';
                    try { if (e.pointerId) (header.setPointerCapture && header.setPointerCapture(e.pointerId)) || (e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId)); } catch (err) {}
                    e.preventDefault();
                });
                header.addEventListener('pointerdown', (e) => {
                    // ignore if the pointerdown originates from a resize handle
                    if (e.target.closest && e.target.closest('.resize-handle')) return;
                    if (e.target.closest('.window-control-btn')) return;
                    // same as mouse handler: delay restore until actual drag occurs
                    actionState.restoreOnDrag = (windowEl.dataset.isMaximized === 'true');
                    focusWindow(windowEl);
                    const rect = windowEl.getBoundingClientRect();
                    const parentRect = desktop.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(desktop);
                    const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                    const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                    const parentOriginX = parentRect.left + parentPaddingLeft;
                    const parentOriginY = parentRect.top + parentPaddingTop;

                    actionState.type = 'drag';
                    actionState.windowEl = windowEl;
                    actionState.startX = e.clientX;
                    actionState.startY = e.clientY;
                    const explicitLeft2 = parseFloat(windowEl.style.left);
                    const explicitTop2 = parseFloat(windowEl.style.top);
                    actionState.startLeft = Number.isFinite(explicitLeft2) ? explicitLeft2 : (rect.left - parentOriginX);
                    actionState.startTop = Number.isFinite(explicitTop2) ? explicitTop2 : (rect.top - parentOriginY);

                    // prevent text selection during drag
                    document.body.style.userSelect = 'none';
                    try { if (e.pointerId) e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); } catch (err) {}
                    e.preventDefault();
                });
                // Double-click header toggles maximize
                header.addEventListener('dblclick', (e) => {
                    if (e.target.closest('.window-control-btn')) return;
                    maximizeWindow(appId);
                });

                // 9.3 調整大小 (使用 resizewin 函數，參考 win12-main)
                windowEl.querySelectorAll('.resize-handle').forEach(handle => {
                    const direction = Array.from(handle.classList).find(c => c.length <= 2) || '';
                    let arg = '';
                    if (direction === 'n') arg = 'top';
                    else if (direction === 's') arg = 'bottom';
                    else if (direction === 'e') arg = 'right';
                    else if (direction === 'w') arg = 'left';
                    else if (direction === 'nw') arg = 'top-left';
                    else if (direction === 'ne') arg = 'top-right';
                    else if (direction === 'sw') arg = 'bottom-left';
                    else if (direction === 'se') arg = 'bottom-right';

                    handle.addEventListener('mousedown', (e) => {
                        focusWindow(windowEl);
                        e.stopPropagation();
                        document.body.style.userSelect = 'none';
                        resizewin(windowEl, arg, handle, e);
                        e.preventDefault();
                    });
                    handle.addEventListener('pointerdown', (e) => {
                        focusWindow(windowEl);
                        e.stopPropagation();
                        document.body.style.userSelect = 'none';
                        resizewin(windowEl, arg, handle, e);
                        e.preventDefault();
                    });
                });
                // 9.4 Snap layout option handlers
                const snapOptions = windowEl.querySelectorAll('.snap-layout-option');
                if (snapOptions && snapOptions.length) {
                    snapOptions.forEach((opt, i) => {
                        opt.addEventListener('click', (e) => {
                            e.stopPropagation();
                            switch (i) {
                                case 0: snapWindow(windowEl, 'left-top'); break;
                                case 1: snapWindow(windowEl, 'right-top'); break;
                                case 2: snapWindow(windowEl, 'left-bottom'); break;
                                case 3: snapWindow(windowEl, 'right-bottom'); break;
                            }
                        });
                    });
                }

                // Note: mousemove and mouseup handlers are added globally once below
                
                // 9.5 全域 MouseUp handled globally below

                // 9.6 控制按鈕
                windowEl.querySelector('.close').addEventListener('click', () => closeWindow(appId));
                windowEl.querySelector('.minimize').addEventListener('click', () => minimizeWindow(appId));
                windowEl.querySelector('.maximize').addEventListener('click', () => maximizeWindow(appId));
            });

            // Global mouse handlers for drag/resize (single listener for all windows)
            // Use RAF to throttle updates and support pointer events to avoid stuck state / missing mouseup

            /**
             * Enhanced resize handler for windows, ported from win12-main.
             * - Uses a local `state` to capture start geometry and pointer start coordinates
             * - Throttles layout updates with requestAnimationFrame to reduce layout thrashing
             * - Anchors the opposite edge (right/bottom) when resizing from left/top to avoid
             *   the window 'jumping' or 'sliding' unexpectedly
             * - Supports mouse, touch and pointer events (pointer capture when supported)
             */
            function resizewin(win, arg, resizeElt, ev) {
                const desktop = document.getElementById('desktop');
                const desktopRect = desktop.getBoundingClientRect();
                const taskbar = document.getElementById('taskbar');
                const taskbarHeight = taskbar ? taskbar.offsetHeight : 0;
                const startRect = win.getBoundingClientRect();
                const explicitLeft = parseFloat(win.style.left);
                const explicitTop = parseFloat(win.style.top);
                const startLeft = Number.isFinite(explicitLeft) ? explicitLeft : (startRect.left - desktopRect.left);
                const startTop = Number.isFinite(explicitTop) ? explicitTop : (startRect.top - desktopRect.top);
                const state = {
                    startX: null,
                    startY: null,
                    startLeft: startLeft,
                    startTop: startTop,
                    startWidth: startRect.width,
                    startHeight: startRect.height,
                    rightEdge: startLeft + startRect.width,
                    bottomEdge: startTop + startRect.height,
                    currentX: null,
                    currentY: null,
                    rafId: null,
                    pointerId: null,
                    captureTarget: null
                };

                function applyResize() {
                    if (state.currentX === null || state.currentY === null || state.startX === null) return;
                    const minWidth = win.dataset.minWidth ? parseFloat(win.dataset.minWidth) : 400;
                    const minHeight = win.dataset.minHeight ? parseFloat(win.dataset.minHeight) : 300;
                    const dx = state.currentX - state.startX;
                    const dy = state.currentY - state.startY;

                    let newLeft = state.startLeft;
                    let newTop = state.startTop;
                    let newWidth = state.startWidth;
                    let newHeight = state.startHeight;
                    const viewW = desktop.clientWidth;
                    const viewH = desktop.clientHeight;

                    // Horizontal
                    if (arg.indexOf('right') !== -1 || arg === 'right') {
                        newWidth = Math.max(minWidth, Math.min(viewW - state.startLeft, state.startWidth + dx));
                    }
                    if (arg.indexOf('left') !== -1 || arg === 'left') {
                        // anchor right edge
                        let candidateLeft = state.startLeft + dx;
                        candidateLeft = Math.max(0, Math.min(candidateLeft, state.rightEdge - minWidth));
                        newLeft = candidateLeft;
                        newWidth = state.rightEdge - newLeft;
                    }

                    // Vertical
                    if (arg.indexOf('bottom') !== -1 || arg === 'bottom') {
                        newHeight = Math.max(minHeight, Math.min(viewH - state.startTop, state.startHeight + dy));
                    }
                    if (arg.indexOf('top') !== -1 || arg === 'top') {
                        let candidateTop = state.startTop + dy;
                        candidateTop = Math.max(0, Math.min(candidateTop, state.bottomEdge - minHeight));
                        newTop = candidateTop;
                        newHeight = state.bottomEdge - newTop;
                    }

                    // clamp to view
                    if (newLeft + newWidth > viewW) newWidth = Math.max(minWidth, viewW - newLeft);
                    if (newTop + newHeight > viewH) newHeight = Math.max(minHeight, viewH - newTop);

                    win.style.left = `${newLeft}px`;
                    win.style.top = `${newTop}px`;
                    win.style.width = `${newWidth}px`;
                    win.style.height = `${newHeight}px`;
                }

                function tick() {
                    if (state.rafId) return;
                    state.rafId = requestAnimationFrame(() => { state.rafId = null; applyResize(); });
                }

                function moveHandler(e) {
                    if (e.type.match('mouse')) {
                        state.currentX = e.clientX;
                        state.currentY = e.clientY;
                    } else if (e.type.match('touch')) {
                        state.currentX = e.touches[0].clientX;
                        state.currentY = e.touches[0].clientY;
                    } else if (e.type.match('pointer')) {
                        state.currentX = e.clientX;
                        state.currentY = e.clientY;
                    }
                    tick();
                }

                function up_f() {
                    // release pointer capture if any
                    try { if (state.captureTarget && state.pointerId && state.captureTarget.releasePointerCapture) state.captureTarget.releasePointerCapture(state.pointerId); } catch (err) {}
                    // remove handlers
                    document.onmousedown = null;
                    document.ontouchstart = null;
                    document.onmousemove = null;
                    document.ontouchmove = null;
                    document.ontouchcancel = null;
                    if (window.PointerEvent) {
                        document.removeEventListener('pointermove', moveHandler);
                        document.removeEventListener('pointerup', up_f);
                        document.removeEventListener('pointercancel', up_f);
                    }
                    // cancel RAF
                    if (state.rafId) { cancelAnimationFrame(state.rafId); state.rafId = null; }
                    document.body.style.cursor = 'auto';
                    document.body.style.userSelect = '';
                    try { if (resizeElt && resizeElt._resizeState) delete resizeElt._resizeState; } catch (err) {}
                }

                // set start positions from the event if provided (mousemove/pointerdown/touchstart)
                if (ev) {
                    if (ev.type && ev.type.indexOf('touch') !== -1) {
                        state.startX = ev.touches && ev.touches[0] ? ev.touches[0].clientX : ev.clientX;
                        state.startY = ev.touches && ev.touches[0] ? ev.touches[0].clientY : ev.clientY;
                    } else {
                        state.startX = ev.clientX;
                        state.startY = ev.clientY;
                        state.pointerId = ev.pointerId || null;
                        state.captureTarget = resizeElt || ev.target || null;
                        try { if (ev.pointerId && resizeElt && resizeElt.setPointerCapture) resizeElt.setPointerCapture(ev.pointerId); } catch (err) {}
                        // Prevent text selection while resizing
                        document.body.style.userSelect = 'none';
                    }
                }

                // bind move events
                document.onmousemove = moveHandler;
                document.ontouchmove = moveHandler;
                if (window.PointerEvent) {
                    document.addEventListener('pointermove', moveHandler);
                    document.addEventListener('pointerup', up_f);
                    document.addEventListener('pointercancel', up_f);
                }

                // Touch / mouse cleanup
                document.onmouseup = up_f;
                document.ontouchend = up_f;
                document.ontouchcancel = up_f;

                // reflect cursor style
                document.body.style.cursor = window.getComputedStyle(resizeElt, null).cursor;

                // The mousedown caller should set state.startX/startY to the initial pointer values and set pointer capture
                // We expose the `state` through the element for the mousedown caller to populate these values and capture pointer.
                resizeElt._resizeState = state;
            }

            // Allow windows to be dragged partially under the taskbar for improved dragging space
            const DRAG_UNDER_TASKBAR = 40; // px; how many pixels of overlap are allowed under taskbar
            // Off-screen allowance: this value is configurable via the settings slider (see #offscreenRatio)
            // Default to 90% to allow windows to be dragged more freely off-screen
            let OFFSCREEN_ALLOW_RATIO = 0.9; // ratio (0-1)
            // Hook settings slider if present to change this value dynamically
            try {
                const _offscreenSlider = document.getElementById('offscreenRatio');
                const _offscreenValue = document.getElementById('offscreenRatioValue');
                if (_offscreenSlider && _offscreenValue) {
                    const saved = localStorage.getItem('offscreenRatio');
                    if (saved !== null && !Number.isNaN(Number(saved))) {
                        _offscreenSlider.value = String(Number(saved));
                    }
                    OFFSCREEN_ALLOW_RATIO = Number(_offscreenSlider.value) / 100;
                    _offscreenValue.textContent = `${_offscreenSlider.value}%`;
                    _offscreenSlider.addEventListener('input', (e) => {
                        const v = Number(e.target.value);
                        OFFSCREEN_ALLOW_RATIO = v / 100;
                        _offscreenValue.textContent = `${v}%`;
                    });
                    _offscreenSlider.addEventListener('change', (e) => {
                        localStorage.setItem('offscreenRatio', String(Number(e.target.value)));
                    });
                }
            } catch (err) { console.error(err); }
            let rafId = null;
            // create snap preview element and append to desktop
            let snapPreview = document.getElementById('snap-preview');
            // Hover timer for snap/ maximize preview (wait to show preview to avoid accidental snaps)
            // Delay (ms) before showing the preview while dragging near the edges
            const SNAP_HOVER_DELAY = 30; // 30ms per user's request
            let snapHoverTimer = null;
            let snapHoverMode = '';

            function setSnapHoverMode(mode) {
                // Cancel any pending timer if mode changed
                if (!mode) {
                    if (snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                    snapHoverMode = '';
                    hideSnapPreview();
                    return;
                }
                // If same mode and already showing, do nothing
                if (mode === snapHoverMode && snapPreview && snapPreview.classList.contains('show')) return;
                // If different mode, reset timer
                if (snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                // Start timer to show the preview after SNAP_HOVER_DELAY
                const desiredMode = mode;
                snapHoverTimer = setTimeout(() => {
                    snapHoverTimer = null;
                    snapHoverMode = desiredMode;
                    showSnapPreview(desiredMode);
                }, SNAP_HOVER_DELAY);
            }
            if (!snapPreview) {
                snapPreview = document.createElement('div');
                snapPreview.id = 'snap-preview';
                desktop.appendChild(snapPreview);
            }
            function requestApply() {
                if (!rafId) rafId = requestAnimationFrame(() => { rafId = null; applyActionState(); });
            }
            function cancelApply() {
                if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
            }
            function applyActionState() {
                if (!actionState.type || !actionState.windowEl) return;
                const windowEl = actionState.windowEl;
                const parentRect = desktop.getBoundingClientRect();
                const parentStyle = window.getComputedStyle(desktop);
                const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                const parentOriginX = parentRect.left + parentPaddingLeft;
                const parentOriginY = parentRect.top + parentPaddingTop;
                const contentBoxWidth = desktop.clientWidth;
                const contentBoxHeight = desktop.clientHeight;
                const taskbarHeight = taskbar.offsetHeight;

                if (actionState.type === 'drag') {
                    const clientX = actionState.currentX || actionState.lastMouseX || actionState.startX;
                    const clientY = actionState.currentY || actionState.lastMouseY || actionState.startY;
                    const dx = clientX - actionState.startX;
                    const dy = clientY - actionState.startY;
                    // If the window was maximized and the user started dragging (not just clicking),
                    // perform a restore to the previous size and continue the drag from there.
                    if (actionState.restoreOnDrag && actionState.windowEl && actionState.windowEl.dataset.isMaximized === 'true') {
                        // threshold to avoid accidental restores on small pointer jitter
                        const restoreThreshold = 6; // px
                        if (Math.abs(dx) > restoreThreshold || Math.abs(dy) > restoreThreshold) {
                            const wEl = actionState.windowEl;
                            const rect = wEl.getBoundingClientRect();
                            const parentRect = desktop.getBoundingClientRect();
                            const parentStyle = window.getComputedStyle(desktop);
                            const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                            const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                            const parentOriginX = parentRect.left + parentPaddingLeft;
                            const parentOriginY = parentRect.top + parentPaddingTop;
                            const pointerX = clientX;
                            const pointerY = clientY;
                            const relX = (pointerX - rect.left) / rect.width;
                            const relY = (pointerY - rect.top) / rect.height;
                            const oldW = parseFloat(wEl.dataset.oldW) || 700;
                            const oldH = parseFloat(wEl.dataset.oldH) || 500;
                            // Calculate new left/top so pointer remains over same relative point
                            let newLeft = pointerX - parentOriginX - (relX * oldW);
                            let newTop = pointerY - parentOriginY - (relY * oldH);
                            const maxLeft = desktop.clientWidth - oldW;
                            const maxTop = desktop.clientHeight - taskbar.offsetHeight - oldH;
                            if (newLeft < 0) newLeft = 0;
                            if (newTop < 0) newTop = 0;
                            if (newLeft > maxLeft) newLeft = maxLeft;
                            if (newTop > maxTop) newTop = maxTop;
                            // Apply restoration and ensure metrics are updated for subsequent drag
                            wEl.style.width = `${oldW}px`;
                            wEl.style.height = `${oldH}px`;
                            wEl.style.left = `${newLeft}px`;
                            wEl.style.top = `${newTop}px`;
                            wEl.dataset.isMaximized = '';
                            actionState.restoreOnDrag = false;
                            // Update start positions for smooth dragging
                            actionState.startLeft = newLeft;
                            actionState.startTop = newTop;
                            actionState.startX = clientX;
                            actionState.startY = clientY;
                            // Recompute dx/dy to reflect the new start position (so the immediate movement continues applying correctly)
                            // No reassign of dx/dy here; let subsequent applyActionState loop pick up new deltas
                        }
                    }
                    let newLeft = actionState.startLeft + dx;
                    let newTop = actionState.startTop + dy;
                    // clamp to desktop bounds, but allow partial off-screen movement when not maximized
                    if (windowEl.dataset.isMaximized === 'true') {
                        // For maximized windows, keep them fully inside the desktop bounds
                        if (newLeft < 0) newLeft = 0;
                        if (newTop < 0) newTop = 0;
                        if (newLeft + windowEl.offsetWidth > contentBoxWidth) newLeft = contentBoxWidth - windowEl.offsetWidth;
                        if (newTop + windowEl.offsetHeight > contentBoxHeight - taskbarHeight) newTop = contentBoxHeight - taskbarHeight - windowEl.offsetHeight;
                    } else {
                        // Non-maximized: allow partially off-screen horizontally and bottom, but not above header (top < 0)
                        const offX = Math.round(windowEl.offsetWidth * OFFSCREEN_ALLOW_RATIO);
                        const offY = Math.round(windowEl.offsetHeight * OFFSCREEN_ALLOW_RATIO);
                        const minLeft = -offX;
                        const maxLeft = contentBoxWidth - windowEl.offsetWidth + offX;
                        const minTop = 0; // prevent moving above header (desktop top)
                        const maxTop = contentBoxHeight - taskbarHeight - windowEl.offsetHeight + offY;

                        if (newLeft < minLeft) newLeft = minLeft;
                        if (newLeft > maxLeft) newLeft = maxLeft;
                        if (newTop < minTop) newTop = minTop;
                        if (newTop > maxTop) newTop = maxTop;
                    }
                    windowEl.style.left = `${newLeft}px`;
                    windowEl.style.top = `${newTop}px`;

                    // Show snap preview while dragging (not when maximized)
                    // NOTE: Use pointer position (cursor) rather than window position so snap triggers
                    // when the mouse is dragged near edges, reducing accidental snaps when the
                    // window itself visually touches the edge because of size/offset.
                    const snapThreshold = 24; // px distance to edge to show preview
                    const cornerThreshold = 120; // px for corner area
                    let previewMode = '';
                    // Use pointer coordinates (clientX/Y) as primary input for snap detection.
                    const parentRectLocal = desktop.getBoundingClientRect();
                    const parentStyleLocal = window.getComputedStyle(desktop);
                    const parentPaddingLeftLocal = parseFloat(parentStyleLocal.paddingLeft) || 0;
                    const parentPaddingTopLocal = parseFloat(parentStyleLocal.paddingTop) || 0;
                    const originXLocal = parentRectLocal.left + parentPaddingLeftLocal;
                    const originYLocal = parentRectLocal.top + parentPaddingTopLocal;
                    const pointerX = clientX - originXLocal; // local to desktop
                    const pointerY = clientY - originYLocal; // local to desktop
                    // Check corners and top first
                    if (pointerY <= snapThreshold && pointerX <= cornerThreshold) {
                        previewMode = 'left-top';
                    } else if (pointerY <= snapThreshold && pointerX >= contentBoxWidth - cornerThreshold) {
                        previewMode = 'right-top';
                    } else if (pointerY <= snapThreshold) {
                        previewMode = 'max';
                    } else if (pointerY >= contentBoxHeight - taskbarHeight - snapThreshold && pointerX <= cornerThreshold) {
                        // bottom-left corner
                        previewMode = 'left-bottom';
                    } else if (pointerY >= contentBoxHeight - taskbarHeight - snapThreshold && pointerX >= contentBoxWidth - cornerThreshold) {
                        // bottom-right corner
                        previewMode = 'right-bottom';
                    } else if (pointerX <= snapThreshold) {
                        previewMode = 'left';
                    } else if (pointerX >= contentBoxWidth - snapThreshold) {
                        previewMode = 'right';
                    } else {
                        previewMode = '';
                    }
                    if (previewMode) setSnapHoverMode(previewMode); else setSnapHoverMode('');
                }
                // Resize logic moved to resizewin function
            }
            document.addEventListener('mousemove', (e) => {
                if (!actionState.type || !actionState.windowEl) return;
                actionState.lastMouseX = e.clientX;
                actionState.lastMouseY = e.clientY;
                actionState.currentX = e.clientX;
                actionState.currentY = e.clientY;
                requestApply();
                e.preventDefault();
            });

            // Pointer move uses the same logic as mousemove for better capture across devices
            document.addEventListener('pointermove', (e) => {
                if (!actionState.type || !actionState.windowEl) return;
                actionState.lastMouseX = e.clientX;
                actionState.lastMouseY = e.clientY;
                actionState.currentX = e.clientX;
                actionState.currentY = e.clientY;
                requestApply();
                e.preventDefault();
            });

            function clearActionState(e) {
                cancelApply();
                const hadAction = !!actionState.type;
                // If there's a pending hover timer, cancel it
                if (typeof snapHoverTimer !== 'undefined' && snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                // Determine whether a snap preview is currently visible (and what mode)
                const previewShown = snapPreview && snapPreview.classList.contains('show');
                const previewMode = previewShown && snapPreview.dataset ? snapPreview.dataset.mode : '';
                // If drag ended, evaluate snap based on preview being displayed
                if (hadAction && actionState.type === 'drag' && actionState.windowEl) {
                    const windowEl = actionState.windowEl;
                    const contentBoxWidth = desktop.clientWidth;
                    const contentBoxHeight = desktop.clientHeight;
                    const taskbarHeight = taskbar.offsetHeight;
                    const left = parseFloat(windowEl.style.left) || windowEl.offsetLeft || 0;
                    const top = parseFloat(windowEl.style.top) || windowEl.offsetTop || 0;
                    const width = windowEl.offsetWidth;
                    const height = windowEl.offsetHeight;
                    // Use pointer position for final snap detection (less false positives)
                    const parentRect = desktop.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(desktop);
                    const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                    const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                    const originX = parentRect.left + parentPaddingLeft;
                    const originY = parentRect.top + parentPaddingTop;
                    const clientX = actionState.currentX || actionState.lastMouseX || actionState.startX;
                    const clientY = actionState.currentY || actionState.lastMouseY || actionState.startY;
                    const pointerX = clientX - originX; // pointer relative to desktop
                    const pointerY = clientY - originY; // pointer relative to desktop
                    const threshold = 24; // px threshold to consider snapped by pointer

                    // Only perform snap/maximize if the hover preview was actually shown
                    if (previewShown && previewMode) {
                        const appId = windowEl.dataset.app;
                        switch (previewMode) {
                            case 'max':
                                maximizeWindow(appId);
                                break;
                            case 'left':
                            case 'right':
                            case 'left-top':
                            case 'right-top':
                            case 'left-bottom':
                            case 'right-bottom':
                                snapWindow(windowEl, previewMode);
                                break;
                        }
                    }
                    // Hide the preview once we acted
                    if (previewShown) hideSnapPreview();
                }
                // try to release pointer capture if used
                try {
                    if (actionState.captureTarget && actionState.pointerId && actionState.captureTarget.releasePointerCapture) {
                        actionState.captureTarget.releasePointerCapture(actionState.pointerId);
                    }
                } catch (err) {}
                if (actionState.type) {
                    actionState.type = null;
                        actionState.windowEl = null;
                        actionState.direction = '';
                        actionState.startX = null;
                        actionState.startY = null;
                        actionState.startLeft = null;
                        actionState.startTop = null;
                        actionState.startWidth = null;
                        actionState.startHeight = null;
                        actionState.currentX = null;
                        actionState.currentX = null;
                        actionState.currentY = null;
                        // Clear any hover-mode state
                        if (typeof snapHoverTimer !== 'undefined' && snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                        snapHoverMode = '';
                        // Ensure preview hidden as part of cleanup
                        hideSnapPreview();
                }
                // re-enable user selection and clear any selection left over from a drag
                // Only do this if we actually had an active action (drag/resize)
                // Determine whether the event target is an editable element (input/textarea/contenteditable)
                const target = e && e.target;
                const isEditable = target && ((target.matches && (target.matches('input, textarea'))) || target.isContentEditable || (target.closest && (target.closest('input, textarea, [contenteditable]'))));
                // Only clear selection if we had an active action (drag/resize) OR the mouseup occurred outside an editable element
                if (hadAction || !isEditable) {
                    document.body.style.userSelect = '';
                    const sel = window.getSelection && window.getSelection();
                    if (sel && sel.removeAllRanges) sel.removeAllRanges();
                }
                actionState.pointerId = null;
                actionState.captureTarget = null;
            }

            // --- Snap preview helpers ---
            function showSnapPreview(mode) {
                if (!snapPreview) return;
                const contentBoxWidth = desktop.clientWidth;
                const contentBoxHeight = desktop.clientHeight;
                const taskbarHeight = taskbar.offsetHeight;
                let left = 0, top = 0, width = contentBoxWidth, height = contentBoxHeight - taskbarHeight;
                switch (mode) {
                    case 'max':
                        left = 0; top = 0; width = contentBoxWidth; height = contentBoxHeight - taskbarHeight; break;
                    case 'left':
                        left = 0; top = 0; width = Math.floor(contentBoxWidth / 2); height = contentBoxHeight - taskbarHeight; break;
                    case 'right':
                        left = Math.ceil(contentBoxWidth / 2); top = 0; width = Math.floor(contentBoxWidth / 2); height = contentBoxHeight - taskbarHeight; break;
                    case 'left-top':
                        left = 0; top = 0; width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                    case 'right-top':
                        left = Math.ceil(contentBoxWidth / 2); top = 0; width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                    case 'left-bottom':
                        left = 0; top = Math.ceil((contentBoxHeight - taskbarHeight) / 2); width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                    case 'right-bottom':
                        left = Math.ceil(contentBoxWidth / 2); top = Math.ceil((contentBoxHeight - taskbarHeight) / 2); width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                }
                snapPreview.style.left = `${left}px`;
                snapPreview.style.top = `${top}px`;
                snapPreview.style.width = `${width}px`;
                snapPreview.style.height = `${height}px`;
                snapPreview.classList.add('show');
                snapPreview.dataset.mode = mode;
            }
            function hideSnapPreview() {
                if (!snapPreview) return;
                snapPreview.classList.remove('show');
                snapPreview.dataset.mode = '';
            }
            document.addEventListener('mouseup', (e) => {
                clearActionState(e);
            });
            document.addEventListener('pointerup', (e) => {
                clearActionState(e);
            });
            document.addEventListener('pointercancel', (e) => {
                clearActionState(e);
            });
            window.addEventListener('blur', () => { clearActionState(); });

            // --- 10. 應用程式開啟邏輯 ---
            
            // 10.1 從桌面圖示開啟 (雙擊)
            desktopIcons.forEach(icon => {
                icon.addEventListener('dblclick', () => {
                    openWindow(icon.dataset.app);
                });
            });

            // 10.2 從任務欄圖示開啟/切換
            // We use event delegation so dynamically created temporary icons are handled too.
            const taskbarCenterGroup = document.querySelector('#taskbar .taskbar-group.center');
            if (taskbarCenterGroup) {
                taskbarCenterGroup.addEventListener('click', (e) => {
                    const icon = e.target.closest('.taskbar-icon');
                    if (!icon) return;
                    const appId = icon.dataset.app;
                    const windowEl = document.getElementById(`window-${appId}`);
                    if (!windowEl) return;
                    if (windowEl.classList.contains('minimized')) {
                        openWindow(appId);
                    } else if (windowEl.classList.contains('show') && windowEl.classList.contains('active')) {
                        minimizeWindow(appId);
                    } else if (windowEl.classList.contains('show')) {
                        focusWindow(windowEl);
                    } else {
                        openWindow(appId);
                    }
                });
                // keyboard accessibility: handle Enter/Space on focused icon
                taskbarCenterGroup.addEventListener('keydown', (e) => {
                    const icon = e.target.closest && e.target.closest('.taskbar-icon') ? e.target.closest('.taskbar-icon') : null;
                    if (!icon) return;
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        icon.click();
                    }
                });
            }
            
            // 10.3 從開始功能表開啟
            startMenu.querySelectorAll('.app-icon[data-app]').forEach(icon => {
                icon.addEventListener('click', () => {
                    openWindow(icon.dataset.app);
                    startMenu.classList.remove('show');
                });
            });
            // Bind click action to start menu '開始設定' context item
            const startMenuSettingsItem = document.getElementById('start-menu-settings');
            if (startMenuSettingsItem) {
                startMenuSettingsItem.addEventListener('click', () => {
                    openWindow('settings');
                    // close start menu and its context menu
                    startMenu.classList.remove('show');
                    startMenuSettingsItem.closest('#start-context-menu').classList.remove('show');
                });
            }

            // --- 11. 長門櫻 (模擬的對話助理，功能增強) ---
            const nagatoWindow = document.getElementById('window-nagato');
            const nagatoMessages = nagatoWindow.querySelector('.nagato-messages');
            const nagatoInput = nagatoWindow.querySelector('#nagato-input');
            const nagatoSend = nagatoWindow.querySelector('#nagato-send');
            const NAGATO_KEY = 'nagato_conversation_v1';

            // Load conversation from localStorage and render
            function loadNagatoConversation() {
                try {
                    const raw = localStorage.getItem(NAGATO_KEY);
                    if (!raw) return [];
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) return [];
                    return parsed;
                } catch (e) { return []; }
            }
            function saveNagatoConversation(arr) {
                try { localStorage.setItem(NAGATO_KEY, JSON.stringify(arr)); } catch (e) { console.warn(e); }
            }
            function renderNagatoMessages() {
                let list = loadNagatoConversation();
                // Seed a friendly greeting if no previous conversation found
                if (!list || !list.length) {
                    list = [{ role: 'ai', text: '主人您好！我叫長門櫻，您的專屬女僕。請問您有什麼需要長門櫻為您效勞的嗎？', ts: Date.now() }];
                    saveNagatoConversation(list);
                }
                nagatoMessages.innerHTML = '';
                list.forEach(msg => {
                    const el = document.createElement('div');
                    el.classList.add('message', msg.role === 'user' ? 'user' : 'ai');
                    el.textContent = msg.text;
                    nagatoMessages.appendChild(el);
                });
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }

            function showTypingIndicator() {
                const typing = document.createElement('div');
                typing.classList.add('message', 'ai', 'typing');
                typing.innerHTML = '<span class="typing-dots"><span></span><span></span><span></span></span>';
                typing.id = 'nagato-typing';
                nagatoMessages.appendChild(typing);
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }
            function hideTypingIndicator() {
                const el = document.getElementById('nagato-typing');
                if (el) el.remove();
            }

            function generateNagatoResponse(userText) {
                const txt = userText.toLowerCase();
                if (/^(hi|hello|嘿|嗨|你好|您 好)/i.test(userText)) {
                    return '主人您好！請問您有什麼需要長門櫻為您效勞的嗎？';
                }
                if (txt.includes('時間')) {
                    const now = new Date();
                    const hh = String(now.getHours()).padStart(2, '0');
                    const mm = String(now.getMinutes()).padStart(2, '0');
                    return `現在是 ${hh}:${mm}`;
                }
                if (txt.includes('日期')) return `今天是 ${new Date().toLocaleDateString('zh-TW')}`;
                if (txt.includes('開啟') && txt.includes('設定')) return '好的，即將開啟設定。';
                if (txt.includes('開啟') && txt.includes('瀏覽')) return '好的，正在開啟瀏覽器。';
                if (txt.includes('我的網站') || txt.includes('網站')) return '你可以查看你的網站: https://amanoshizukikun.github.io/';
                if (txt.includes('幫助')) return '我能提供時間、日期、打開應用程式，或簡單回答一般問題。你可以試試說 "告訴我今天的時間"。';
                // fallback: summarize / echo back a short reply
                const truncated = userText.length > 120 ? userText.slice(0, 117) + '…' : userText;
                return `收到："${truncated}"。你想要我怎麼處理？`;
            }

            function appendNagatoMessage(role, text) {
                const el = document.createElement('div');
                el.classList.add('message', role === 'user' ? 'user' : 'ai');
                el.textContent = text;
                nagatoMessages.appendChild(el);
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }

            function sendNagatoMessage() {
                const message = nagatoInput.value.trim();
                if (!message) return;
                // store
                const conv = loadNagatoConversation();
                conv.push({ role: 'user', text: message, ts: Date.now() });
                saveNagatoConversation(conv);

                appendNagatoMessage('user', message);
                nagatoInput.value = '';
                showTypingIndicator();

                // Simulate AI latency based on message length
                const delay = Math.min(1400 + message.length * 5, 2200);
                setTimeout(() => {
                    hideTypingIndicator();
                    const resp = generateNagatoResponse(message);
                    appendNagatoMessage('ai', resp);
                    // store AI response
                    const conv2 = loadNagatoConversation();
                    conv2.push({ role: 'ai', text: resp, ts: Date.now() });
                    saveNagatoConversation(conv2);
                    // optionally include quick actions
                    addNagatoQuickActions(resp);
                }, delay);
            }

            function addNagatoQuickActions(respText) {
                // remove previous suggestions
                nagatoMessages.querySelectorAll('.message-suggestions').forEach(el => el.remove());
                // Suggest a couple quick actions based on the response
                const container = document.createElement('div');
                container.className = 'message-suggestions';
                // Basic actions
                const suggestions = [
                    { label: '開啟設定', action: () => openWindow('settings') },
                    { label: '開啟瀏覽器', action: () => openWindow('browser') },
                    { label: '顯示時間', action: () => { sendNagatoMessageFromBtn('現在時間是多少？'); } }
                ];
                suggestions.forEach(s => {
                    const b = document.createElement('button');
                    b.className = 'suggestion-btn';
                    b.textContent = s.label;
                    b.addEventListener('click', (e) => { e.stopPropagation(); s.action(); });
                    container.appendChild(b);
                });
                nagatoMessages.appendChild(container);
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }

            function sendNagatoMessageFromBtn(text) {
                nagatoInput.value = text;
                sendNagatoMessage();
            }

            // Event bindings
            nagatoSend.addEventListener('click', sendNagatoMessage);
            nagatoInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendNagatoMessage(); }
            });
            // Auto-resize textarea for better UX
            function autoResizeNagatoInput() {
                nagatoInput.style.height = 'auto';
                nagatoInput.style.height = (nagatoInput.scrollHeight) + 'px';
            }
            nagatoInput.addEventListener('input', autoResizeNagatoInput);
            autoResizeNagatoInput();
            // initialize messages
            renderNagatoMessages();
            // Bind clear button
            const nagatoClearBtn = document.getElementById('nagato-clear');
            if (nagatoClearBtn) {
                nagatoClearBtn.addEventListener('click', () => {
                    if (!confirm('確認要清除長門櫻的聊天紀錄嗎？')) return;
                    saveNagatoConversation([]);
                    renderNagatoMessages();
                });
            }
            
            // --- 12. 初始化 ---
            // Calculator initialization and enhancements
            try {
                // instantiate app calculator (if element exists)
                if (document.querySelector('#win-calc')) {
                    window.appCalculator = new Calculator('#calc-input', '#win-calc>.keyb');
                }
                // Make calc buttons accessible and attach keyboard (Enter/Space) handlers
                document.querySelectorAll('#win-calc .b').forEach(btn => {
                    btn.setAttribute('role', 'button');
                    btn.setAttribute('tabindex', '0');
                    if (!btn.hasAttribute('aria-label')) btn.setAttribute('aria-label', btn.textContent.trim());
                    btn.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); } });
                });

                // Global keyboard handler while calculator is focused/active
                document.addEventListener('keydown', (e) => {
                    try {
                        const active = activeWindow; // var from earlier
                        if (!active || active.id !== 'window-calculator') return;
                        if (!window.appCalculator) return;
                        const key = e.key;
                        if (/^[0-9]$/.test(key)) { window.appCalculator.number_key(Number(key)); e.preventDefault(); return; }
                        if (key === '.') { window.appCalculator.point(); e.preventDefault(); return; }
                        if (key === '+' || key === '-') { window.appCalculator.func_key(key === '+' ? 1 : 2); 
                            // set visual checked
                            const el = document.querySelector(key === '+' ? '#win-calc>.keyb>.jia' : '#win-calc>.keyb>.jian');
                            if (el) window.appCalculator.check(el);
                            e.preventDefault();
                            return;
                        }
                        if (key === '*' || key === 'x' || key === 'X') { window.appCalculator.func_key(3); const el = document.querySelector('#win-calc>.keyb>.cheng'); if (el) window.appCalculator.check(el); e.preventDefault(); return; }
                        if (key === '/') { window.appCalculator.func_key(4); const el = document.querySelector('#win-calc>.keyb>.chu'); if (el) window.appCalculator.check(el); e.preventDefault(); return; }
                        if (key === 'Enter' || key === '=') { window.appCalculator.eq(); e.preventDefault(); return; }
                        if (key === 'Backspace') { window.appCalculator.backspace(); e.preventDefault(); return; }
                        if (key === 'Escape') { window.appCalculator.clear_num(); e.preventDefault(); return; }
                    } catch (error) { console.error('Calculator keyboard handler error', error); }
                });
            } catch (err) { console.warn('Calculator init failed', err); }
            initBootSequence();
            renderCalendar();
            // Ensure taskbar icon states (open-app / active-app) are synced to current windows
            function syncTaskbarWithWindows() {
                getAllTaskbarIcons().forEach(icon => {
                    const appId = icon.dataset.app;
                    const winEl = document.getElementById(`window-${appId}`);
                    // Keep open-app if showing or minimized
                    if (winEl && (winEl.classList.contains('show') || winEl.classList.contains('minimized'))) {
                        icon.classList.add('open-app');
                    } else {
                        icon.classList.remove('open-app');
                    }
                    if (winEl && winEl.classList.contains('active')) {
                        icon.classList.add('active-app');
                        icon.setAttribute('aria-pressed', 'true');
                    } else {
                        icon.classList.remove('active-app');
                        icon.setAttribute('aria-pressed', 'false');
                    }
                });
            }
            syncTaskbarWithWindows();
            // 全域初始化 (背景、導航、動畫)
            if (typeof Core !== 'undefined' && typeof Core.initBackground === 'function') Core.initBackground();
            if (typeof Navigation !== 'undefined' && typeof Navigation.init === 'function') Navigation.init();
            if (typeof Animations !== 'undefined' && typeof Animations.init === 'function') Animations.init();
            
            // 處理窗口大小變化 (用於最大化視窗)
            // 監聽 window resize 事件，以確保在瀏覽器大小變化時，最大化的視窗能正確調整高度
            window.addEventListener('resize', () => {
                document.querySelectorAll('.window[data-is-maximized="true"]').forEach(window => {
                    window.style.height = `calc(100% - ${taskbar.offsetHeight}px)`;
                });
            });

            // --- Browser Favorites (最愛/書籤) ---
            const favoritesKey = 'sim_favorites_v1';
            const favoritesBar = document.getElementById('favorites-bar');
            const browserBack = document.getElementById('browser-back');
            const browserForward = document.getElementById('browser-forward');
            const browserRefresh = document.getElementById('browser-refresh');
            const browserUrlInput = document.getElementById('browser-url-input');
            const bookmarkToggle = document.getElementById('bookmark-toggle');
            const browserWindow = document.getElementById('window-browser');
            const browserIframe = browserWindow.querySelector('iframe');

            // Basic history implemented client-side (for navigation via this UI only)
            let browserHistory = [];
            let browserHistoryIndex = -1;

            const defaultFavorites = [
                { title: '我的網站', url: 'https://amanoshizukikun.github.io/' }
            ];

            function loadFavorites() {
                try {
                    const raw = localStorage.getItem(favoritesKey);
                    if (!raw) return defaultFavorites.slice();
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) return defaultFavorites.slice();
                    return parsed;
                } catch (e) {
                    console.warn('Failed to load favorites', e);
                    return defaultFavorites.slice();
                }
            }

            function saveFavorites(list) {
                try {
                    localStorage.setItem(favoritesKey, JSON.stringify(list));
                } catch (e) {
                    console.warn('Failed to save favorites', e);
                }
            }

            function renderFavorites() {
                const list = loadFavorites();
                favoritesBar.innerHTML = '';
                list.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'fav-item';
                    el.setAttribute('role', 'button');
                    el.setAttribute('tabindex', '0');
                    el.setAttribute('title', item.url);
                    el.innerHTML = `<img class="favicon" src="https://www.google.com/s2/favicons?sz=64&domain_url=${encodeURIComponent(item.url)}" alt=""> <span class="title">${item.title}</span>`;
                    el.addEventListener('click', (e) => {
                        e.preventDefault();
                        openWindow('browser');
                        setBrowserUrl(item.url, true);
                    });
                    el.addEventListener('keydown', (e) => { if (e.key === 'Enter') el.click(); });
                    favoritesBar.appendChild(el);
                });
            }

            function isFavorite(url) {
                const list = loadFavorites();
                return list.some(item => item.url === url);
            }

            function addFavorite(obj) {
                if (!obj || !obj.url) return;
                const list = loadFavorites();
                if (list.some(i => i.url === obj.url)) return;
                list.unshift(obj);
                saveFavorites(list);
                renderFavorites();
            }

            function removeFavoriteByUrl(url) {
                let list = loadFavorites();
                list = list.filter(i => i.url !== url);
                saveFavorites(list);
                renderFavorites();
            }

            function setBrowserUrl(url, pushHistory = true) {
                if (!url) return;
                // Ensure protocol for local relative paths
                // Normalize the urls to absolute for a robust comparison
                const normalize = (u) => {
                    try { return new URL(u, window.location.href).href; } catch (e) { return u; }
                };
                const normalized = normalize(url);
                const current = browserIframe ? browserIframe.src : '';
                // If the normalized URL is the same as current iframe src, avoid resetting it (prevents reload/reset when restoring from minimized state)
                if (current && normalized === current) {
                    // Still update UI states
                    browserUrlInput.value = url;
                    updateNavigationButtons();
                    updateBookmarkButton(url);
                    return;
                }
                browserUrlInput.value = url;
                browserIframe.src = url;
                // Show iframe (Edge style uses .show class)
                browserIframe.classList.add('show');
                // Add to internal history
                if (pushHistory) {
                    // If we navigate to a new URL while not at the end of history, discard the forward
                    if (browserHistoryIndex < browserHistory.length - 1) {
                        browserHistory = browserHistory.slice(0, browserHistoryIndex + 1);
                    }
                    browserHistory.push(url);
                    browserHistoryIndex = browserHistory.length - 1;
                }
                updateNavigationButtons();
                updateBookmarkButton(url);
            }

            function updateNavigationButtons() {
                browserBack.classList.toggle('disabled', browserHistoryIndex <= 0);
                browserForward.classList.toggle('disabled', browserHistoryIndex >= browserHistory.length - 1);
                // Add a11y attributes
                browserBack.setAttribute('aria-disabled', String(browserHistoryIndex <= 0));
                browserForward.setAttribute('aria-disabled', String(browserHistoryIndex >= browserHistory.length - 1));
            }

            browserBack.addEventListener('click', () => {
                if (browserHistoryIndex <= 0) return;
                browserHistoryIndex -= 1;
                setBrowserUrl(browserHistory[browserHistoryIndex], false);
            });
            browserForward.addEventListener('click', () => {
                if (browserHistoryIndex >= browserHistory.length - 1) return;
                browserHistoryIndex += 1;
                setBrowserUrl(browserHistory[browserHistoryIndex], false);
            });
            browserRefresh.addEventListener('click', () => {
                try { browserIframe.contentWindow.location.reload(); } catch (e) { browserIframe.src = browserUrlInput.value; }
            });

            bookmarkToggle.addEventListener('click', () => {
                const url = browserUrlInput.value;
                if (!url) return;
                if (isFavorite(url)) removeFavoriteByUrl(url);
                else addFavorite({ title: url.replace(/https?:\/\//, '').replace(/\/.*$/, ''), url: url });
                updateBookmarkButton(url);
            });

            function updateBookmarkButton(url) {
                const icon = bookmarkToggle.querySelector('i');
                if (isFavorite(url)) {
                    icon.classList.remove('fa-regular');
                    icon.classList.add('fa-solid');
                    bookmarkToggle.setAttribute('aria-pressed', 'true');
                } else {
                    icon.classList.remove('fa-solid');
                    icon.classList.add('fa-regular');
                    bookmarkToggle.setAttribute('aria-pressed', 'false');
                }
            }

            // Initialize: render favorites and load default homepage if needed
            renderFavorites();
            // If the iframe is blank, set a friendly default
            const initialUrl = 'https://amanoshizukikun.github.io/';
            if (browserIframe && (browserIframe.src === 'about:blank' || !browserIframe.src)) {
                setBrowserUrl(initialUrl, true);
            } else if (browserIframe && browserIframe.src && browserIframe.src !== 'about:blank') {
                setBrowserUrl(browserIframe.src, true);
            }

            // When the browser window receives focus (is opened/activated), update bookmark status for current URL
            // Hook into openWindow by wrapping a reference to previous openWindow behavior is already used. We'll listen for focus changes.
            document.addEventListener('click', (e) => {
                // If a browser taskbar icon was clicked and it's showing then update
                const openIcon = document.getElementById('taskbar-icon-browser');
                if (openIcon && openIcon.classList.contains('open-app')) {
                    updateBookmarkButton(browserUrlInput.value);
                }
            });

            // Allow pressing Enter on url input to open
            browserUrlInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const url = browserUrlInput.value.trim() || initialUrl;
                    setBrowserUrl(url, true);
                }
            });
            // Ensure clicking or mousedown on the URL input doesn't let parent handlers steal focus
            browserUrlInput.addEventListener('mousedown', (e) => {
                // Prevent any simulator-level click handlers from hiding menus or stealing focus
                e.stopPropagation();
            });
            browserUrlInput.addEventListener('click', (e) => {
                e.stopPropagation();
                browserUrlInput.focus();
            });
        });
    </script>

    <!-- Weather widget script -->
    <script>
    (function (){
        const DEFAULT_CITY = '台北';
        const CACHE_KEY = 'webos_weather_cache_v1';
        const CACHE_TTL = 10 * 60 * 1000; // 10 minutes
        const weatherInput = document.getElementById('weather-city-input');
        const weatherRefresh = document.getElementById('weather-refresh');
        const weatherGeo = document.getElementById('weather-geolocate');
        const weatherIcon = document.getElementById('weather-icon');
        const weatherTemp = document.getElementById('weather-temp');
        const weatherDesc = document.getElementById('weather-desc');
        const weatherHumidity = document.getElementById('weather-humidity');
        const weatherFeels = document.getElementById('weather-feels');
        const weatherForecast = document.getElementById('weather-forecast');
        const weatherLocSpan = document.getElementById('weather-location');
        const weatherUpdatedElem = document.getElementById('weather-updated');

        function _getCache(){
            try{ return JSON.parse(localStorage.getItem(CACHE_KEY)); }catch(e){return null}
        }
        function _setCache(city, data){
            localStorage.setItem(CACHE_KEY, JSON.stringify({city, ts: Date.now(), data}));
        }
        function _checkCache(city){
            const c = _getCache();
            if(!c || c.city !== city) return null;
            if(Date.now() - c.ts > CACHE_TTL) return null;
            return c.data;
        }

        async function fetchWeatherData(city){
            // Primary: wttr.in JSON
            const wttrUrl = `https://wttr.in/${encodeURIComponent(city)}?format=j1`;
            try{
                const resp = await fetch(wttrUrl);
                if(resp.ok){
                    return await resp.json();
                }
                // fallback via allorigins to avoid CORS issues
                const fallback = `https://api.allorigins.win/raw?url=${encodeURIComponent(wttrUrl)}`;
                const alt = await fetch(fallback);
                if(alt.ok) return await alt.json();
                throw new Error('無法從 wttr.in 獲取資料');
            }catch(e){
                // Try allorigins if first failed
                try{
                    const fallback = `https://api.allorigins.win/raw?url=${encodeURIComponent(wttrUrl)}`;
                    const alt = await fetch(fallback);
                    if(alt.ok) return await alt.json();
                }catch(err){ }
                throw e;
            }
        }

        function getIconForDesc(desc){
            if(!desc) return 'fa-cloud-sun';
            const d = desc.toLowerCase();
            if(d.includes('rain') || d.includes('雨') || d.includes('shower') || d.includes('drizzle') || d.includes('thunder')) return 'fa-cloud-showers-heavy';
            if(d.includes('snow') || d.includes('snow') || d.includes('flake') || d.includes('雪')) return 'fa-snowflake';
            if(d.includes('cloud') || d.includes('cloudy') || d.includes('多雲') || d.includes('陰')) return 'fa-cloud';
            if(d.includes('clear') || d.includes('sun') || d.includes('晴') || d.includes('晴時')) return 'fa-sun';
            if(d.includes('mist') || d.includes('fog') || d.includes('霧')) return 'fa-smog';
            return 'fa-cloud-sun';
        }

        function render(data, city){
            try{
                const current = data.current_condition && data.current_condition[0];
                const nearest = (data.nearest_area && data.nearest_area[0]) || null;
                const locName = nearest && (nearest.areaName && nearest.areaName[0] && nearest.areaName[0].value) ? nearest.areaName[0].value : city;
                weatherLocSpan.innerText = locName;
                // icon
                const desc = (current && current.weatherDesc && current.weatherDesc[0] && current.weatherDesc[0].value) || '';
                const iconClass = getIconForDesc(desc);
                // using font awesome classes on <i>
                // Replace icon element classes
                weatherIcon.className = `fa-solid ${iconClass}`;
                // temps
                weatherTemp.innerText = `${current.temp_C}°C`;
                weatherDesc.innerText = desc;
                weatherHumidity.innerText = `濕度: ${current.humidity}%`;
                weatherFeels.innerText = `體感: ${current.FeelsLikeC}°C`;
                // forecast
                weatherForecast.innerHTML = '';
                if(Array.isArray(data.weather)){
                    for(let i=0;i<data.weather.length && i<3;i++){
                        const d = data.weather[i];
                        const date = d.date;
                        const high = d.maxtempC;
                        const low = d.mintempC;
                        const midday = (d.hourly && d.hourly[4] && d.hourly[4].weatherDesc && d.hourly[4].weatherDesc[0] && d.hourly[4].weatherDesc[0].value) ? d.hourly[4].weatherDesc[0].value : '';
                        const ic = getIconForDesc(midday);
                        const item = document.createElement('div');
                        item.className = 'forecast-item';
                        item.innerHTML = `
                            <div class="date">${date}</div>
                            <div class="icon"><i class="fa-solid ${ic}"></i></div>
                            <div class="temp">${high}° / ${low}°</div>
                            <div class="desc" style="font-size:0.8rem;color:#bbb">${midday}</div>
                        `;
                        weatherForecast.appendChild(item);
                    }
                }
                // Update last refreshed time
                try{ weatherUpdatedElem.innerText = '更新: ' + new Date().toLocaleTimeString(); }catch(e){}
            }catch(e){
                weatherDesc.innerText = '解析資料時發生錯誤';
                weatherForecast.innerHTML = '';
            }
        }

        async function updateWeather(city){
            if(!city) city = DEFAULT_CITY;
            // show loading
            weatherDesc.innerText = '載入中...';
            // UI feedback - disable buttons and animate refresh icon
            try{ weatherRefresh.disabled = true; weatherRefresh.style.opacity = '0.6'; weatherRefresh.querySelector('i')?.classList.add('fa-spin'); }catch(e){}
            try{
                const cached = _checkCache(city);
                let data = cached;
                if(!data){
                    data = await fetchWeatherData(city);
                    _setCache(city, data);
                }
                render(data, city);
            }catch(e){
                console.error(e);
                weatherDesc.innerText = '無法獲取天氣資料';
                weatherForecast.innerHTML = '';
            }
            try{ weatherRefresh.disabled = false; weatherRefresh.style.opacity = '1'; weatherRefresh.querySelector('i')?.classList.remove('fa-spin'); }catch(e){}
        }

        async function detectLocationAndUpdate(){
            if(!navigator.geolocation){
                return updateWeather(DEFAULT_CITY);
            }
            weatherDesc.innerText = '獲取定位中...';
            navigator.geolocation.getCurrentPosition(async pos => {
                try{
                    const {latitude, longitude} = pos.coords;
                    const nomUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`;
                    const r = await fetch(nomUrl);
                    if(r.ok){
                        const rjson = await r.json();
                        const city = rjson.address.city || rjson.address.town || rjson.address.village || rjson.address.county || rjson.address.state || DEFAULT_CITY;
                        weatherInput.value = city;
                        updateWeather(city);
                    }else{
                        updateWeather(DEFAULT_CITY);
                    }
                }catch(e){
                    updateWeather(DEFAULT_CITY);
                }
            }, err => {
                updateWeather(DEFAULT_CITY);
            }, {timeout: 8000});
        }

        // Initialize: populate input and run first fetch
            (function init(){
            weatherInput.value = DEFAULT_CITY;
            weatherInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') updateWeather(weatherInput.value.trim()); });
            weatherRefresh.addEventListener('click', () => { updateWeather(weatherInput.value.trim() || DEFAULT_CITY); });
            weatherGeo.addEventListener('click', () => { detectLocationAndUpdate(); });
            // auto populate from cache or run update
            const cache = _getCache();
            const city = (cache && cache.city) ? cache.city : DEFAULT_CITY;
            if(cache && cache.ts && (Date.now() - cache.ts) < CACHE_TTL && cache.data){
                render(cache.data, city);
            }else{
                updateWeather(city);
            }
            })();
            // Auto refresh every 10 minutes (cache TTL)
            setInterval(() => { updateWeather(weatherInput.value.trim() || DEFAULT_CITY); }, CACHE_TTL);

    })();
    </script>