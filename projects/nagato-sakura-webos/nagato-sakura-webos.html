<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="天野靜樹的 OS 網頁模擬器">
    <meta name="author" content="天野靜樹">
    <meta name="keywords" content="天野靜樹">
    <title>天野靜樹 - WEB OS</title>
    <link rel="icon" href="../../assets/images/logo.png" type="image/png">
    
    <!-- 圖示庫 (Font Awesome) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- 全域樣式 (確保 header / settings-panel 使用全域樣式) -->
    <link rel="stylesheet" href="../../assets/css/core.css">
    <link rel="stylesheet" href="../../assets/css/components.css">
    <link rel="stylesheet" href="../../assets/css/animations.css">
    
    <!-- 字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* 顏色 */
            --primary-cyan: #00d4ff;
            --primary-magenta: #ff0080;
            --accent-cyan: #00ffff;
            --accent-pink: #ff69b4; 
            --accent-purple: #8b5cf6;
            --primary-yellow: #ffff00;
            
            --dark-bg: #0a0a0f;
            --darker-bg: #050507;
            
            /* 改良的毛玻璃/Mica效果 */
            --mica-bg: rgba(30, 30, 45, 0.7);
            --mica-bg-light: rgba(45, 45, 60, 0.7);
            --mica-bg-dark: rgba(20, 20, 30, 0.8);
            --mica-blur: 20px;
            
            /* 字體 */
            --font-display: 'Orbitron', monospace;
            --font-body: 'Rajdhani', sans-serif;
            --font-ui: 'Noto Sans TC', sans-serif;
            
            /* UI 尺寸 */
            --taskbar-height: 50px;
            --taskbar-icon-size: 24px; /* New: icon size used by both font & image icons */
            --window-border-radius: 8px;
            
            /* Z-Index Hierarchy (Highest to Lowest) */
            --z-header: 5000;
            --z-taskbar: 4000;
            --z-start-menu: 3900;
            --z-widgets: 3800; /* Calendar & Widgets */
            --z-window-active: 3000;
            --z-snap-preview: 2000;
            --z-window-base: 1000; /* Inactive windows start here */
            
            --z-window: var(--z-window-base); /* Legacy support */
            --z-context-menu: 6000; /* Above everything */
            --z-loader: 9999;
            
            /* 新增：混合佈局尺寸 */
            --header-height: 60px;
            --sidebar-width: 280px;
            --text: #e6e6e6;            /* general text color */
            --card: rgba(255,255,255,0.03);
            --bd: rgba(0,0,0,0.2);
            --s3d: rgba(0,0,0,0.35);
            --mm: rgba(0,212,255,0.14);
            --theme-1: #00d4ff;
            --theme-2: #4caf50;
            /* 顯示/夜間光線控制 */
            --simulator-brightness: 1; /* 0.5 ~ 1.2 - controlled by亮度滑桿 */
            --background-brightness: 1; /* 0..1 - independent background brightness (slider 0..100 -> 0..1) */
            /* overlay alpha (0..1) used to dim background with a black overlay. Computed by JS as: 1 - background-brightness */
            --background-overlay: 0;
            --nightlight-opacity: 0; /* 0~0.5 - controlled by夜間光線 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: var(--font-ui), sans-serif;
            background-color: var(--dark-bg);
            color: #f0f0f0;
            
            /* 新增：為混合佈局修改 */
            display: flex;
            flex-direction: column;
            /* 防止 navigation.js 中 toggleSettings 設定的 paddingTop 影響佈局 */
            padding-top: 0 !important;
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20000; /* 確保 header 高於 nav-overlay (19998) */
            flex-shrink: 0;
        }

        /* 針對此頁面的 nav-overlay 調整，確保低於 header */
        .nav-overlay {
            z-index: 19998;
            top: var(--header-height, 60px); /* 從 header 下方開始 */
        }

        /* 1. 頂部導航欄 (use global header styles to match other pages) */
        .header-logo a {
            font-size: 1.5rem;
            color: var(--primary-cyan);
            text-decoration: none;
            font-weight: 700;
        }
        .header-nav a {
            color: #eee;
            text-decoration: none;
            margin-left: 25px;
            font-size: 0.9rem;
            font-family: var(--font-body);
            transition: color 0.2s ease;
        }
        .header-nav a:hover {
            color: var(--primary-cyan);
        }

        /* 2. 主內容包裝器 */
        .main-wrapper {
            display: flex;
            width: 100%;
            /* height: 100vh; */
            flex-grow: 1; /* 填滿剩餘空間 */
            margin-top: var(--header-height, 60px); /* 為固定的 header 預留空間 */
            min-height: calc(100vh - var(--header-height, 60px));
        }

        /* 3. 右側邊欄 */
        .cyber-sidebar {
            width: var(--sidebar-width);
            flex-shrink: 0;
            z-index: 5;
            z-index: 5;
            background: rgba(10, 10, 15, 0.7);
            backdrop-filter: blur(15px);
            border-left: 1px solid rgba(255, 255, 255, 0.1); /* 改為左邊框 */
            z-index: 1500;
            padding: 20px;
            font-family: var(--font-body);
            color: #ccc;
            overflow-y: auto;
        }
        .cyber-sidebar h3 {
            color: var(--primary-cyan);
            font-family: var(--font-display);
            margin-bottom: 15px;
            border-bottom: 1px solid var(--primary-cyan);
            padding-bottom: 5px;
        }
        .cyber-sidebar ul {
            list-style: none;
            padding: 0;
        }
        .cyber-sidebar li {
            padding: 12px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 1.1rem;
        }
        .cyber-sidebar li:hover {
            background: rgba(0, 212, 255, 0.1);
            color: #fff;
        }
        .cyber-sidebar li i {
            margin-right: 12px;
            width: 20px;
            text-align: center;
        }

        /* 4. 模擬器容器 */
        .simulator-container {
            flex-grow: 1;
            position: relative; /* 關鍵：使所有子元素相對於此定位 */
            height: calc(100vh - var(--header-height, 60px));
            overflow: hidden;
            margin-top: 0; /* 防止任何其他邊距導致空隙 */
            /* Apply overall brightness using CSS variable */
            filter: brightness(var(--simulator-brightness));
        }

        /* Desktop background layer: sits below UI content and above the page background
           to allow independent brightness control for wallpapers & gradients */
        #desktop-bg {
            position: absolute;
            inset: 0 0 0 0;
            z-index: calc(var(--z-window) - 50); /* behind windows/desktop content */
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            filter: brightness(var(--background-brightness));
            /* Hint browser to use GPU compositing for smoother updates */
            transform: translateZ(0);
            will-change: filter, transform;
            backface-visibility: hidden;
            pointer-events: none; /* don't block clicks */
            /* allow background & opacity fade rather than a sliding animation */
            opacity: 1;
            transition: background 0.18s ease, filter 0.18s ease, opacity 0.32s ease;
        }

        /* Video background element - occupies same space as desktop-bg and supports brightness control */
        #desktop-video {
            position: absolute;
            inset: 0 0 0 0;
            z-index: calc(var(--z-window) - 49);
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: brightness(var(--background-brightness));
            opacity: 0; /* hidden until set by JS */
            transition: opacity 0.32s ease, filter 0.18s ease;
            pointer-events: none;
        }

        /* Shared overlay placed above desktop background (image/video) but beneath windows/desktop UI */
        #desktop-overlay {
            position: absolute;
            inset: 0;
            z-index: calc(var(--z-window) - 40); /* sits above bg & video but below UI windows */
            pointer-events: none;
            background: rgba(0,0,0,1);
            opacity: var(--background-overlay, 0);
            transition: opacity 120ms linear;
        }

        /* Use a dimming overlay on the background layer to avoid changing expensive filter properties
           while sliding brightness. The overlay's opacity is controlled via CSS var --background-overlay. */
        #desktop-bg::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,1);
            opacity: var(--background-overlay, 0);
            pointer-events: none;
            transition: opacity 120ms linear;
            will-change: opacity;
            z-index: 0;
        }

        /* Night light overlay sits on top of simulator content but below menus/overlays */
        #nightlight-overlay {
            position: absolute;
            inset: 0 0 0 0; /* top/right/bottom/left */
            pointer-events: none;
            z-index: calc(var(--z-start-menu) - 1); /* just beneath start menu */
            background: rgba(255, 137, 73, var(--nightlight-opacity));
            mix-blend-mode: overlay;
            transition: opacity 0.18s ease, background 0.18s ease;
            opacity: 0;
        }

        /* 1. 啟動加載器 */
        #boot-loader {
            position: absolute; /* 修改 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: var(--z-loader);
            transition: opacity 0.5s ease-out;
        }
        #boot-logo {
            width: 8rem;
            height: 8rem;
            margin-bottom: 2rem;
            animation: pulse 2s infinite ease-in-out;
            object-fit: contain;
        }
        #boot-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--primary-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #boot-status {
            margin-top: 2rem;
            font-family: var(--font-body);
            font-size: 1.2rem;
            color: #aaa;
        }

        /* 2. 桌面 */
            #desktop {
            position: absolute; /* 修改 */
            z-index: calc(var(--z-window) - 40);
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at bottom, #0a192f 0%, #05080f 100%);
            overflow: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            gap: 15px;
            align-content: flex-start;
        }

        .desktop-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            width: 80px;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .desktop-icon:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .desktop-icon i {
            font-size: 2.5rem;
            margin-bottom: 8px;
            color: #fff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .desktop-icon span {
            font-size: 0.85rem;
            color: #f0f0f0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
            word-break: break-all;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* 3. 任務欄 */
        #taskbar {
            position: absolute; /* 修改 */
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--taskbar-height);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: var(--z-taskbar);
            
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        .taskbar-group {
            display: flex;
            height: 100%;
            align-items: center;
            padding: 0 4px; /* reduced outer padding for tighter layout */
            gap: 4px; /* reduce spacing between icon groups */
        }
        .taskbar-group.center {
            justify-content: center;
            flex-grow: 1;
            gap: 4px; /* tighter gap between center icons */
        }
        .taskbar-group.right {
            justify-content: flex-end;
        }

        .taskbar-icon {
            font-size: 1.2rem; /* baseline font for FA icons */
            color: #e0e0e0;
            /* shrink the clickable area and reduce spacing while maintaining tappable size */
            min-width: calc(var(--taskbar-icon-size) + 16px);
            padding: 0 4px; /* reduced horizontal padding, tighter spacing */
            height: 100%;
            display: inline-flex; /* inline to avoid full-width flex children issues */
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background-color 0.18s ease;
            cursor: pointer;
            box-sizing: border-box;
        }
        .taskbar-icon:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        /* Make sure FA icons and images match in size */
        .taskbar-icon i { font-size: var(--taskbar-icon-size); line-height: 1; display: inline-block; }
        .taskbar-icon img { width: var(--taskbar-icon-size); height: var(--taskbar-icon-size); display: inline-block; object-fit: contain; }
        /* For apps that are open (in background) */
        .taskbar-icon.open-app::after {
            content: '';
            position: absolute;
            bottom: 6px; /* keep gap from bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 3px; /* 較短 */
            background: var(--primary-cyan);
            opacity: 0.6;
            border-radius: 999px; /* pill */
            transition: all 0.15s ease;
        }

        /* For apps active in foreground */
        .taskbar-icon.active-app {
            background: rgba(255, 255, 255, 0.08);
        }
        .taskbar-icon.active-app::after {
            content: '';
            position: absolute;
            bottom: 6px; /* keep gap from bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 16px; /* 較長 */
            height: 3px;
            background: var(--primary-cyan);
            opacity: 1;
            border-radius: 999px; /* pill */
            box-shadow: 0 0 6px rgba(0, 212, 255, 0.15);
        }
        [data-theme="light"] .taskbar-icon.open-app::after {
            background: var(--primary-cyan);
            box-shadow: none;
        }
        [data-theme="light"] .taskbar-icon.active-app::after {
            box-shadow: none;
        }

        /* ========== 淺色模式完整樣式 ========== */
        [data-theme="light"] {
            --dark-bg: #f5f5f7;
            --darker-bg: #e8e8ec;
            --mica-bg: rgba(255, 255, 255, 0.85);
            --mica-bg-light: rgba(255, 255, 255, 0.9);
            --mica-bg-dark: rgba(245, 245, 247, 0.92);
            --text: #1a1a1a;
            --card: rgba(0, 0, 0, 0.03);
            --bd: rgba(0, 0, 0, 0.1);
            --s3d: rgba(0, 0, 0, 0.15);
            --mm: rgba(0, 160, 200, 0.12);
        }

        /* 頁面與桌面背景 */
        [data-theme="light"] body {
            background-color: #f5f5f7;
            color: #1a1a1a;
        }

        [data-theme="light"] #desktop {
            background: linear-gradient(135deg, #e8f4f8 0%, #d4e6ed 50%, #c8dce6 100%);
        }

        [data-theme="light"] #desktop-bg {
            background: linear-gradient(135deg, #e8f4f8 0%, #d4e6ed 50%, #c8dce6 100%);
        }

        /* 側邊欄 */
        [data-theme="light"] .cyber-sidebar {
            background: rgba(255, 255, 255, 0.85);
            border-left: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        [data-theme="light"] .cyber-sidebar li:hover {
            background: rgba(0, 160, 200, 0.1);
            color: #000;
        }

        /* 任務欄 */
        [data-theme="light"] #taskbar {
            background: rgba(255, 255, 255, 0.88);
            backdrop-filter: blur(20px) saturate(180%);
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }

        [data-theme="light"] .taskbar-icon {
            color: #333;
        }

        [data-theme="light"] .taskbar-icon:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] #taskbar-time {
            color: #333;
        }

        [data-theme="light"] #taskbar-time:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        /* 開始功能表 */
        [data-theme="light"] #start-menu {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        [data-theme="light"] .search-bar {
            background: rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        [data-theme="light"] .search-bar input {
            color: #1a1a1a;
        }

        [data-theme="light"] .search-bar input::placeholder {
            color: #888;
        }

        [data-theme="light"] .search-bar i {
            color: #666;
        }

        [data-theme="light"] .start-section-title {
            color: #555;
        }

        [data-theme="light"] .app-icon:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] .app-icon span {
            color: #1a1a1a;
        }

        [data-theme="light"] .recommended-item:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] .recommended-item i {
            color: #555;
        }

        [data-theme="light"] .recommended-item-info {
            color: #1a1a1a;
        }

        [data-theme="light"] .recommended-item-info span {
            color: #666;
        }

        [data-theme="light"] .start-menu-footer {
            background: rgba(0, 0, 0, 0.03);
        }

        [data-theme="light"] .power-button:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        /* 視窗 */
        [data-theme="light"] .window {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }

        [data-theme="light"] .window.active {
            border-color: rgba(0, 160, 200, 0.5);
        }

        [data-theme="light"] .window-header {
            background: rgba(250, 250, 252, 0.95);
        }

        [data-theme="light"] .window-title {
            color: #1a1a1a;
        }

        [data-theme="light"] .window-control-btn {
            color: #333;
        }

        [data-theme="light"] .window-control-btn:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        [data-theme="light"] .window-content {
            color: #1a1a1a;
        }

        [data-theme="light"] .snap-layouts {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.12);
        }

        [data-theme="light"] .snap-layout-option {
            border-color: #888;
            background: rgba(0, 0, 0, 0.04);
        }

        [data-theme="light"] .snap-layout-option:hover {
            border-color: var(--primary-cyan);
            background: rgba(0, 160, 200, 0.15);
        }

        /* 設定視窗 */
        [data-theme="light"] .settings-sidebar {
            border-right: 1px solid rgba(0, 0, 0, 0.08);
        }

        [data-theme="light"] .settings-menu-item {
            color: #333;
        }

        [data-theme="light"] .settings-menu-item:hover {
            background: rgba(0, 0, 0, 0.04);
        }

        [data-theme="light"] .settings-menu-item.active {
            background: rgba(0, 160, 200, 0.1);
        }

        [data-theme="light"] .setting-section h3 {
            border-bottom: 1px solid rgba(0, 0, 0, 0.12);
        }

        [data-theme="light"] .setting-item {
            background: rgba(0, 0, 0, 0.02);
        }

        [data-theme="light"] .setting-item-label {
            color: #1a1a1a;
        }

        [data-theme="light"] .setting-item-label span {
            color: #666;
        }

        /* 檔案總管 */
        [data-theme="light"] .explorer-content {
            background: #fafafa;
        }

        [data-theme="light"] .explorer-sidebar {
            background: rgba(0, 0, 0, 0.02);
            border-right: 1px solid rgba(0, 0, 0, 0.08);
        }

        [data-theme="light"] .explorer-sidebar h4 {
            color: #555;
        }

        [data-theme="light"] .explorer-item {
            color: #333;
        }

        [data-theme="light"] .explorer-item:hover {
            background: rgba(0, 0, 0, 0.04);
        }

        [data-theme="light"] .explorer-item i {
            color: #555;
        }

        [data-theme="light"] .folder-icon span {
            color: #1a1a1a;
        }

        /* 瀏覽器 */
        [data-theme="light"] .browser-toolbar {
            background: rgba(0, 0, 0, 0.03);
        }

        [data-theme="light"] .browser-toolbar input {
            background: rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }

        [data-theme="light"] .browser-toolbar i {
            color: #555;
        }

        [data-theme="light"] .favorites-bar {
            background: rgba(0, 0, 0, 0.02);
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] .fav-item {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.06);
            color: #333;
        }

        [data-theme="light"] .fav-item:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] .fav-item .title {
            color: #1a1a1a;
        }

        [data-theme="light"] #win-edge > .tool > input.url {
            background: rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }

        [data-theme="light"] #win-edge > .tool > .a {
            color: #333;
        }

        [data-theme="light"] #win-edge > .tool > .a:hover {
            background-color: rgba(0, 0, 0, 0.06);
        }

        /* 日曆彈窗 */
        [data-theme="light"] #calendar-flyout {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }

        [data-theme="light"] .calendar-header span {
            color: #1a1a1a;
        }

        [data-theme="light"] .calendar-nav button {
            color: #333;
        }

        [data-theme="light"] .calendar-cell {
            color: #1a1a1a;
        }

        [data-theme="light"] .calendar-cell.day-name {
            color: #666;
        }

        [data-theme="light"] .calendar-cell.other-month {
            color: #aaa;
        }

        [data-theme="light"] .calendar-cell.today {
            background: var(--primary-cyan);
            color: #fff;
        }

        [data-theme="light"] .calendar-cell:not(.day-name):not(.today):hover {
            background: rgba(0, 0, 0, 0.06);
        }

        /* 小工具面板 */
        [data-theme="light"] #widgets-panel {
            background: rgba(255, 255, 255, 0.95);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.1);
        }

        [data-theme="light"] .widget {
            background: rgba(0, 0, 0, 0.03);
        }

        [data-theme="light"] .widget-header {
            color: #1a1a1a;
        }

        [data-theme="light"] .weather-controls input[type="text"] {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }

        [data-theme="light"] .weather-controls button {
            color: #333;
        }

        [data-theme="light"] .weather-info .desc {
            color: #555;
        }

        [data-theme="light"] .weather-info .meta {
            color: #666;
        }

        [data-theme="light"] .weather-forecast .forecast-item {
            background: rgba(0, 0, 0, 0.03);
        }

        [data-theme="light"] .weather-forecast .forecast-item .date {
            color: #666;
        }

        [data-theme="light"] .news-item-info {
            color: #1a1a1a;
        }

        [data-theme="light"] .news-item-info span {
            color: #666;
        }

        /* 右鍵選單 */
        [data-theme="light"] #context-menu {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.12);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
        }

        [data-theme="light"] .context-menu-item {
            color: #1a1a1a;
        }

        [data-theme="light"] .context-menu-item:hover {
            background: rgba(0, 160, 200, 0.12);
        }

        [data-theme="light"] .context-menu-item i {
            color: #555;
        }

        [data-theme="light"] .context-menu-separator {
            background: rgba(0, 0, 0, 0.1);
        }

        [data-theme="light"] #start-context-menu {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.12);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
        }

        /* 對話/聊天區域 */
        [data-theme="light"] .nagato-messages {
            background: rgba(0, 0, 0, 0.02);
        }

        [data-theme="light"] .message.ai {
            background: rgba(0, 0, 0, 0.05);
            color: #1a1a1a;
        }

        [data-theme="light"] .message.user {
            background: var(--primary-cyan);
            color: #fff;
        }

        [data-theme="light"] .message-suggestions .suggestion-btn {
            background: rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        [data-theme="light"] .message-suggestions .suggestion-btn:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        [data-theme="light"] .nagato-input-area {
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        [data-theme="light"] .nagato-input-area textarea {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.15);
            color: #1a1a1a;
        }

        [data-theme="light"] .nagato-input-area .clear-btn {
            color: #555;
        }

        [data-theme="light"] .nagato-input-area .clear-btn:hover {
            background: rgba(0, 0, 0, 0.06);
            color: #1a1a1a;
        }

        /* 計算機 */
        [data-theme="light"] #win-calc {
            background: #fafafa;
        }

        [data-theme="light"] #calc-input {
            color: #1a1a1a;
        }

        [data-theme="light"] #win-calc > .keyb > .b {
            background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.04));
            border: 1px solid rgba(0, 0, 0, 0.08);
            color: #1a1a1a;
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
        }

        [data-theme="light"] #win-calc > .keyb > .b:hover {
            box-shadow: 0 6px 12px rgba(0,0,0,0.12);
        }

        [data-theme="light"] #win-calc > .keyb > .b.u {
            background: linear-gradient(180deg, rgba(0,160,200,0.08), rgba(0,160,200,0.04));
        }

        /* 桌面圖示 - 只調整 hover 背景和文字陰影，圖示顏色保持與開始菜單一致 */
        [data-theme="light"] .desktop-icon:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        [data-theme="light"] .desktop-icon span {
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        /* 滾動條 */
        [data-theme="light"] ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        [data-theme="light"] ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.03);
        }

        [data-theme="light"] ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
        }

        [data-theme="light"] ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        /* 關於頁面 */
        [data-theme="light"] .about-item {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] .about-item-row {
            color: #555;
        }

        [data-theme="light"] .btn {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }

        [data-theme="light"] .btn:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        /* 更新頁面 */
        [data-theme="light"] .update-item {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        /* Snap 預覽 */
        [data-theme="light"] #snap-preview {
            background: rgba(0, 160, 200, 0.1);
            border: 2px dashed rgba(0, 160, 200, 0.4);
        }

        /* 使用者頭像 */
        [data-theme="light"] .user-profile img.avatar {
            border: 2px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        /* 切換開關 */
        [data-theme="light"] .toggle-switch {
            background: rgba(0, 0, 0, 0.15);
        }

        [data-theme="light"] .toggle-switch.active {
            background: var(--primary-cyan);
        }

        /* 選擇控制項 */
        [data-theme="light"] .select-control select {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.12);
            color: #1a1a1a;
        }

        /* 滑桿控制項 */
        [data-theme="light"] .slider-range {
            background: rgba(0, 0, 0, 0.1);
        }

        [data-theme="light"] .slider-value {
            color: #1a1a1a;
        }

        [data-theme="light"] .slider-marks span {
            color: #666;
        }

        /* 輸入框 */
        [data-theme="light"] input[type="color"] {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.12);
        }

        [data-theme="light"] input[type="text"],
        [data-theme="light"] input[type="url"],
        [data-theme="light"] input[type="number"] {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.12);
            color: #1a1a1a;
        }

        /* 設定面板 (主頁面側邊設定) */
        [data-theme="light"] .settings-panel {
            background: rgba(255, 255, 255, 0.95);
            border-left: 1px solid rgba(0, 0, 0, 0.1);
        }

        [data-theme="light"] .settings-panel h2 {
            color: #1a1a1a;
        }

        [data-theme="light"] .settings-section {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        [data-theme="light"] .settings-section-title {
            color: #1a1a1a;
        }

        [data-theme="light"] .setting-label span:first-child {
            color: #1a1a1a;
        }

        [data-theme="light"] .setting-description {
            color: #666;
        }

        /* FPS 監控 */
        [data-theme="light"] .fps-display {
            color: #1a1a1a;
        }

        /* 頁眉 */
        [data-theme="light"] header {
            background: rgba(255, 255, 255, 0.9);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        [data-theme="light"] header a {
            color: var(--primary-cyan);
        }

        [data-theme="light"] .nav-links a {
            color: #333;
        }

        [data-theme="light"] .nav-links a:hover {
            color: var(--primary-cyan);
        }

        /* ========== 淺色模式結束 ========== */

        #start-button {
            font-size: 1.5rem;
            color: var(--primary-cyan);
            /* keep start button visually slightly larger but with consistent vertical sizing */
            padding: 0 8px;
            min-width: calc(var(--taskbar-icon-size) + 20px);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        /* Ensure the time widget fits exactly inside the taskbar and never stretches it.
           Use flexbox to vertically center the two lines (time/date) and limit height.
           Keep fonts/spacing unchanged to avoid altering displayed text sizes. */
        #taskbar-time {
            display: inline-flex;           /* make this a flex column so we can center vertically */
            flex-direction: column;         /* time above date */
            justify-content: center;        /* vertically center within taskbar */
            align-items: flex-end;          /* align text to the right */
            height: 100%;                   /* match parent taskbar height */
            max-height: 100%;
            box-sizing: border-box;         /* ensure padding included in height */
            font-family: var(--font-body);
            font-size: 0.9rem;
            text-align: right;
            padding: 0 10px;
            color: #e0e0e0;
            cursor: pointer;
            line-height: 1;                 /* avoid extra added height from default line height */
            overflow: hidden;               /* prevent overflowing elements from stretching it */
        }
        #taskbar-time:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Make sure the inner time/date elements do not have margins that increase height */
        #taskbar-time > div {
            margin: 0;
            padding: 0;
            line-height: 1;
            display: block;
            white-space: nowrap;
        }
        /* Keep AM/PM label same size as numbers and add spacing between them */
        #taskbar-time .ampm {
            margin-right: 3px; /* reduced spacing between AM/PM label and digits */
            /* Make the AM/PM label visually smaller than the numeric time
               while keeping good readability and alignment. Using em so
               it scales with the current font-size. */
            font-size: 0.8em;
            opacity: 0.95;
            line-height: 1; /* keep centered with the digits */
            display: inline-block;
            vertical-align: middle; /* align with digits */
            letter-spacing: 0.01em; /* keep label legible */
        }
        #taskbar-time .time-value {
            font-family: var(--font-body);
            font-size: inherit; /* preserve parent's font size */
            display: inline-block;
        }

        /* 4. 開始功能表 */
        #start-menu {
            position: absolute; /* 修改 */
            bottom: var(--taskbar-height);
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90vw;
            height: 500px;
            
            background: var(--mica-bg);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            
            border-radius: var(--window-border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            
            display: flex;
            flex-direction: column;
            overflow: hidden;
            
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(20px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: var(--z-start-menu);
        }
        #start-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .start-menu-header { padding: 15px 25px; }
        .search-bar { display: flex; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px; padding: 8px 15px; }
        .search-bar i { margin-right: 10px; color: #aaa; }
        .search-bar input { flex: 1; background: none; border: none; outline: none; color: #fff; font-family: var(--font-ui); font-size: 0.9rem; }
        .start-menu-body { flex: 1; padding: 10px 25px; overflow-y: auto; }
        .start-section-title { font-size: 0.9rem; font-weight: 500; color: #bbb; margin: 10px 0; }
        .pinned-apps { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 15px; }
        .app-icon { display: flex; flex-direction: column; align-items: center; padding: 10px 5px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; }
        .app-icon:hover { background: rgba(255, 255, 255, 0.1); }
        .app-icon i { font-size: 1.8rem; margin-bottom: 8px; }
        .app-icon span { font-size: 0.8rem; }
        .icon-settings { color: #9a9a9a; }
        .icon-nagato { color: var(--accent-pink); }
        /* Image-based app icons */
        .app-icon-img { width: 28px; height: 28px; object-fit: cover; border-radius: 6px; }
        .desktop-icon .app-icon-img { width: 56px; height: 56px; }
        .pinned-apps .app-icon .app-icon-img { width: 36px; height: 36px; }
        #taskbar .taskbar-icon .app-icon-img { width: var(--taskbar-icon-size); height: var(--taskbar-icon-size); }
        .window-title .app-icon-img { width: 18px; height: 18px; margin-right: 8px; }
        .icon-explorer { color: #f7d45f; }
        .icon-edge { color: #0078d7; }
        .icon-store { color: #00a4ef; }
        .recommended-list { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .recommended-item { display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; }
        .recommended-item:hover { background: rgba(255, 255, 255, 0.1); }
        .recommended-item i { font-size: 1.2rem; margin-right: 10px; color: #ccc; }
        .recommended-item-info { font-size: 0.85rem; }
        .recommended-item-info span { display: block; color: #aaa; font-size: 0.75rem; }
        .start-menu-footer { padding: 15px 25px; background: rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; }
        .user-profile { display: flex; align-items: center; cursor: pointer; }
        .user-profile i { font-size: 1.5rem; margin-right: 10px; background: var(--accent-purple); padding: 5px; border-radius: 50%; }
        /* Avatar image styles */
        .user-profile img.avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
            background-color: rgba(255, 255, 255, 0.03);
        }
        .power-button { font-size: 1.2rem; padding: 5px; cursor: pointer; border-radius: 4px; }
        .power-button:hover { background: rgba(255, 255, 255, 0.1); }


        /* 5. 視窗系統 */
        .window {
            position: absolute;
            width: 700px;
            height: 500px;
            min-width: 300px;
            min-height: 200px;
            
            background: rgba(25, 25, 40, 0.8);
            border-radius: var(--window-border-radius);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            
            display: flex;
            flex-direction: column;
            overflow: hidden;
            
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
        }
        .window.show { opacity: 1; visibility: visible; transform: scale(1); }
        /* Ensure active window stacks above other windows (calc for correct value) */
        .window.active { z-index: var(--z-window-active) !important; border-color: rgba(0, 212, 255, 0.5); }
        .window.minimized { display: none; }

        .window-header {
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px 0 15px;
            cursor: move;
            
            background: var(--mica-bg-light);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            flex-shrink: 0;
            /* Ensure the header (and its overlays like .snap-layouts) sits above window content (iframes/inputs) */
            position: relative;
            z-index: calc(var(--z-window) + 20);
        }
        .window-title { font-family: var(--font-body); font-weight: 500; font-size: 0.9rem; display: flex; align-items: center; }
        .window-title i { margin-right: 8px; font-size: 0.9rem; }

        .window-controls { display: flex; height: 100%; }
        .window-control-btn { width: 40px; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; cursor: pointer; transition: background-color 0.2s ease; position: relative; }
        .window-control-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .window-control-btn.close:hover { background: #e81123; }
        .snap-layouts { position: absolute; top: calc(100% - 2px); right: 0; width: 130px; background: var(--mica-bg-dark); backdrop-filter: blur(var(--mica-blur)); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 6px; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; z-index: calc(var(--z-context-menu) + 2); pointer-events: auto; will-change: opacity; }
        /* Keep snap-layouts visible when the maximize button or the overlay itself is hovered/focused */
        .window-control-btn.maximize:hover .snap-layouts,
        .window-control-btn.maximize:focus-within .snap-layouts,
        .window-control-btn.maximize .snap-layouts:hover { opacity: 1; visibility: visible; }
        .snap-layout-option { height: 30px; border: 2px solid #888; border-radius: 4px; background: rgba(255, 255, 255, 0.1); cursor: pointer; pointer-events: auto; z-index: calc(var(--z-context-menu) + 3); }
        .snap-layout-option:hover { border-color: var(--primary-cyan); background: rgba(0, 212, 255, 0.2); }

        /* Snap preview overlay used when dragging windows near edges */
        #snap-preview {
            position: absolute;
            z-index: var(--z-snap-preview); /* above windows but below start-menu overlays */
            background: rgba(0, 212, 255, 0.12);
            border: 2px dashed rgba(0, 212, 255, 0.35);
            border-radius: var(--window-border-radius);
            pointer-events: none;
            transition: opacity 0.12s ease, transform 0.12s ease;
            opacity: 0;
            visibility: hidden;
        }
        #snap-preview.show { opacity: 1; visibility: visible; }

        .window-content { flex: 1; padding: 15px; overflow: auto; font-family: var(--font-ui); font-size: 0.95rem; line-height: 1.6; }
        

          .resize-handle { position: absolute; background: transparent; z-index: calc(var(--z-window) + 30); pointer-events: auto; }
        .resize-handle.n { top: 0; left: 5px; right: 5px; height: 5px; cursor: n-resize; }
        .resize-handle.s { bottom: 0; left: 5px; right: 5px; height: 5px; cursor: s-resize; }
        .resize-handle.e { top: 5px; bottom: 5px; right: 0; width: 5px; cursor: e-resize; }
        .resize-handle.w { top: 5px; bottom: 5px; left: 0; width: 5px; cursor: w-resize; }
        .resize-handle.nw { top: 0; left: 0; width: 5px; height: 5px; cursor: nw-resize; }
        .resize-handle.ne { top: 0; right: 0; width: 5px; height: 5px; cursor: ne-resize; }
        .resize-handle.sw { bottom: 0; left: 0; width: 5px; height: 5px; cursor: sw-resize; }
        .resize-handle.se { bottom: 0; right: 0; width: 5px; height: 5px; cursor: se-resize; }


        /* 6. 應用程式內容 */
        .settings-content { display: flex; height: 100%; }
        /* 設定視窗主滾動條箭頭 - 只顯示單一按鈕 */
        #window-settings .window-content::-webkit-scrollbar-button:vertical:start:increment,
        #window-settings .window-content::-webkit-scrollbar-button:vertical:end:decrement,
        #window-settings .settings-main::-webkit-scrollbar-button:vertical:start:increment,
        #window-settings .settings-main::-webkit-scrollbar-button:vertical:end:decrement {
            display: none;
        }
        .settings-sidebar { width: 200px; flex-shrink: 0; border-right: 1px solid rgba(255, 255, 255, 0.1); padding: 10px 0; }
        .settings-menu-item { display: flex; align-items: center; padding: 12px 20px; cursor: pointer; font-size: 0.9rem; }
        .settings-menu-item:hover { background: rgba(255, 255, 255, 0.05); }
        .settings-menu-item.active { background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--primary-cyan); padding-left: 17px; }
        .settings-menu-item i { margin-right: 15px; width: 20px; text-align: center; }
        .settings-page { display: none; }
        .settings-page.active { display: block; }
        .settings-subpage { display: none; }
        .settings-subpage.active { display: block; }
        .settings-main { width: 100%; }
        .settings-main { flex: 1; padding: 20px; overflow-y: auto; }
        .setting-section { margin-bottom: 30px; }
        .setting-section h3 { font-family: var(--font-body); font-size: 1.5rem; color: var(--primary-cyan); border-bottom: 1px solid rgba(255, 255, 255, 0.2); padding-bottom: 10px; margin-bottom: 15px; }
        .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: rgba(0, 0, 0, 0.1); border-radius: 4px; }
        .setting-item-label { font-size: 0.9rem; }
        .setting-item-label span { display: block; font-size: 0.8rem; color: #aaa; }
        .nagato-content { display: flex; flex-direction: column; height: 100%; padding: 0; }
        .nagato-messages { flex: 1; padding: 15px; overflow-y: auto; background: rgba(0, 0, 0, 0.1); }
        .message { margin-bottom: 15px; padding: 10px 15px; border-radius: 10px; max-width: 80%; line-height: 1.5; }
        .message.user { background: var(--primary-cyan); color: #000; align-self: flex-end; margin-left: auto; border-bottom-right-radius: 2px; }
        .message.ai { background: rgba(255, 255, 255, 0.1); color: #f0f0f0; align-self: flex-start; border-bottom-left-radius: 2px; }
        .message-suggestions { margin-top: 8px; display: flex; gap: 6px; }
        .message-suggestions .suggestion-btn { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.04); color: #f0f0f0; padding: 6px 8px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; }
        .message-suggestions .suggestion-btn:hover { background: rgba(255,255,255,0.08); }
        .nagato-input-area { display: flex; padding: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .nagato-input-area textarea { flex: 1; padding: 10px; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; outline: none; color: #fff; font-family: var(--font-ui); resize: none; }
        .nagato-input-area button { background: var(--accent-pink); border: none; color: #000; padding: 0 15px; margin-left: 10px; border-radius: 4px; cursor: pointer; font-size: 1.1rem; }
        .nagato-input-area .clear-btn { background: transparent; border: none; color: #f0f0f0; padding: 0 10px; margin-left: 8px; border-radius: 6px; cursor: pointer; font-size: 1rem; height: 36px; align-self: center; }
        .nagato-input-area .clear-btn:hover { background: rgba(255,255,255,0.04); color: #fff; }
        .message.ai.typing { opacity: 0.9; }
        .typing-dots { display: inline-block; width: 36px; text-align: left; }
        .typing-dots span { display: inline-block; width: 6px; height: 6px; background: rgba(255,255,255,0.3); border-radius: 50%; margin: 0 2px; animation: dots 1.2s infinite; }
        .typing-dots span:nth-child(2) { animation-delay: 0.15s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.30s; }
        @keyframes dots { 0% { transform: translateY(0);} 50% { transform: translateY(-4px);} 100% { transform: translateY(0);} }
        .explorer-content { display: flex; height: 100%; padding: 0; background: #1e1e1e; }
        .explorer-sidebar { width: 220px; flex-shrink: 0; background: rgba(0, 0, 0, 0.1); padding: 10px; border-right: 1px solid rgba(255, 255, 255, 0.1); }
        .explorer-sidebar h4 { font-size: 0.9rem; color: #aaa; margin: 15px 0 5px 5px; }
        .explorer-item { display: flex; align-items: center; padding: 8px 10px; font-size: 0.9rem; border-radius: 4px; cursor: pointer; }
        .explorer-item:hover { background: rgba(255, 255, 255, 0.05); }
        .explorer-item i { margin-right: 10px; color: #ccc; }

        .explorer-main { flex: 1; padding: 15px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 20px; align-content: start; }
        /* 檔案總管滾動條箭頭 - 只顯示單一按鈕 */
        .explorer-main::-webkit-scrollbar-button:vertical:start:increment,
        .explorer-main::-webkit-scrollbar-button:vertical:end:decrement {
            display: none;
        }
        .folder-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
        .folder-icon i { font-size: 3rem; color: #f7d45f; margin-bottom: 5px; }
        .folder-icon span { font-size: 0.85rem; }
        .browser-content { padding: 0; overflow: hidden; display: flex; flex-direction: column; }
        /* Browser toolbar: slightly more compact to reduce vertical spacing to favorites bar below */
        /* Compact browser toolbar - reduce bottom margin to tighten spacing to favorites bar */
        .browser-toolbar { display: flex; align-items: center; padding: 6px 8px; background: rgba(0, 0, 0, 0.2); margin-bottom: 0; }
        .browser-toolbar input { flex: 1; padding: 5px 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; color: #fff; margin: 0 8px; font-size: 0.9rem; }
        .browser-toolbar i { padding: 5px; cursor: pointer; color: #ccc; }
        .browser-toolbar i.disabled { opacity: 0.35; cursor: not-allowed; }
        #bookmark-toggle { display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 8px; }
        #bookmark-toggle i.fa-solid { color: var(--primary-cyan); }
        /* Favorites bar (bookmarks) */
        /* Compact favorites bar - reduced height while keeping scroll capability; hide scrollbar visually */
        /* Compact favorites bar - smaller height and padding for tighter layout under the toolbar */
        /* Compact favorites bar - smaller padding and height for tighter layout under the toolbar */
        .favorites-bar { display: flex; gap: 6px; padding: 2px 8px; overflow-x: auto; align-items: center; height: 34px; background: rgba(0,0,0,0.08); border-bottom: 1px solid rgba(255,255,255,0.04); -ms-overflow-style: none; scrollbar-width: none; margin-top: 0; }
        .favorites-bar::-webkit-scrollbar { display: none; }
        .fav-item { display: inline-flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.02); color: #ddd; cursor: pointer; transition: background-color 0.15s ease; white-space: nowrap; border: 1px solid rgba(255,255,255,0.02); font-size: 0.9rem; }
        .fav-item:hover { background: rgba(255,255,255,0.06); }
        .fav-item i { font-size: 1rem; }
        .fav-item .title { font-size: 0.85rem; color: #f3f3f3; }
        /* Small favicon placeholder to the left of each fav item */
        .fav-item .favicon { width: 16px; height: 16px; display: inline-block; border-radius: 4px; object-fit: cover; background: rgba(255,255,255,0.04); }
        #win-edge { display: flex; flex-direction: column; height: 100%; }
        /* Edge-like toolbar: reduce padding and gap to make it more compact */
        /* Edge-like toolbar: reduce padding and gap to make it more compact */
        #win-edge > .tool { display: flex; gap: 6px; padding: 4px 6px; align-items: center; position: relative; z-index: 2; margin-bottom: 0; }
        #win-edge > .tool > .a { display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 6px; color: var(--text); cursor: pointer; transition: 50ms; background: transparent; text-decoration: none; }
        #win-edge > .tool > .a:hover { background-color: rgba(255,255,255,0.04); }
        #win-edge > .tool > .a.disabled { opacity: 0.25; pointer-events: none; }
        #win-edge > .tool > input.url { flex-grow: 1; background: rgba(255,255,255,0.03); padding: 6px 12px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.06); color: #fff; }
        /* Show/hide iframe depending on class 'show' to replicate edge.css pattern */
        #win-edge > iframe { width: calc(100% - 4px); flex-grow: 1; margin: 2px; border-radius: 10px; display: none; background: #ffffff; }
        #win-edge > iframe.show { display: block; }
        .browser-iframe { flex: 1; border: none; background: #fff; }
        .store-content { text-align: center; padding-top: 50px; }
        .store-content i { font-size: 4rem; color: var(--accent-purple); margin-bottom: 20px; }


        /* 7. 日曆彈窗 */
        #calendar-flyout {
            position: absolute; /* 修改 */
            bottom: var(--taskbar-height);
            right: 0;
            width: 320px;
            background: var(--mica-bg);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border-radius: var(--window-border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            padding: 15px;
            
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: var(--z-widgets);
        }
        #calendar-flyout.show { opacity: 1; visibility: visible; transform: translateY(0); }
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .calendar-header span { font-family: var(--font-body); font-size: 1.1rem; font-weight: 500; }
        .calendar-nav button { background: none; border: none; color: #f0f0f0; font-size: 1.2rem; cursor: pointer; padding: 5px; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-cell { text-align: center; padding: 8px; font-size: 0.85rem; border-radius: 50%; cursor: pointer; }
        .calendar-cell.day-name { font-weight: 600; color: #aaa; font-size: 0.75rem; cursor: default; }
        .calendar-cell.other-month { color: #666; }
        .calendar-cell.today { background: var(--primary-cyan); color: #000; font-weight: 700; }
        .calendar-cell:not(.day-name):not(.today):hover { background: rgba(255, 255, 255, 0.1); }


        /* 8. 小工具面板 (Widgets) */
        #widgets-panel {
            position: absolute; /* 修改 */
            top: 0;
            left: 0;
            width: 360px;
            height: 100%;
            
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.3);
            
            z-index: var(--z-widgets);
            padding: 20px;
            padding-top: 50px;
            overflow-y: auto;
            
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #widgets-panel.show { transform: translateX(0); }
        .widget { background: var(--mica-bg-light); border-radius: var(--window-border-radius); padding: 15px; margin-bottom: 20px; }
        .widget-header { font-family: var(--font-body); font-size: 1.1rem; font-weight: 500; margin-bottom: 10px; }
        .weather-widget { display: block; align-items: center; }
        .weather-controls { display:flex; gap:8px; margin-bottom:10px; }
        .weather-controls input[type="text"]{ flex:1; padding:8px 10px; border-radius:8px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); color: #fff; outline:none; }
        .weather-controls button{ background:transparent; border:none; color:var(--text); padding:6px 8px; border-radius:8px; cursor:pointer; }
        .weather-controls button[disabled]{ opacity: 0.6; cursor:not-allowed; }
        .weather-main{ display:flex; align-items:center; gap:12px; }
        .weather-visual #weather-icon { font-size: 3.2rem; color: var(--primary-yellow); }
        .weather-visual img{ width:56px; height:56px; object-fit:cover; border-radius:6px; }
        .weather-info .temp { font-size: 2rem; font-weight: 700; }
        .weather-info .desc { font-size: 0.9rem; color: #ccc; }
        .weather-info .meta { font-size: 0.8rem; color: #aaa; margin-top:4px; }
        .weather-forecast { display:flex; gap:8px; margin-top:12px; align-items:center; overflow-x:auto; }
        .weather-forecast .forecast-item { background: rgba(255,255,255,0.02); padding:8px; border-radius:6px; min-width:90px; text-align:center; }
        .weather-forecast .forecast-item .date{ font-size:0.8rem; color:#aaa; }
        .weather-forecast .forecast-item .temp{ font-weight:700; }
        .weather-info .temp { font-size: 2rem; font-weight: 700; }
        .weather-info .desc { font-size: 0.9rem; color: #ccc; }
        .news-item { display: flex; margin-bottom: 15px; }
        .news-item img { width: 60px; height: 60px; object-fit: cover; border-radius: 4px; margin-right: 10px; }
        .news-item-info { font-size: 0.85rem; }
        .news-item-info span { font-size: 0.75rem; color: #aaa; }

        /* ------------------------------------------------------------------ */
        /* Calc: Ensure calculator window does not show scrollbars when sized */
        /* - Use flexbox to let inner #win-calc fill the window-content area
           - Prevent min-height from causing overflow in flex children
           - Prevent inner scroll via overflow:hidden on the window content */
        /* ------------------------------------------------------------------ */
        #window-calculator .window-content {
            overflow: hidden;         /* prevent scrollbars */
            -ms-overflow-style: none; /* IE/Edge */
            scrollbar-width: none;    /* Firefox */
            display: flex;            /* create a flex container so children can scale */
            flex-direction: column;   /* stack input above keypad */
            padding: 10px;            /* slightly smaller padding for tighter fit */
        }

        /* Hide scrollbar on webkit-based browsers as extra precaution */
        #window-calculator .window-content::-webkit-scrollbar { display: none; }

        /* Make the win-calc element stretch to available height and be allowed to shrink */
        #window-calculator #win-calc {
            flex: 1 1 auto; /* grow and shrink to available space */
            min-height: 0;  /* allow shrinking inside flex container */
            display: flex;
            flex-direction: column;
        }

        /* Let keypad rows stretch proportionally so they always fit inside the
           window without forcing a scrollbar while keeping the buttons usable */
        #window-calculator #win-calc>.keyb {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, minmax(48px, 1fr)); /* use fractional rows to scale but keep minimum */
            gap: 6px;
        }

        /* Override fixed widths coming from calc.css to ensure responsive layout */
        #window-calculator #win-calc>.keyb>span { width: auto; margin: 0; height: auto; }

        /* Keep input area stable while allowing it to reduce when space is needed */
        #window-calculator #win-calc>.container {
            height: 90px;
            flex: 0 0 auto;
            display: flex;
            align-items: center;
        }

        /* Calc input tweaks */
        #window-calculator #calc-input {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: clamp(20px, 3.5vw, 35px);
            padding-right: 8px;
        }

        /* Ensure the calculator window can't be resized smaller than default size
           so the keypad never gets folded or clipped vertically. Also ensure the 
           minimum width is not larger than the default width (default inline width is 340px). */
        #window-calculator {
            min-height: 430px; /* match default window height so buttons won't be clipped */
            min-width: 320px;  /* smaller or equal to default width (340px) */
            width: 340px; /* set default width as desired; inline style already sets this */
        }

        /* Improve button look & feel for a tactile impression */
        #window-calculator #win-calc>.keyb>.b {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: auto; /* allow grid to control the height */
            min-height: 48px; /* keep buttons comfortably tappable */
            font-size: 1.05rem;
            padding: 0 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));
            box-shadow: 0 6px 12px rgba(0,0,0,0.35), inset 0 -2px 0 rgba(255,255,255,0.02);
            cursor: pointer;
            transition: transform 60ms ease, box-shadow 60ms ease, background 60ms ease;
            box-sizing: border-box; /* prevent padding from causing overflow */
            white-space: nowrap; /* prevent label wrapping */
            overflow: hidden; /* ensure text doesn't wrap and will be ellipsed */
            text-overflow: ellipsis;
        }
        #window-calculator #win-calc>.keyb>.b:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 18px rgba(0,0,0,0.42), inset 0 -2px 0 rgba(255,255,255,0.02);
        }
        #window-calculator #win-calc>.keyb>.b:active {
            transform: translateY(0);
            box-shadow: 0 3px 8px rgba(0,0,0,0.25), inset 0 -1px 0 rgba(255,255,255,0.01);
        }
        #window-calculator #win-calc>.keyb>.b:focus { outline: none; box-shadow: 0 0 0 3px rgba(0,212,255,0.12); }
        #window-calculator #win-calc>.keyb>.b { user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }

        /* Make special function keys visually distinct */
        #window-calculator #win-calc>.keyb>.b.u { background: linear-gradient(180deg, rgba(0,212,255,0.06), rgba(0,212,255,0.02)); }
        #window-calculator #win-calc>.keyb>.b.ans { background-image: linear-gradient(120deg, var(--theme-1), var(--theme-2)); color: #fff; border: none; }


        /* 9. 右鍵選單 */
        #context-menu {
            position: absolute; /* 修改 */
            width: 200px;
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.1s ease, transform 0.1s ease;
            z-index: var(--z-context-menu);
        }
        #context-menu.show { opacity: 1; visibility: visible; transform: scale(1); }
        .context-menu-item { display: flex; align-items: center; padding: 8px 12px; font-size: 0.9rem; border-radius: 4px; cursor: pointer; }
        .context-menu-item:hover { background: rgba(0, 212, 255, 0.2); }
        .context-menu-item i { width: 25px; text-align: center; margin-right: 8px; font-size: 0.9rem; }
        .context-menu-separator { height: 1px; background: rgba(255, 255, 255, 0.1); margin: 5px 0; }

        /* Start-menu-specific context menu */
        #start-context-menu {
            position: absolute;
            width: 220px;
            background: var(--mica-bg-dark);
            backdrop-filter: blur(var(--mica-blur)) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.1s ease, transform 0.1s ease, visibility 0.1s ease;
            z-index: var(--z-context-menu); /* higher than start menu */
            pointer-events: auto;
        }
        #start-context-menu.show { opacity: 1; visibility: visible; transform: scale(1); }


        /* --- Personalization styles (taskbar, fonts, background preview) --- */
        :root { --font-scale: 1; }
        html { font-size: calc(16px * var(--font-scale)); }
        /* Taskbar positions */
        #taskbar.center { justify-content: center; }
        #taskbar.left { justify-content: flex-start; }
        #taskbar.right { justify-content: flex-end; }
        /* Autohide (hidden state) */
        .taskbar-autohide { transition: transform 0.18s ease; }
        .taskbar-autohide.taskbar-hidden { transform: translateY(100%); }
        /* Accent color preview (used by a small swatch if needed) */
        .accent-swatch { width: 18px; height: 18px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.06); display:inline-block; }
        /* Thumbnail styling for background images */
        .bg-thumb { box-sizing: border-box; overflow: hidden; width: 160px; height: 90px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.06); cursor: pointer; }
        .bg-thumb:hover { outline: 2px solid rgba(255,255,255,0.06); transform: scale(1.02); transition: transform 120ms ease, outline 120ms ease; }
        /* Small preview video inside bgPreview */
        #personalization_bgPreview { position: relative; overflow: hidden; }
        #personalization_bgPreview video.bg-preview-video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 6px; display: block; }
        /* Ensure favorites/toolbar scale with font scale variable where needed */
        .settings-panel, .window, .start-menu, .taskbar, .desktop-icon { font-size: inherit; }
        /* About page styles */
        .about-header { display:flex; flex-direction:column; gap:10px; }
        /* Place the header logo to the right of text on wider screens. Stack vertically on small screens. */
        .about-header .about-logo { width:56px; height:56px; border-radius:8px; object-fit:cover; margin-left: 12px; flex: 0 0 auto; }
        @media (max-width: 640px) {
            .about-header > div { display:flex; flex-direction:column; gap:8px; align-items:flex-start; }
            .about-header .about-logo { margin-left: 0; margin-top: 8px; align-self: flex-start; }
        }
        .about-grid { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 10px; }
        .about-item { background: var(--card); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.04); }
        .about-item h4 { margin: 0 0 8px 0; color: var(--primary-cyan); font-family: var(--font-body); }
        .about-item-row { color: #ccc; margin: 4px 0; font-size: 0.9rem; }
        .about-actions { margin-top: 14px; display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
        .btn { padding: 8px 12px; border-radius: 8px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.04); color: #fff; cursor:pointer; }
        .btn:hover { background: rgba(255,255,255,0.04); }
        /* Update page styles */
        .update-item { background: var(--card); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.04); }
        .update-controls .btn { min-width: 120px; }
        #update-release-notes { white-space: pre-wrap; font-family: var(--font-ui); }
        /* Rectangular buttons for update actions (override global .btn parallelogram style) */
        .btn-rect, #update-check-btn, #update-open-release-btn {
            clip-path: none !important;
            border-radius: 8px !important;
            background: transparent !important;
            border: 2px solid rgba(0,212,255,0.12) !important;
            color: var(--primary-cyan) !important;
            text-transform: uppercase !important;
            font-family: var(--font-display) !important;
            font-weight: 600 !important;
            letter-spacing: 1px !important;
            padding: 8px 14px !important;
            box-shadow: 0 1px 4px rgba(0,0,0,0.45) !important;
            transition: all 160ms ease !important;
            min-width: 120px; /* keep button width inline with update controls */
        }
        .btn-rect::before, #update-check-btn::before, #update-open-release-btn::before { left: -100%; }
        .btn-rect:hover, #update-check-btn:hover, #update-open-release-btn:hover {
            background: linear-gradient(90deg, rgba(0,212,255,0.06), rgba(255,0,128,0.03)) !important;
            border-color: var(--primary-cyan) !important;
            color: #fff !important;
            box-shadow: 0 8px 28px rgba(0,212,255,0.12) !important;
            transform: translateY(-2px) !important;
        }
        .btn-rect:focus, #update-check-btn:focus, #update-open-release-btn:focus { outline: none; box-shadow: 0 0 0 4px rgba(0,212,255,0.08) !important; }
        .btn-rect:disabled, #update-open-release-btn:disabled { opacity: 0.55; cursor: not-allowed; transform: none !important; box-shadow: none !important; }
        /* --- 動畫 --- */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; color: var(--primary-cyan); }
            50% { opacity: 0.7; color: var(--accent-cyan); }
        }
        @keyframes shine {
            0% { border-color: #111; }
            49% { border-color: #111; }
            51% { border-color: transparent; }
            98% { border-color: transparent; }
            100% { border-color: #111; }
        }

        /* Core calc layout */
        #win-calc { display: flex; flex-direction: column; padding: 5px; }
        #calc-input { border: none; border-right: 2px solid transparent; outline: none; background-color: transparent; font-size: 35px; text-align: end; color: var(--text); width: 100%; }
        #win-calc > .container { height: 90px; display: flex; align-items: center; }
        #calc-input:focus { border-color: #111; animation-name: shine; animation-duration: 1s; animation-iteration-count: infinite; }

        /* Key grid + button appearance */
        #win-calc > .keyb { flex-grow: 1; display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(5, minmax(48px, 1fr)); gap: 6px; }
        #win-calc > .keyb > .b { height: auto; min-height: 48px; font-size: 1.05rem; text-align: center; transition: transform 60ms ease, box-shadow 60ms ease, background 60ms ease; border-radius: 8px; border: 1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03)); box-shadow: 0 6px 12px rgba(0,0,0,0.35), inset 0 -2px 0 rgba(255,255,255,0.02); padding: 0 8px; }
        #win-calc > .keyb > .b:hover { transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.42), inset 0 -2px 0 rgba(255,255,255,0.02); }
        #win-calc > .keyb > .b:active { transform: translateY(0); box-shadow: 0 3px 8px rgba(0,0,0,0.25), inset 0 -1px 0 rgba(255,255,255,0.01); }
        #win-calc > .keyb > .b.ans { background-image: linear-gradient(120deg, var(--theme-1), var(--theme-2)); color: #fff; border: none; }
        #win-calc > .keyb > .b.u { padding-top: 5px; }
        #win-calc > .keyb > .b.checked { background-color: var(--mm) !important; }
        #win-calc > .keyb > span { width: auto; margin: 0; height: auto; }

        /* Make keypad accessible: clickable and keyboard focusable */
        #win-calc .b { cursor: pointer; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body>

    <!-- 1. 頂部導航 (使用全域 Header) -->
    <header>
        <a href="../../index.html">
            <div style="margin-left: 30px; font-family: 'Orbitron', sans-serif;">『 AMANO SHIZUKI 』</div>
        </a>
        <div class="nav-container">
            <ul class="nav-links">
                <div class="nav-header">
                    <h2 class="nav-title">選單導航</h2>
                </div>
                
                <div class="search-box">
                    <input type="text" id="navSearch" class="search-input" placeholder="搜尋頁面...">
                    <button class="search-btn" aria-label="Search">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="nav-section">
                    <h3 class="nav-section-title">主要頁面</h3>
                    <li><a href="../../pages/about.html" class="active">◆ ABOUT</a></li>
                    <li><a href="../../pages/experience.html">◆ EXPERIENCE</a></li>
                    <li><a href="../../pages/skills.html">◆ SKILLS</a></li>
                    <li><a href="../../pages/contact.html">◆ CONTACT</a></li>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">特別內容</h3>
                    <li><a href="../game-center/game-center.html">◆ GAME CENTER</a></li>
                    <li><a href="nagato-sakura-webos.html" class="active">◆ WEB OS</a></li>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">更多連結</h3>
                    <li>
                        <a href="https://www.youtube.com/@Amano_Shizuki_Kun" target="_blank" rel="noopener noreferrer" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                            </svg>
                            YouTube
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/AmanoShizukikun" target="_blank" rel="noopener noreferrer" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                            GitHub
                        </a>
                    </li>
                    <li>
                        <a href="https://discord.gg/jac8eAFzjz" target="_blank" rel="noopener noreferrer" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028c.462-.63.874-1.295 1.226-1.994a.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/>
                            </svg>
                            Discord
                        </a>
                    </li>
                    <li>
                        <a href="mailto:3b017128@gm.student.ncut.edu.tw" class="social-link">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px; vertical-align: middle;">
                                <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                                <polyline points="22,6 12,13 2,6"></polyline>
                            </svg>
                            Email
                        </a>
                    </li>
                </div>
            </ul>
        </div>
        <div class="header-actions">
            <button class="settings-toggle" aria-label="Settings"></button>
            <button class="menu-toggle" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </header>

    <!-- 2. 主內容包裝器 (來自 win.html) -->
    <div class="main-wrapper">
        
        <!-- 3. 模擬器容器 (取代 main-content) -->
        <main class="simulator-container" id="simulator-container-main">
            <!-- Nightlight overlay: warm color overlay applied when nightlight enabled -->
            <div id="nightlight-overlay" aria-hidden="true"></div>
            <!-- Desktop background layer for independent wallpaper brightness & effects -->
            <div id="desktop-bg" aria-hidden="true"></div>
            <!-- Video background element (hidden until a video is set). autoplay muted to allow auto-play in most browsers -->
            <video id="desktop-video" aria-hidden="true" muted loop playsinline preload="metadata" style="display:none;"></video>
            <!-- Overlay used to dim background or apply extra overlay over both image & video backgrounds -->
            <div id="desktop-overlay" aria-hidden="true"></div>
            
            <!-- 模擬器內容 (來自 win_improved.html) -->

            <!-- 1. 啟動加載器 -->
            <div id="boot-loader">
                <img id="boot-logo" src="../../assets/images/logo.png" alt="Logo">
                <div id="boot-spinner"></div>
                <div id="boot-status">系統啟動中...</div>
            </div>

            <!-- start 的右鍵選單（開始設定） -->
            <div id="start-context-menu">
                <div class="context-menu-item" id="start-menu-settings"><i class="fa-solid fa-cog"></i> 開始設定</div>
            </div>

            <!-- 2. 桌面 -->
            <div id="desktop">
                <!-- 桌面圖示 -->
                <div class="desktop-icon" data-app="settings">
                    <i class="fa-solid fa-gear icon-settings"></i>
                    <span>設定</span>
                </div>
                <div class="desktop-icon" data-app="nagato">
                    <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img icon-nagato" loading="lazy">
                    <span>長門櫻</span>
                </div>
                <div class="desktop-icon" data-app="explorer">
                    <i class="fa-solid fa-folder icon-explorer"></i>
                    <span>檔案總管</span>
                </div>
                <div class="desktop-icon" data-app="browser">
                    <i class="fa-brands fa-edge icon-edge"></i>
                    <span>瀏覽器</span>
                </div>
                <div class="desktop-icon" data-app="store">
                    <i class="fa-solid fa-store icon-store"></i>
                    <span>應用商店</span>
                </div>
            </div>

            <!-- 3. 任務欄 -->
            <div id="taskbar">
                <div class="taskbar-group left">
                    <!-- 小工具按鈕 -->
                    <div class="taskbar-icon" id="widgets-button" title="小工具">
                        <i class="fa-solid fa-table-cells-large"></i>
                    </div>
                </div>
                
                <div class="taskbar-group center">
                    <!-- 開始按鈕 -->
                    <div class="taskbar-icon" id="start-button" title="開始">
                        <img src="../../assets/images/logo.png" alt="開始" class="app-icon-img" loading="lazy">
                    </div>
                    <!-- 搜尋 -->
                    <div class="taskbar-icon" id="search-button" title="搜尋">
                        <i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                    
                    <!-- 任務圖示 (動態) -->

                    <div class="taskbar-icon" id="taskbar-icon-nagato" data-app="nagato" data-pinned="true" title="長門櫻" role="button" tabindex="0" aria-pressed="false">
                        <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img" loading="lazy">
                    </div>
                    <div class="taskbar-icon" id="taskbar-icon-explorer" data-app="explorer" data-pinned="true" title="檔案總管" role="button" tabindex="0" aria-pressed="false">
                        <i class="fa-solid fa-folder icon-explorer"></i>
                    </div>
                    <div class="taskbar-icon" id="taskbar-icon-browser" data-app="browser" data-pinned="true" title="瀏覽器" role="button" tabindex="0" aria-pressed="false">
                        <i class="fa-brands fa-edge icon-edge"></i>
                    </div>
                    <div class="taskbar-icon" id="taskbar-icon-store" data-app="store" data-pinned="true" title="應用商店" role="button" tabindex="0" aria-pressed="false">
                        <i class="fa-solid fa-store icon-store"></i>
                    </div>
                </div>
                
                <div class="taskbar-group right">
                    <!-- 時間日期 -->
                    <div id="taskbar-time">
                        <div id="time"><span class="ampm">午前</span><span class="time-value">00:00</span></div>
                        <div id="date">YYYY/MM/DD</div>
                    </div>
                </div>
            </div>

            <!-- 4. 開始功能表 -->
            <div id="start-menu">
                <div class="start-menu-header">
                    <div class="search-bar">
                        <i class="fa-solid fa-magnifying-glass"></i>
                        <input type="text" placeholder="在這裡搜尋應用程式、設定和文件">
                    </div>
                </div>
                
                <div class="start-menu-body">
                    <div class="start-section-title">已釘選</div>
                    <div class="pinned-apps">
                        <div class="app-icon" data-app="settings">
                            <i class="fa-solid fa-gear icon-settings"></i>
                            <span>設定</span>
                        </div>
                        <div class="app-icon" data-app="nagato">
                            <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img" loading="lazy">
                            <span>長門櫻</span>
                        </div>
                        <div class="app-icon" data-app="explorer">
                            <i class="fa-solid fa-folder icon-explorer"></i>
                            <span>檔案總管</span>
                        </div>
                        <div class="app-icon" data-app="browser">
                            <i class="fa-brands fa-edge icon-edge"></i>
                            <span>瀏覽器</span>
                        </div>
                        <div class="app-icon" data-app="store">
                            <i class="fa-solid fa-store icon-store"></i>
                            <span>商店</span>
                        </div>
                        <div class="app-icon" data-app="calculator">
                            <i class="fa-solid fa-calculator" style="color: #4caf50;"></i>
                            <span>計算機</span>
                        </div>
                    </div>
                    
                    <div class="start-section-title">建議</div>
                    <div class="recommended-list">
                        <div class="recommended-item">
                            <i class="fa-solid fa-file-word" style="color: #2b579a;"></i>
                            <div class="recommended-item-info">
                                專案報告.docx
                                <span>15 分鐘前</span>
                            </div>
                        </div>
                        <div class="recommended-item">
                            <i class="fa-solid fa-image" style="color: #e81123;"></i>
                            <div class="recommended-item-info">
                                設計原型.png
                                <span>1 小時前</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="start-menu-footer">
                    <div class="user-profile">
                        <img src="../../assets/images/avatar.jpg" alt="天野靜樹" class="avatar" width="36" height="36" loading="lazy">
                        <span>天野靜樹</span>
                    </div>
                    <div class="power-button" title="電源">
                        <i class="fa-solid fa-power-off"></i>
                    </div>
                </div>
            </div>

            <!-- 5. 視窗 (多個) -->

            <!-- 5.1 設定視窗 -->
            <div class="window" id="window-settings" data-app="settings">
                <!-- 調整大小 Handles -->
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>

                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-gear icon-settings"></i>
                        <span>設定</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize" title="最小化">
                            <i class="fa-solid fa-minus"></i>
                        </div>
                        <div class="window-control-btn maximize" title="最大化">
                            <i class="fa-regular fa-square"></i>
                            <!-- 貼齊佈局 (新增) -->
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close" title="關閉">
                            <i class="fa-solid fa-xmark"></i>
                        </div>
                    </div>
                </div>
                <div class="window-content settings-content">
                    <div class="settings-sidebar">
                        <div class="settings-menu-item active" data-page="page-display" role="button" tabindex="0">
                            <i class="fa-solid fa-display"></i> 顯示
                        </div>
                        <div class="settings-menu-item" data-page="page-personalization" role="button" tabindex="0">
                            <i class="fa-solid fa-palette"></i> 個人化
                        </div>
                        <div class="settings-menu-item" data-page="page-network" role="button" tabindex="0">
                            <i class="fa-solid fa-wifi"></i> 網路
                        </div>
                        <div class="settings-menu-item" data-page="page-privacy" role="button" tabindex="0">
                            <i class="fa-solid fa-shield-halved"></i> 隱私權
                        </div>
                        <div class="settings-menu-item" data-page="page-about" role="button" tabindex="0">
                            <i class="fa-solid fa-circle-info"></i> 關於
                        </div>
                        <div class="settings-menu-item" data-page="page-update" role="button" tabindex="0">
                            <i class="fa-solid fa-arrow-up-right-from-square"></i> 更新
                        </div>
                    </div>
                    <div class="settings-main">
                        <!-- Page: Display -->
                        <div id="page-display" class="settings-page">
                            <div class="setting-section">
                                <h3>顯示</h3>
                                <div class="setting-item">
                                    <div class="setting-item-label">
                                        亮度
                                        <span>調整內建顯示器的亮度</span>
                                    </div>
                                    <div class="slider-control">
                                        <div class="slider-value" id="brightnessValue">70%</div>
                                        <input type="range" class="slider-range" id="displayBrightness" min="0" max="100" value="70" step="1" aria-label="顯示亮度">
                                    </div>
                                </div>
                                <div class="setting-item" id="nightlightItem" role="button" tabindex="0" aria-pressed="false">
                                    <div class="setting-item-label">
                                        夜間光線
                                        <span>使用較暖的色彩以協助睡眠</span>
                                    </div>
                                    <div class="toggle-switch" id="nightLightToggle" role="switch" aria-checked="false" tabindex="0"></div>
                                </div>
                            </div>
                            <!-- Nightlight subpage: hidden by default (inside Display page) -->
                            <div id="nightlight-settings" class="settings-subpage" style="display:none;">
                            <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                <button id="nightlight-back" style="padding:6px 8px; background:transparent; border:1px solid rgba(255,255,255,0.06); color:#f0f0f0; border-radius:6px;">← 返回</button>
                                <h3 style="margin:0;">夜間光線設定</h3>
                            </div>

                            <div class="setting-item">
                                <div class="setting-item-label">開關
                                    <span>在此啟用或停用夜間光線</span>
                                </div>
                                <div class="toggle-switch" id="nightlightSubToggle" role="switch" aria-checked="false" tabindex="0"></div>
                            </div>

                            <div class="setting-item">
                                <div class="setting-item-label">強度
                                    <span>調整夜間光線強度</span>
                                </div>
                                <div class="slider-control">
                                    <div class="slider-value" id="nightlightStrengthValue">50%</div>
                                    <input type="range" class="slider-range" id="nightlightStrength" min="0" max="100" value="50" step="1" aria-label="夜間光線強度">
                                </div>
                            </div>

                            <div class="setting-item">
                                <div class="setting-item-label">排程
                                    <span>設定自動開啟夜間光線的時間區間</span>
                                </div>
                                <div style="display:flex;align-items:center;gap:8px;">
                                    <div class="toggle-switch" id="nightlightScheduleToggle" role="switch" aria-checked="false" tabindex="0"></div>
                                </div>
                            </div>

                            <div id="nightlight-schedule-controls" style="display:none; margin-top:6px;">
                                <div class="setting-item">
                                    <div class="setting-item-label">開始時間
                                        <span>選擇要開始啟用夜間光線的時間</span>
                                    </div>
                                    <input type="time" id="nightlightStart" value="22:00" aria-label="夜間光線開始時間">
                                </div>
                                <div class="setting-item">
                                    <div class="setting-item-label">結束時間
                                        <span>選擇結束夜間光線的時間</span>
                                    </div>
                                    <input type="time" id="nightlightEnd" value="06:00" aria-label="夜間光線結束時間">
                                </div>
                            </div>
                        </div>
                        </div>
                        <!-- Page: Personalization -->
                        <div id="page-personalization" class="settings-page" style="display:none;">
                            <div class="setting-section">
                                <h3>個人化</h3>
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>主題</span>
                                    <span class="setting-description">切換深色/淺色模式</span>
                                </div>
                                <div class="select-control">
                                    <select id="personalization_themeMode">
                                        <option value="dark">深色模式</option>
                                        <option value="light">淺色模式</option>
                                    </select>
                                </div>
                            </div>

                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>色彩 (強調色)</span>
                                    <span class="setting-description">選擇系統主題色與強調色</span>
                                </div>
                                <div style="display:flex;gap:8px;align-items:center;">
                                    <input type="color" id="personalization_accentColor" aria-label="主題色"> 
                                    <span class="accent-swatch" id="personalization_accentColor_preview"></span>
                                </div>
                            </div>

                            <!-- Background: details in subpage -->
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>背景</span>
                                    <span class="setting-description">編輯桌面背景</span>
                                </div>
                                <div style="display:flex;gap:8px;align-items:center;">
                                    <div id="personalization_bgPreview" title="當前桌面背景預覽" style="width:56px; height:36px; border-radius:6px; background: linear-gradient(135deg,#0f2027 0%,#2c5364 100%); border:1px solid rgba(255,255,255,0.04);"></div>
                                </div>
                            </div>

                            <!-- Background panel (moved to page bottom) -->

                            <!-- Start menu: split into two single-control items -->
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>顯示建議</span>
                                    <span class="setting-description">顯示開始功能表中的建議項目</span>
                                </div>
                                <div class="toggle-switch" id="personalization_startShowSuggested"></div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>顯示最近使用</span>
                                    <span class="setting-description">顯示開始功能表中的最近使用項目</span>
                                </div>
                                <div class="toggle-switch" id="personalization_startShowRecent"></div>
                            </div>

                            <!-- Taskbar: separate controls for position and icon size -->
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>工作列位置</span>
                                    <span class="setting-description">設定工作列的位置（左右/置中）</span>
                                </div>
                                <div class="select-control">
                                    <select id="personalization_taskbarPosition">
                                        <option value="center">置中</option>
                                        <option value="left">靠左</option>
                                        <option value="right">靠右</option>
                                    </select>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>工作列圖示大小</span>
                                    <span class="setting-description">調整工作列圖示大小</span>
                                </div>
                                <div class="slider-control">
                                    <div class="slider-value" id="personalization_taskbarIconSizeValue">24px</div>
                                    <input type="range" class="slider-range" id="personalization_taskbarIconSize" min="12" max="48" step="2" value="24" aria-label="工作列圖示大小">
                                </div>
                            </div>

                            <!-- Fonts: split into font set and font scale -->
                            <div class="setting-item">
                                <div class="setting-label">
                                    <span>字型</span>
                                    <span class="setting-description">選擇 UI 與文字字型</span>
                                </div>
                                <div class="select-control">
                                    <select id="personalization_fontSet">
                                        <option value="default">預設 (Orbitron / Rajdhani / Noto Sans TC)</option>
                                        <option value="system">系統字型</option>
                                        <option value="serif">Serif</option>
                                        <option value="mono">等寬字體</option>
                                    </select>
                                </div>
                            </div>
                            </div>
                        </div>
                        <!-- Personalization subpages (moved here to remain visible when main section is hidden) -->
                        <div id="personalization_background_panel" class="settings-subpage" style="display:none; margin-top:10px;">
                            <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                <button id="personalization_background_back" style="padding:6px 8px; background:transparent; border:1px solid rgba(255,255,255,0.06); color:#f0f0f0; border-radius:6px;">← 返回</button>
                                <h3 style="margin:0;">背景設定</h3>
                            </div>
                            <div class="setting-item" style="margin-top:6px;" id="personalization_bg_brightness_item">
                                <div class="setting-item-label">背景亮度
                                    <span>獨立調整桌面背景的亮度（不影響 UI）</span>
                                </div>
                                <div class="slider-control">
                                    <div class="slider-value" id="personalization_bgBrightnessValue">100%</div>
                                    <input type="range" class="slider-range" id="personalization_bgBrightness" min="0" max="100" value="100" step="1" aria-label="背景亮度">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-item-label">模式
                                    <span>選擇桌面背景類型（預設 / 漸層 / 單色 / 圖片 / 影片）</span>
                                </div>
                                <div class="select-control">
                                    <select id="personalization_backgroundMode" aria-label="背景模式">
                                        <option value="default">預設</option>
                                        <option value="gradient1">漸層 1</option>
                                        <option value="gradient2">漸層 2</option>
                                        <option value="solid">單色</option>
                                        <option value="image">圖片</option>
                                        <option value="video">影片</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Solid color control -->
                            <div id="personalization_background_solid" class="setting-item" style="display:none;">
                                <div class="setting-item-label">顏色
                                    <span>選擇桌面單色背景</span>
                                </div>
                                <div style="display:flex;gap:8px;align-items:center;">
                                    <input type="color" id="personalization_bgColor" aria-label="背景顏色">
                                </div>
                            </div>

                            <!-- Gradient 1 control -->
                            <div id="personalization_background_gradient1" class="setting-item" style="display:none;">
                                <div class="setting-item-label">漸層 1
                                    <span>從起始顏色到結束顏色 (線性漸層)</span>
                                </div>
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <input type="color" id="personalization_bgGradient1_start" aria-label="漸層1 起始顏色">
                                    <input type="color" id="personalization_bgGradient1_end" aria-label="漸層1 結束顏色">
                                </div>
                            </div>

                            <!-- Gradient 2 control -->
                            <div id="personalization_background_gradient2" class="setting-item" style="display:none;">
                                <div class="setting-item-label">漸層 2
                                    <span>從起始顏色到結束顏色 (線性漸層)</span>
                                </div>
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <input type="color" id="personalization_bgGradient2_start" aria-label="漸層2 起始顏色">
                                    <input type="color" id="personalization_bgGradient2_end" aria-label="漸層2 結束顏色">
                                </div>
                            </div>

                            <!-- Image control: URL / Upload / Reset / Thumbnails -->
                            <div id="personalization_background_image" class="setting-item" style="display:none; flex-direction:column; gap:10px;">
                                <div style="display:flex; align-items:center; gap:12px; width:100%;">
                                    <div class="setting-item-label">圖片
                                        <span>URL</span>
                                    </div>
                                    <div style="display:flex; gap:8px; align-items:center; margin-left:auto;">
                                        <input type="text" id="personalization_bgImageUrl" placeholder="圖片 URL 或 Base64" style="min-width:240px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff;" aria-label="背景圖片 URL">
                                        <button id="personalization_bgUpload" style="padding:6px 8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06); color:#f0f0f0;">上傳</button>
                                        <input type="file" id="personalization_bgUploadFile" accept="image/*" style="display:none;">
                                        <button id="personalization_bgReset" style="padding:6px 8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06); color:#f0f0f0;">重設</button>
                                    </div>
                                </div>
                                <div id="personalization_bgThumbs" style="display:flex; flex-wrap:wrap; gap:8px; margin-top:25px;">
                                    <!-- Thumbnails will be populated dynamically -->
                                </div>
                            </div>

                            <!-- Video control: URL / Upload / Reset / Thumbnails -->
                            <div id="personalization_background_video" class="setting-item" style="display:none; flex-direction:column; gap:10px;">
                                <div style="display:flex; align-items:center; gap:12px; width:100%;">
                                    <div class="setting-item-label">影片
                                        <span>URL 或 上傳影片檔案</span>
                                    </div>
                                    <div style="display:flex; gap:8px; align-items:center; margin-left:auto;">
                                        <input type="text" id="personalization_bgVideoUrl" placeholder="影片 URL 或 Base64" style="min-width:240px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff;" aria-label="背景影片 URL">
                                        <button id="personalization_bgVideoUpload" style="padding:6px 8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06); color:#f0f0f0;">上傳</button>
                                        <input type="file" id="personalization_bgVideoUploadFile" accept="video/*" style="display:none;">
                                        <button id="personalization_bgVideoReset" style="padding:6px 8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06); color:#f0f0f0;">重設</button>
                                    </div>
                                </div>
                                <div id="personalization_bgVideoThumbs" style="display:flex; flex-wrap:wrap; gap:8px; margin-top:25px;">
                                    <!-- Video Thumbnails will be populated dynamically -->
                                </div>
                            </div>

                        </div>

                        <div id="personalization_font_panel" class="settings-subpage" style="display:none; margin-top:10px;">
                            <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                <button id="personalization_font_back" style="padding:6px 8px; background:transparent; border:1px solid rgba(255,255,255,0.06); color:#f0f0f0; border-radius:6px;">← 返回</button>
                                <h3 style="margin:0;">字型進階設定</h3>
                            </div>
                            <div class="setting-item">
                                <div class="setting-item-label">字型
                                    <span>選擇主題字型</span>
                                </div>
                                <div class="select-control">
                                    <select id="personalization_fontSet_panel" aria-label="字型選擇 (進階)">
                                    <option value="default">預設 (Orbitron / Rajdhani / Noto Sans TC)</option>
                                    <option value="system">系統字型</option>
                                    <option value="serif">Serif</option>
                                    <option value="mono">等寬字體</option>
                                    </select>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-item-label">字型縮放
                                    <span>調整整體 UI 字型大小</span>
                                </div>
                                <div class="slider-control">
                                    <div class="slider-value" id="personalization_fontScaleValue_panel">100%</div>
                                    <input type="range" class="slider-range" id="personalization_fontScale_panel" min="80" max="140" step="5" value="100" aria-label="字型大小縮放">
                                </div>
                            </div>
                        </div>

                        <!-- Page: Network (placeholder) -->
                        <div id="page-network" class="settings-page" style="display:none;">
                            <div class="setting-section">
                                <h3>網路</h3>
                                <div class="setting-item">
                                    <div class="setting-item-label">Wi-Fi
                                        <span>在此新增或管理 Wi-Fi 網路</span>
                                    </div>
                                    <div class="toggle-switch" id="network_wifi_toggle"></div>
                                </div>
                            </div>
                        </div>
                        <!-- Page: Privacy (placeholder) -->
                        <div id="page-privacy" class="settings-page" style="display:none;">
                            <div class="setting-section">
                                <h3>隱私權</h3>
                                <div class="setting-item">
                                    <div class="setting-item-label">診斷資料
                                        <span>允許傳送使用情況分析以改善體驗</span>
                                    </div>
                                    <div class="toggle-switch" id="privacy_diagnostics_toggle"></div>
                                </div>
                            </div>
                        </div>
                        <!-- Page: About (placeholder) -->
                        <div id="page-about" class="settings-page" style="display:none;">
                            <div class="setting-section about-header">
                                <div style="display:flex;align-items:center;gap:12px;">
                                    <div>
                                        <h3 style="margin-bottom:6px;">關於 — 長門櫻 WebOS</h3>
                                    </div>
                                    <img src="../../assets/images/logo.png" alt="長門櫻 - Web OS" class="about-logo" loading="lazy">
                                </div>
                            </div>

                            <div class="setting-section about-grid">
                                <div class="about-item" style="grid-column: span 2;">
                                    <h4>版本資訊</h4>
                                    <div class="about-item-row">版本: <strong id="about-version">v1.0.0</strong></div>
                                    <div style="font-size:0.9rem;color:#ccc;">建構日期: <span id="about-build-date">2025/11/18</span></div>
                                    <div style="font-size:0.9rem;color:#ccc;">啟用於: <span id="about-boot-time">--</span></div>
                                </div>
                                <div class="about-item" style="margin-top:14px;">
                                    <h4>系統資訊</h4>
                                    <div class="about-item-row">瀏覽器: <span id="about-browser">--</span></div>
                                    <div class="about-item-row">解析度: <span id="about-resolution">--</span></div>
                                    <div class="about-item-row">語言: <span id="about-language">--</span></div>
                                </div>
                                <div class="about-item" style="margin-top:14px;">
                                    <h4>授權與文件</h4>
                                    <div class="about-item-row">授權: <a href="../../LICENSE" target="_blank" rel="noopener">檢視 LICENSE</a></div>
                                    <div class="about-item-row">原始碼與貢獻: <a href="https://github.com/AmanoShizukikun/AmanoShizukikun.github.io" target="_blank" rel="noopener">GitHub</a></div>
                                    <div class="about-item-row">回報問題: <a href="https://github.com/AmanoShizukikun/AmanoShizukikun.github.io/issues" target="_blank" rel="noopener">Issue</a></div>
                                </div>

                                <div style="font-size:0.9rem;color:#ccc;margin-top:14px;">©2025  Build By 天野靜樹</div>
                            </div>
                        </div>
                        <!-- Page: Update -->
                        <div id="page-update" class="settings-page" style="display:none;">
                            <div class="setting-section">
                                <h3>更新</h3>
                                <div class="setting-item update-controls" style="margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                                    <button id="update-check-btn" type="button" class="btn btn-rect" title="檢查更新">檢查更新</button>
                                    <button id="update-open-release-btn" type="button" class="btn btn-rect" title="在 GitHub 上檢視發行頁面" disabled>檢視發行頁面</button>
                                    <div style="margin-left:auto;display:flex;align-items:center;gap:8px;"><div>自動檢查</div><div class="toggle-switch" id="update-auto-toggle" role="switch" aria-checked="false" tabindex="0"></div></div>
                                </div>
                                <div class="setting-item update-item">
                                    <div class="setting-item-label">目前版本
                                        <span id="update-current-version" style="display:inline-block;margin-left:6px;color:#ccc;">v1.0.0</span>
                                    </div>
                                    <div class="setting-item-label">最新版本
                                        <span id="update-latest-version" style="display:inline-block;margin-left:6px;color:#ccc;">尚未檢查</span>
                                    </div>
                                    <div class="setting-item-label">說明 / 發行說明</div>
                                    <div id="update-release-notes" style="margin-top:8px;color:#ccc;font-size:0.9rem;max-height:160px;overflow:auto;">尚未取得更新資訊</div>
                                </div>

                                <div style="margin-top:8px;color:#aaa;font-size:0.85rem;">最近檢查：<span id="update-last-checked">尚未檢查</span></div>
                                <div id="update-status" style="margin-top:8px;color:#bdbdbd;font-size:0.85rem;">狀態：等待使用者操作</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5.2 長門櫻 視窗 -->
            <div class="window" id="window-nagato" data-app="nagato" style="width: 400px; height: 600px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img" loading="lazy">
                        <span>長門櫻</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content nagato-content">
                    <div class="nagato-messages">
                        <div class="message ai">主人您好！我叫長門櫻，您的專屬女僕。請問您有什麼需要長門櫻為您效勞的嗎？</div>
                    </div>
                    <div class="nagato-input-area">
                        <textarea id="nagato-input" rows="1" placeholder="在這裡輸入..." aria-label="輸入訊息"></textarea>
                        <button id="nagato-clear" class="clear-btn" title="清除對話" aria-label="清除對話"><i class="fa-solid fa-trash"></i></button>
                        <button id="nagato-send" title="傳送"><i class="fa-solid fa-paper-plane"></i></button>
                    </div>
                </div>
            </div>
            
            <!-- 5.3 檔案總管視窗 (新增) -->
            <div class="window" id="window-explorer" data-app="explorer" style="width: 800px; height: 550px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-folder icon-explorer"></i>
                        <span>檔案總管</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content explorer-content">
                    <div class="explorer-sidebar">
                        <h4>快速存取</h4>
                        <div class="explorer-item"><i class="fa-solid fa-desktop"></i> 桌面</div>
                        <div class="explorer-item"><i class="fa-solid fa-download"></i> 下載</div>
                        <div class="explorer-item"><i class="fa-solid fa-file-lines"></i> 文件</div>
                        <h4>本機</h4>
                        <div class="explorer-item"><i class="fa-solid fa-hard-drive"></i> (C:)</div>
                    </div>
                    <div class="explorer-main">
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>文件</span></div>
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>下載</span></div>
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>音樂</span></div>
                        <div class="folder-icon"><i class="fa-solid fa-folder"></i><span>圖片</span></div>
                    </div>
                </div>
            </div>
            
            <!-- 5.4 瀏覽器視窗 (新增) -->
            <div class="window" id="window-browser" data-app="browser" style="width: 900px; height: 600px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-brands fa-edge icon-edge"></i>
                        <span>瀏覽器 (模擬)</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content browser-content">
                        <!-- 使用 Edge 風格的 toolbar 和 favorites bar -->
                        <div id="win-edge">
                            <div class="tool">
                                <a class="a" id="browser-back" title="上一頁"><i class="fa-solid fa-arrow-left"></i></a>
                                <a class="a" id="browser-forward" title="下一頁"><i class="fa-solid fa-arrow-right"></i></a>
                                <a class="a" id="browser-refresh" title="重新整理"><i class="fa-solid fa-rotate-right"></i></a>
                                <input id="browser-url-input" class="url" type="text" value="https://amanoshizukikun.github.io/" aria-label="網址列">
                                <a class="a" id="bookmark-toggle" title="管理最愛" aria-pressed="false"><i class="fa-regular fa-star"></i></a>
                            </div>

                            <!-- 最愛列 (Favorites bar) - 可滾動的按鈕列 -->
                            <div class="favorites-bar" id="favorites-bar" role="navigation" aria-label="最愛列">
                                <!-- JS will populate favorite items here -->
                            </div>
                        <iframe class="browser-iframe" src="about:blank" sandbox="allow-scripts allow-same-origin"></iframe>
                        </div>
                </div>
            </div>
            
            <!-- 5.5 應用商店視窗 (新增) -->
            <div class="window" id="window-store" data-app="store" style="width: 800px; height: 600px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-store icon-store"></i>
                        <span>應用商店</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize"><i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content store-content">
                    <i class="fa-solid fa-shop"></i>
                    <h3>應用商店即將上線</h3>
                    <p>正在準備更多精彩的應用程式...</p>
                </div>
            </div>
            <!-- 5.6 計算機視窗 (新增) -->
            <div class="window" id="window-calculator" data-app="calculator" data-min-width="320" data-min-height="430" style="width: 340px; height: 430px;">
                <div class="resize-handle n"></div><div class="resize-handle s"></div><div class="resize-handle e"></div><div class="resize-handle w"></div>
                <div class="resize-handle nw"></div><div class="resize-handle ne"></div><div class="resize-handle sw"></div><div class="resize-handle se"></div>
                <div class="window-header">
                    <div class="window-title">
                        <i class="fa-solid fa-calculator icon-calculator" style="color: #4caf50;"></i>
                        <span>計算機</span>
                    </div>
                    <div class="window-controls">
                        <div class="window-control-btn minimize" title="最小化"><i class="fa-solid fa-minus"></i></div>
                        <div class="window-control-btn maximize" title="最大化">
                            <i class="fa-regular fa-square"></i>
                            <div class="snap-layouts">
                                <div class="snap-layout-option" title="左上角"></div>
                                <div class="snap-layout-option" title="右上角"></div>
                                <div class="snap-layout-option" title="左下角"></div>
                                <div class="snap-layout-option" title="右下角"></div>
                            </div>
                        </div>
                        <div class="window-control-btn close" title="關閉"><i class="fa-solid fa-xmark"></i></div>
                    </div>
                </div>
                <div class="window-content" id="win-calc">
                    <div class="container">
                        <input id="calc-input" aria-label="計算機輸入" readonly="true" value="0" onkeydown="
                            switch (event.key) {
                                case '+':
                                    appCalculator.func_key(1);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.jia'));
                                    break;
                                case '-':
                                    appCalculator.func_key(2);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.jian'));
                                    break;
                                case '*':
                                    appCalculator.func_key(3);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.cheng'));
                                    break;
                                case '/':
                                    appCalculator.func_key(4);
                                    appCalculator.check(document.querySelector('#win-calc>.keyb>.chu'));
                                    break;
                                case '=':
                                case 'Enter':
                                    appCalculator.eq();
                                    break;
                                case 'Backspace':
                                    appCalculator.backspace();
                                    break;
                                case '.':
                                    appCalculator.point();
                                    break;
                            }
                            if (!isNaN(event.key)) {
                                appCalculator.number_key(Number(event.key));
                            }
                        " />
                    </div>
                    <div class="keyb">
                        <a class="a b" onclick="appCalculator.square()">𝑥²</a>
                        <a class="a b" onclick="appCalculator.squareRoot()">√𝑥</a>
                        <a class="a b" onclick="appCalculator.clear_num()">C</a>
                        <a class="a b u jia" onclick="appCalculator.func_key(1); appCalculator.check(this);">+</a>
                        <a class="a b" onclick="appCalculator.number_key(7);">7</a>
                        <a class="a b" onclick="appCalculator.number_key(8);">8</a>
                        <a class="a b" onclick="appCalculator.number_key(9);">9</a>
                        <a class="a b u jian" onclick="appCalculator.func_key(2); appCalculator.check(this);">-</a>
                        <a class="a b" onclick="appCalculator.number_key(4);">4</a>
                        <a class="a b" onclick="appCalculator.number_key(5);">5</a>
                        <a class="a b" onclick="appCalculator.number_key(6);">6</a>
                        <a class="a b u cheng" onclick="appCalculator.func_key(3); appCalculator.check(this);">×</a>
                        <a class="a b" onclick="appCalculator.number_key(1);">1</a>
                        <a class="a b" onclick="appCalculator.number_key(2);">2</a>
                        <a class="a b" onclick="appCalculator.number_key(3);">3</a>
                        <a class="a b u chu" onclick="appCalculator.func_key(4); appCalculator.check(this);">÷</a>
                        <a class="a b" onclick="appCalculator.point()">.</a>
                        <a class="a b" onclick="appCalculator.number_key(0);">0</a>
                        <a class="a b" onclick="appCalculator.backspace()"><i class="fa-solid fa-delete-left"></i></a>
                        <a class="a b ans u" onclick="if(!appCalculator.eq()){ appCalculator.clear_num(); }">=</a>
                    </div>
                </div>
            </div>

            <!-- 6. 日曆彈窗 -->
            <div id="calendar-flyout">
                <div class="calendar-header">
                    <span id="calendar-month-year"></span>
                    <div class="calendar-nav">
                        <button id="calendar-prev"><i class="fa-solid fa-chevron-left"></i></button>
                        <button id="calendar-next"><i class="fa-solid fa-chevron-right"></i></button>
                    </div>
                </div>
                <div class="calendar-grid" id="calendar-grid">
                    <!-- 由 JS 生成 -->
                </div>
            </div>
            
            <!-- 7. 小工具面板 (新增) -->
            <div id="widgets-panel">
                <div class="widget weather-widget" id="widget-weather">
                    <div class="widget-header">天氣 <span id="weather-location" class="small">台北市</span></div>
                    <div class="weather-controls">
                        <input id="weather-city-input" type="text" aria-label="城市" placeholder="城市 (例如：Taipei / 台北)" />
                        <button id="weather-refresh" aria-label="刷新天氣" title="刷新"><i class="fa-solid fa-rotate-right"></i></button>
                        <button id="weather-geolocate" aria-label="使用定位" title="使用定位"><i class="fa-solid fa-location-crosshairs"></i></button>
                    </div>
                    <div class="weather-main">
                        <div class="weather-visual"><i id="weather-icon" class="fa-solid fa-cloud-sun"></i></div>
                        <div class="weather-info">
                            <div class="temp" id="weather-temp">--°C</div>
                            <div class="desc" id="weather-desc">載入中...</div>
                            <div class="meta"><span id="weather-humidity"></span> <span id="weather-feels"></span> <span id="weather-updated" style="margin-left:8px;color:#9aa; font-size:0.8rem"></span></div>
                        </div>
                    </div>
                    <div class="weather-forecast" id="weather-forecast"></div>
                </div>
                <div class="widget news-widget">
                    <div class="widget-header">頭條新聞</div>
                    <div class="news-item">
                        <img src="https://placehold.co/100x100/333/fff?text=NEWS" alt="News">
                        <div class="news-item-info">
                            這是一條模擬的新聞標題...
                            <span>2 小時前</span>
                        </div>
                    </div>
                    <div class="news-item">
                        <img src="https://placehold.co/100x100/555/fff?text=TECH" alt="Tech">
                        <div class="news-item-info">
                            關於網頁技術的最新進展...
                            <span>3 小時前</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 8. 右鍵選單 (新增) -->
            <div id="context-menu">
                <div class="context-menu-item"><i class="fa-solid fa-eye"></i> 檢視</div>
                <div class="context-menu-item"><i class="fa-solid fa-arrow-down-a-z"></i> 排序方式</div>
                <div class="context-menu-item"><i class="fa-solid fa-rotate-right"></i> 重新整理</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item"><i class="fa-solid fa-folder-plus"></i> 新增</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item"><i class="fa-solid fa-display"></i> 顯示設定</div>
                <div class="context-menu-item"><i class="fa-solid fa-palette"></i> 個人化</div>
            </div>

        </main>
        
        <!-- 4. 右側設定面板 (使用全域 Settings Panel) -->
        <div class="settings-panel">
            <div class="settings-header">
                <h2 class="settings-title">系統設定</h2>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-title">顯示設定</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>固定導航欄</span>
                        <span class="setting-description">保持導航欄在頂部固定</span>
                    </div>
                    <div class="toggle-switch" id="headerFixed"></div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>導航欄高度</span>
                        <span class="setting-description">調整頂部導航欄的高度</span>
                    </div>
                    <div class="slider-control">
                        <div class="slider-value" id="headerHeightValue">75px</div>
                        <input type="range" class="slider-range" id="headerHeight" min="50" max="100" value="75" step="5">
                        <div class="slider-marks">
                            <span data-value="50">小</span>
                            <span data-value="75">中</span>
                            <span data-value="100">大</span>
                        </div>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>視窗越界允許</span>
                        <span class="setting-description">允許視窗部分移出畫面的百分比 (左右/下方)</span>
                    </div>
                    <div class="slider-control">
                        <div class="slider-value" id="offscreenRatioValue">90%</div>
                        <input type="range" class="slider-range" id="offscreenRatio" min="0" max="100" value="90" step="5">
                        <div class="slider-marks">
                            <span data-value="0">0%</span>
                            <span data-value="50">50%</span>
                            <span data-value="100">100%</span>
                        </div>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>側邊欄文字顯示</span>
                        <span class="setting-description">是否持續顯示側邊欄文字標題</span>
                    </div>
                    <div class="toggle-switch active" id="sideNavTextVisible"></div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <span>主題模式</span>
                        <span class="setting-description">切換深色/淺色模式</span>
                    </div>
                    <div class="select-control">
                        <select id="themeMode">
                            <option value="dark">深色模式</option>
                            <option value="light">淺色模式</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-title">效能設定</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>動畫強度</span>
                        <span class="setting-description">調整頁面動畫效果強度</span>
                    </div>
                    <div class="slider-control">
                        <div class="slider-value" id="animationValue">強</div>
                        <input type="range" class="slider-range" id="animationStrength" min="0" max="2" value="2" step="1">
                        <div class="slider-marks">
                            <span data-value="0">關</span>
                            <span data-value="1">低</span>
                            <span data-value="2">強</span>
                        </div>
                    </div>
                </div>

                <div class="setting-item fps-monitor">
                    <div class="setting-label">
                        <span>幀數監控</span>
                        <span class="setting-description">即時顯示頁面渲染幀率</span>
                    </div>
                    <div class="fps-display">
                        <span class="fps-value" id="fpsValue">000</span>
                        <span class="fps-unit">FPS</span>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-title">音效設定</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>音效開關</span>
                        <span class="setting-description">啟用/關閉互動音效</span>
                    </div>
                    <div class="toggle-switch active" id="soundEnabled"></div>
                </div>
            </div>
        </div>

    </div>


    <script src="../../assets/js/core.js"></script>
    <script src="../../assets/js/navigation.js"></script>
    <script src="../../assets/js/animations.js"></script>

    <!-- Calc dependencies: jQuery (for the kernel), Big.js (arbitrary precision), and calculator kernel script -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/big.js/6.2.1/big.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- 0. 獲取 DOM 元素 ---
            // 修改：獲取模擬器容器
            const simulatorContainer = document.getElementById('simulator-container-main');
            
            const bootLoader = document.getElementById('boot-loader');
            const desktop = document.getElementById('desktop');
            const taskbar = document.getElementById('taskbar');
            const startButton = document.getElementById('start-button');
            const startMenu = document.getElementById('start-menu');
            const taskbarTime = document.getElementById('taskbar-time');
            const timeEl = document.getElementById('time');
            const timeAmpmEl = timeEl.querySelector('.ampm');
            const timeValueEl = timeEl.querySelector('.time-value');
            const dateEl = document.getElementById('date');
            const calendarFlyout = document.getElementById('calendar-flyout');
            const calendarGrid = document.getElementById('calendar-grid');
            const calendarMonthYear = document.getElementById('calendar-month-year');
            const calendarPrev = document.getElementById('calendar-prev');
            const calendarNext = document.getElementById('calendar-next');
            const widgetsButton = document.getElementById('widgets-button');
            const widgetsPanel = document.getElementById('widgets-panel');
            const contextMenu = document.getElementById('context-menu');
            
            const windows = document.querySelectorAll('.window');
            // Keep a NodeList of pinned icons (static), but we will dynamically create temporary icons for apps opened
            const pinnedTaskbarIcons = document.querySelectorAll('.taskbar-icon[data-app][data-pinned]');
            function getAllTaskbarIcons() { return document.querySelectorAll('.taskbar-icon[data-app]'); }
            const desktopIcons = document.querySelectorAll('.desktop-icon[data-app]');
            
            let calendarDate = new Date();
            let activeWindow = null;
            let highestZIndex = 1000;

            class Calculator {
                constructor(inputSelector, keysContainerSelector) {
                    this.eltSelector = inputSelector;
                    this.elt = document.querySelector(inputSelector);
                    this.num1 = null;
                    this.num2 = null;
                    this.keysContainer = document.querySelector(keysContainerSelector);
                    this.operator = 0;
                    this.preview = false;
                }

                get_num() { return Big(this.elt.value); }

                number_key(key) {
                    if (!this.elt) return;
                    if (this.elt.value === '0' || this.preview) {
                        this.elt.value = '';
                        this.preview = false;
                    }
                    this.elt.value += key;
                    this.uncheck();
                }

                func_key(key) {
                    if (!this.elt) return;
                    if (!this.isCheck()) {
                        if (this.num1 != null) {
                            this.num2 = Big(this.elt.value);
                            this.num1 = Big(this._calc(this.num1, this.num2, this.operator));
                            this.elt.value = this.num1;
                            this.preview = true;
                        } else {
                            this.num1 = Big(this.elt.value);
                            this.elt.value = this.num1;
                            this.preview = true;
                        }
                    }
                    this.operator = key;
                }

                check(elt) {
                    this.uncheck();
                    if (elt) elt.classList.add('checked');
                }

                uncheck() {
                    if (!this.keysContainer) return;
                    for (const elt of this.keysContainer.children) {
                        elt.classList.remove('checked');
                    }
                }

                isCheck() { if (!this.keysContainer) return false; for (const elt of this.keysContainer.children) { if (elt.classList.contains('checked')) return true; } return false; }

                point() { if (!this.elt) return; if (this.elt.value === '') this.elt.value = '0'; if (!this.elt.value.includes('.')) this.elt.value += '.'; }

                square() { if (!this.elt) return; this.elt.value = (Number(this.get_num().toString()) ** 2).toString(); }
                squareRoot() { if (!this.elt) return; this.elt.value = Math.sqrt(Number(this.get_num().toString())); }

                backspace() { if (!this.elt) return; if (this.elt.value.length > 0) { this.elt.value = this.elt.value.substring(0, this.elt.value.length - 1); } if (this.elt.value === '') this.elt.value = '0'; }

                clear_num() { if (!this.elt) return; this.elt.value = '0'; this.num1 = null; this.num2 = null; this.operator = 0; this.uncheck(); }

                eq() {
                    if (!this.elt) return true;
                    this.uncheck();
                    if (this.operator === 0) return true;
                    this.num2 = Big(this.elt.value);
                    var num = this._calc(this.num1, this.num2, this.operator);
                    this.clear_num();
                    if (num != null) { this.elt.value = num; return true; }
                    // division by zero or other calculation error: show user-friendly error
                    try { this.elt.value = '錯誤'; this.preview = true; setTimeout(() => { if (this.elt) this.elt.value = '0'; }, 1400); } catch (e) {}
                    return false;
                }

                _calc(n1, n2, c) {
                    try {
                        switch (c) {
                            case 1: return n1.plus(n2).toString();
                            case 2: return n1.minus(n2).toString();
                            case 3: return n1.times(n2).toString();
                            case 4: return (n2 != 0) ? n1.div(n2).toString() : null;
                        }
                    } catch (err) { console.error('Calculation error', err); return null; }
                }
            }

            // --- Display settings: brightness + nightlight ---
            const displayBrightness = document.getElementById('displayBrightness');
            const brightnessValue = document.getElementById('brightnessValue');
            const nightLightToggle = document.getElementById('nightLightToggle');
            const nightlightOverlay = document.getElementById('nightlight-overlay');
            // Subpage controls
            const nightlightItem = document.getElementById('nightlightItem');
            const nightlightSubpage = document.getElementById('nightlight-settings');
            const nightlightBack = document.getElementById('nightlight-back');
            const nightlightStrength = document.getElementById('nightlightStrength');
            const nightlightStrengthValue = document.getElementById('nightlightStrengthValue');
            const nightlightScheduleToggle = document.getElementById('nightlightScheduleToggle');
            const nightlightSubToggle = document.getElementById('nightlightSubToggle');
            const nightlightStartInput = document.getElementById('nightlightStart');
            const nightlightEndInput = document.getElementById('nightlightEnd');

            const DISPLAY_STORAGE_KEY = 'webos_display_settings';

            function mapSliderToBrightness(val) {
                // Map 0..100 slider to 0.6..1.2 brightness range
                const v = parseFloat(val);
                const min = 0.6;
                const max = 1.2;
                return (min + (v / 100) * (max - min)).toFixed(3);
            }

            function mapSliderToNightlightOpacity(val) {
                const v = parseFloat(val);
                const maxOpacity = 0.5; // maximum warm overlay alpha (increased for stronger effect)
                return (v / 100 * maxOpacity).toFixed(3);
            }

            function applyDisplaySettings(settings) {
                const brightVal = (settings && typeof settings.brightness !== 'undefined') ? settings.brightness : Number(displayBrightness.value || 70);
                const night = settings && !!settings.nightLight;
                const nightStrength = settings && typeof settings.nightlightStrength !== 'undefined' ? settings.nightlightStrength : (nightlightStrength ? Number(nightlightStrength.value) : 50);
                const scheduleEnabled = settings && !!settings.nightlightScheduleEnabled;
                const scheduleStart = settings && settings.nightlightScheduleStart ? settings.nightlightScheduleStart : (nightlightStartInput ? nightlightStartInput.value : '22:00');
                const scheduleEnd = settings && settings.nightlightScheduleEnd ? settings.nightlightScheduleEnd : (nightlightEndInput ? nightlightEndInput.value : '06:00');

                // Update UI controls
                if (displayBrightness) {
                    displayBrightness.value = brightVal;
                    if (brightnessValue) brightnessValue.textContent = `${brightVal}%`;
                    const bFactor = mapSliderToBrightness(brightVal);
                    document.documentElement.style.setProperty('--simulator-brightness', bFactor);
                }

                if (nightLightToggle && nightlightOverlay) {
                    if (night) {
                        nightLightToggle.classList.add('active');
                        nightLightToggle.setAttribute('aria-checked', 'true');
                        // use opacity 0.12 as a gentle warm overlay
                        nightlightOverlay.style.opacity = '1';
                        document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(nightStrength));
                    } else {
                        nightLightToggle.classList.remove('active');
                        nightLightToggle.setAttribute('aria-checked', 'false');
                        nightlightOverlay.style.opacity = '0';
                        document.documentElement.style.setProperty('--nightlight-opacity', '0');
                    }
                    // sync subpage toggle as well (if present)
                    if (nightlightSubToggle) {
                        if (night) {
                            nightlightSubToggle.classList.add('active');
                            nightlightSubToggle.setAttribute('aria-checked', 'true');
                        } else {
                            nightlightSubToggle.classList.remove('active');
                            nightlightSubToggle.setAttribute('aria-checked', 'false');
                        }
                    }
                }

                // Apply strength UI
                if (nightlightStrength && nightlightStrengthValue) {
                    nightlightStrength.value = nightStrength;
                    nightlightStrengthValue.textContent = `${nightStrength}%`;
                    document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(nightStrength));
                }

                // Schedule UI
                if (nightlightScheduleToggle) {
                    if (scheduleEnabled) {
                        nightlightScheduleToggle.classList.add('active');
                        nightlightScheduleToggle.setAttribute('aria-checked', 'true');
                        if (nightlightStartInput && nightlightEndInput) {
                            nightlightStartInput.value = scheduleStart;
                            nightlightEndInput.value = scheduleEnd;
                        }
                        if (document.getElementById('nightlight-schedule-controls')) document.getElementById('nightlight-schedule-controls').style.display = 'block';
                    } else {
                        nightlightScheduleToggle.classList.remove('active');
                        nightlightScheduleToggle.setAttribute('aria-checked', 'false');
                        if (document.getElementById('nightlight-schedule-controls')) document.getElementById('nightlight-schedule-controls').style.display = 'none';
                    }
                }
            }

            function saveDisplaySettings() {
                const settings = {
                    brightness: Number(displayBrightness ? displayBrightness.value : 70),
                    nightLight: nightLightToggle ? nightLightToggle.classList.contains('active') : false,
                    nightlightStrength: nightlightStrength ? Number(nightlightStrength.value) : 50,
                    nightlightScheduleEnabled: nightlightScheduleToggle ? nightlightScheduleToggle.classList.contains('active') : false,
                    nightlightScheduleStart: nightlightStartInput ? nightlightStartInput.value : '22:00',
                    nightlightScheduleEnd: nightlightEndInput ? nightlightEndInput.value : '06:00'
                };
                try { localStorage.setItem(DISPLAY_STORAGE_KEY, JSON.stringify(settings)); } catch (e) { /* ignore */ }
            }

            // Initialize from localStorage
            try {
                const saved = JSON.parse(localStorage.getItem(DISPLAY_STORAGE_KEY) || 'null');
                applyDisplaySettings(saved || null);
            } catch (err) {
                applyDisplaySettings(null);
            }
            // Apply schedule immediately on load in case scheduling should enable/disable nightlight
            try { applyScheduleIfNeeded(); } catch (e) { /* ignore */ }

            // Hook up brightness slider
            if (displayBrightness) {
                displayBrightness.addEventListener('input', (e) => {
                    const val = e.target.value;
                    if (brightnessValue) brightnessValue.textContent = `${val}%`;
                    const bFactor = mapSliderToBrightness(val);
                    document.documentElement.style.setProperty('--simulator-brightness', bFactor);
                    saveDisplaySettings();
                });
            }

            // Hook up nightlight toggle
            if (nightLightToggle) {
                nightLightToggle.addEventListener('click', (e) => {
                    const enabled = nightLightToggle.classList.toggle('active');
                    nightLightToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    if (nightlightOverlay) {
                        if (enabled) {
                            nightlightOverlay.style.opacity = '1';
                            const curr = nightlightStrength ? nightlightStrength.value : 50;
                            document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(curr));
                            // sync sub toggle
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.add('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'true');
                            }
                        } else {
                            nightlightOverlay.style.opacity = '0';
                            document.documentElement.style.setProperty('--nightlight-opacity', '0');
                            // sync sub toggle
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.remove('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'false');
                            }
                        }
                    }
                    saveDisplaySettings();
                });
                nightLightToggle.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        nightLightToggle.click();
                    }
                });
            }

            // Subpage toggle: synchronize with main nightLightToggle
            if (nightlightSubToggle) {
                // initial sync
                if (nightLightToggle && nightLightToggle.classList.contains('active')) {
                    nightlightSubToggle.classList.add('active');
                    nightlightSubToggle.setAttribute('aria-checked', 'true');
                }
                nightlightSubToggle.addEventListener('click', () => {
                    const enabled = nightlightSubToggle.classList.toggle('active');
                    nightlightSubToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    // propagate to main toggle
                    if (nightLightToggle) {
                        if (enabled) nightLightToggle.classList.add('active'); else nightLightToggle.classList.remove('active');
                        nightLightToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    }
                    if (nightlightOverlay) {
                        if (enabled) {
                            nightlightOverlay.style.opacity = '1';
                            const curr = nightlightStrength ? nightlightStrength.value : 50;
                            document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(curr));
                        } else {
                            nightlightOverlay.style.opacity = '0';
                            document.documentElement.style.setProperty('--nightlight-opacity', '0');
                        }
                    }
                    saveDisplaySettings();
                });
                nightlightSubToggle.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); nightlightSubToggle.click(); } });
            }

            // Page switching helpers
            const settingsMenuItems = Array.from(document.querySelectorAll('.settings-menu-item[data-page]'));
            const settingsPages = Array.from(document.querySelectorAll('.settings-page'));
            function switchSettingsPage(pageId) {
                // Hide other pages and subpages
                settingsPages.forEach(p => { p.classList.remove('active'); p.style.display = 'none'; });
                const allSubpages = Array.from(document.querySelectorAll('.settings-subpage'));
                allSubpages.forEach(s => { s.style.display = 'none'; s.classList.remove('active'); });
                settingsMenuItems.forEach(mi => mi.classList.remove('active'));
                const target = document.getElementById(pageId);
                if (target) { target.classList.add('active'); target.style.display = 'block'; }
                const menuMatch = settingsMenuItems.find(mi => mi.dataset.page === pageId);
                if (menuMatch) menuMatch.classList.add('active');
                // Restore all sections in case a subpage hid them (e.g., background/font/nightlight)
                try {
                    Array.from(document.querySelectorAll('.setting-section')).forEach(s => {
                        s.style.display = 'block';
                        try { const hdr = s.querySelector('h3'); if (hdr) hdr.style.display = ''; } catch(e){}
                        try { const items = s.querySelectorAll('.setting-item'); items.forEach(i => { i.style.display = ''; }); } catch(e){}
                    });
                } catch (e) {}
                // Ensure specific panels are closed (in case we navigated while they were open)
                try { const bgPanel = document.getElementById('personalization_background_panel'); if (bgPanel) { bgPanel.style.display = 'none'; bgPanel.classList.remove('active'); } } catch(e){}
                try { const fontPanel = document.getElementById('personalization_font_panel'); if (fontPanel) { fontPanel.style.display = 'none'; fontPanel.classList.remove('active'); } } catch(e){}
                try { const nightPanel = document.getElementById('nightlight-settings'); if (nightPanel) nightPanel.style.display = 'none'; } catch(e){}
            }

            // Show / open Nightlight subpage when clicking the setting item (not the toggle)
            if (nightlightItem && nightlightSubpage) {
                const displayPage = document.getElementById('page-display');
                const displaySections = displayPage ? Array.from(displayPage.querySelectorAll('.setting-section')) : [];
                function openNightlightSubpage() {
                    // Hide display's sections instead of the whole page (to keep subpage visible)
                    displaySections.forEach(s => s.style.display = 'none');
                    nightlightSubpage.style.display = 'block';
                    nightlightSubpage.classList.add('active');
                }
                function closeNightlightSubpage() {
                    nightlightSubpage.style.display = 'none';
                    nightlightSubpage.classList.remove('active');
                    // Restore display sections
                    displaySections.forEach(s => s.style.display = 'block');
                }
                nightlightItem.addEventListener('click', (e) => {
                    // if clicked on the toggle or on interactive elements inside, ignore — toggle handled separately
                    if (e.target === nightLightToggle || nightLightToggle.contains(e.target)) return;
                    openNightlightSubpage();
                });
                nightlightItem.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); nightlightItem.click(); } });
                // Back button
                if (nightlightBack) {
                    nightlightBack.addEventListener('click', (e) => { e.preventDefault(); closeNightlightSubpage(); });
                }
            }
            // Sidebar click: switch between settings pages
            settingsMenuItems.forEach(mi => {
                mi.addEventListener('click', (e) => {
                    const page = mi.dataset.page;
                    if (!page) return;
                    switchSettingsPage(page);
                });
                mi.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); mi.click(); } });
            });
            // initialize with the display page selected
            try { switchSettingsPage('page-display'); } catch (e) { /* ignore */ }

            // Nightlight strength slider
            if (nightlightStrength) {
                nightlightStrength.addEventListener('input', (e) => {
                    const val = e.target.value;
                    if (nightlightStrengthValue) nightlightStrengthValue.textContent = `${val}%`;
                    const opacity = mapSliderToNightlightOpacity(val);
                    document.documentElement.style.setProperty('--nightlight-opacity', opacity);
                    // If toggle on, ensure overlay visible
                    if (nightLightToggle && nightLightToggle.classList.contains('active')) {
                        nightlightOverlay.style.opacity = '1';
                    }
                    saveDisplaySettings();
                });
            }

            // Schedule toggle & controls
            function isTimeInRange(startHHMM, endHHMM, now = new Date()) {
                if (!startHHMM || !endHHMM) return false;
                const [sh, sm] = startHHMM.split(':').map(Number);
                const [eh, em] = endHHMM.split(':').map(Number);
                const start = new Date(now);
                start.setHours(sh, sm, 0, 0);
                const end = new Date(now);
                end.setHours(eh, em, 0, 0);
                if (start.getTime() === end.getTime()) return true;
                if (start < end) {
                    return now >= start && now <= end;
                } else {
                    // wraps overnight
                    return now >= start || now <= end;
                }
            }

            function applyScheduleIfNeeded() {
                try {
                    const raw = localStorage.getItem(DISPLAY_STORAGE_KEY) || 'null';
                    const saved = JSON.parse(raw);
                    if (!saved) return;
                    const enabled = !!saved.nightlightScheduleEnabled;
                    const start = saved.nightlightScheduleStart;
                    const end = saved.nightlightScheduleEnd;
                    if (!enabled) return; // nothing to auto-apply
                    const nowShouldBeOn = isTimeInRange(start, end, new Date());
                    if (nightLightToggle && nightLightToggle.classList.contains('active') !== nowShouldBeOn) {
                        if (nowShouldBeOn) {
                            nightLightToggle.classList.add('active');
                            nightLightToggle.setAttribute('aria-checked', 'true');
                            nightlightOverlay.style.opacity = '1';
                            // ensure CSS property set according to strength
                            const curr = nightlightStrength ? nightlightStrength.value : 50;
                            document.documentElement.style.setProperty('--nightlight-opacity', mapSliderToNightlightOpacity(curr));
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.add('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'true');
                            }
                            saveDisplaySettings();
                        } else {
                            nightLightToggle.classList.remove('active');
                            nightLightToggle.setAttribute('aria-checked', 'false');
                            nightlightOverlay.style.opacity = '0';
                            if (nightlightSubToggle) {
                                nightlightSubToggle.classList.remove('active');
                                nightlightSubToggle.setAttribute('aria-checked', 'false');
                            }
                            saveDisplaySettings();
                        }
                    }
                } catch (err) {
                    /* ignore errors */
                }
            }

            if (nightlightScheduleToggle) {
                nightlightScheduleToggle.addEventListener('click', () => {
                    const enabled = nightlightScheduleToggle.classList.toggle('active');
                    nightlightScheduleToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    if (document.getElementById('nightlight-schedule-controls')) document.getElementById('nightlight-schedule-controls').style.display = enabled ? 'block' : 'none';
                    saveDisplaySettings();
                    if (enabled) applyScheduleIfNeeded();
                });
                nightlightScheduleToggle.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); nightlightScheduleToggle.click(); } });
            }

            if (nightlightStartInput) nightlightStartInput.addEventListener('change', () => { saveDisplaySettings(); if (nightlightScheduleToggle && nightlightScheduleToggle.classList.contains('active')) applyScheduleIfNeeded(); });
            if (nightlightEndInput) nightlightEndInput.addEventListener('change', () => { saveDisplaySettings(); if (nightlightScheduleToggle && nightlightScheduleToggle.classList.contains('active')) applyScheduleIfNeeded(); });

            // Check schedule every minute
            setInterval(applyScheduleIfNeeded, 60 * 1000);

            // --- Personalization (背景/主題/色彩/開始/工作列/字型) ---
            const PERSONALIZATION_STORAGE_KEY = 'webos_personalization_v1';
            const personalizationControls = {
                themeMode: document.getElementById('personalization_themeMode'),
                accentColor: document.getElementById('personalization_accentColor'),
                backgroundMode: document.getElementById('personalization_backgroundMode'),
                bgColor: document.getElementById('personalization_bgColor'),
                bgImageUrl: document.getElementById('personalization_bgImageUrl'),
                bgVideoUrl: document.getElementById('personalization_bgVideoUrl'),
                bgVideoUpload: document.getElementById('personalization_bgVideoUpload'),
                bgVideoUploadFile: document.getElementById('personalization_bgVideoUploadFile'),
                bgVideoThumbs: document.getElementById('personalization_bgVideoThumbs'),
                bgReset: document.getElementById('personalization_bgReset'),
                bgPreview: document.getElementById('personalization_bgPreview'),
                bgBrightness: document.getElementById('personalization_bgBrightness'),
                bgBrightnessValue: document.getElementById('personalization_bgBrightnessValue'),
                bgGradient1Start: document.getElementById('personalization_bgGradient1_start'),
                bgGradient1End: document.getElementById('personalization_bgGradient1_end'),
                bgGradient2Start: document.getElementById('personalization_bgGradient2_start'),
                bgGradient2End: document.getElementById('personalization_bgGradient2_end'),
                startShowSuggested: document.getElementById('personalization_startShowSuggested'),
                startShowRecent: document.getElementById('personalization_startShowRecent'),
                taskbarPosition: document.getElementById('personalization_taskbarPosition'),
                taskbarIconSize: document.getElementById('personalization_taskbarIconSize'),
                taskbarIconSizeValue: document.getElementById('personalization_taskbarIconSizeValue'),
                fontSet: document.getElementById('personalization_fontSet'),
                fontSetPanel: document.getElementById('personalization_fontSet_panel'),
                // Prefer the main control if present, otherwise fallback to panel control
                fontScale: document.getElementById('personalization_fontScale') || document.getElementById('personalization_fontScale_panel'),
                fontScalePanel: document.getElementById('personalization_fontScale_panel'),
                fontScaleValue: document.getElementById('personalization_fontScaleValue') || document.getElementById('personalization_fontScaleValue_panel')
            };

            // Remember last applied background (mode and value) so we don't re-run fades for identical values
            let _lastBackgroundMode = null;
            let _lastBackgroundValue = null;
            // If user uploads a local video via File -> ObjectURL, track it so we can revoke it on reset
            let _lastBackgroundVideoObjectUrl = null;

            const DEFAULT_PERSONALIZATION = {
                theme: 'dark',
                accentColor: getComputedStyle(document.documentElement).getPropertyValue('--primary-cyan').trim() || '#00d4ff',
                backgroundMode: 'default',
                backgroundColor: '#0a0a0f',
                backgroundImageURL: '',
                backgroundVideoURL: '',
                backgroundGradient1Start: '#0f2027',
                backgroundGradient1End: '#2c5364',
                backgroundGradient2Start: '#141e30',
                backgroundGradient2End: '#243b55',
                startSuggested: true,
                startRecent: true,
                taskbarPosition: 'center',
                taskbarIconSize: 24,
                fontSet: 'default',
                fontScale: 100
                ,
                backgroundBrightness: 100
            };

            // Helper: Fade the background for a smooth appearance when switching to image backgrounds
            function fadeSetBackground(el, bgValue) {
                if (!el) return;
                try {
                    // Skip if the background hasn't actually changed (avoids unnecessary fade)
                    if (bgValue === _lastBackgroundValue) return;
                    // If document is not visible (e.g., tab background), avoid animation and set immediately
                    if (typeof document !== 'undefined' && document.hidden) {
                        el.style.background = bgValue;
                        _lastBackgroundValue = bgValue;
                        _lastBackgroundMode = 'image';
                        return;
                    }
                    // Prefer to only fade the background layer (desktop-bg) or the desktop element itself
                    const prevTransition = el.style.transition || '';
                    // Ensure opacity transition is available
                    el.style.transition = prevTransition.includes('opacity') ? prevTransition : (prevTransition + (prevTransition ? ', ' : '') + 'opacity 0.32s ease');
                    // fade out
                    el.style.opacity = '0';
                    // After the fade out completes (or short delay), apply the background and fade in
                    // Use a timeout small enough to let opacity animate out
                    setTimeout(() => {
                            el.style.background = bgValue;
                        // force reflow then fade back in
                        // eslint-disable-next-line no-unused-expressions
                        void el.offsetWidth;
                        el.style.opacity = '1';
                    }, 120);
                    // update cached value and mode (image)
                    _lastBackgroundValue = bgValue;
                    _lastBackgroundMode = 'image';
                } catch (e) { try { el.style.background = bgValue; _lastBackgroundValue = bgValue; } catch (err) {} }
            }

            function applyPersonalizationSettings(settings) {
                const s = Object.assign({}, DEFAULT_PERSONALIZATION, settings || {});
                // Theme
                if (s.theme) {
                    document.documentElement.setAttribute('data-theme', s.theme);
                }
                // Accent color
                if (s.accentColor) {
                    document.documentElement.style.setProperty('--primary-cyan', s.accentColor);
                    try { updateAccentPreviews(s.accentColor); } catch (err) {}
                }
                // Background
                const sc = simulatorContainer;
                const deskEl = document.getElementById('desktop');
                const desktopBgEl = document.getElementById('desktop-bg');
                if (s.backgroundMode === 'default') {
                    // 根據主題選擇預設背景
                    const bgDefaultDark = 'radial-gradient(ellipse at bottom, #0a192f 0%, #05080f 100%)';
                    const bgDefaultLight = 'linear-gradient(135deg, #e8f4f8 0%, #d4e6ed 50%, #c8dce6 100%)';
                    const bgDefault = s.theme === 'light' ? bgDefaultLight : bgDefaultDark;
                    if (desktopBgEl) {
                        if (_lastBackgroundMode !== 'default' || _lastBackgroundValue !== bgDefault) {
                            desktopBgEl.style.background = bgDefault;
                            _lastBackgroundMode = 'default';
                            _lastBackgroundValue = bgDefault;
                        }
                        if (sc) sc.style.background = 'none';
                        if (deskEl) deskEl.style.background = 'none';
                    } else {
                        if (sc && (_lastBackgroundMode !== 'default' || _lastBackgroundValue !== bgDefault)) { sc.style.background = bgDefault; _lastBackgroundMode = 'default'; _lastBackgroundValue = bgDefault; }
                        if (deskEl && (_lastBackgroundMode !== 'default' || _lastBackgroundValue !== bgDefault)) { deskEl.style.background = bgDefault; _lastBackgroundMode = 'default'; _lastBackgroundValue = bgDefault; }
                    }
                } else if (s.backgroundMode === 'gradient1') {
                    const g1s = s.backgroundGradient1Start || '#0f2027';
                    const g1e = s.backgroundGradient1End || '#2c5364';
                    const bgG1 = `linear-gradient(135deg, ${g1s} 0%, ${g1e} 100%)`;
                    if (desktopBgEl) {
                        if (_lastBackgroundMode !== 'gradient1' || _lastBackgroundValue !== bgG1) {
                            desktopBgEl.style.background = bgG1;
                            _lastBackgroundMode = 'gradient1';
                            _lastBackgroundValue = bgG1;
                        }
                        if (sc) sc.style.background = 'none';
                        if (deskEl) deskEl.style.background = 'none';
                    } else {
                        if (sc && (_lastBackgroundMode !== 'gradient1' || _lastBackgroundValue !== bgG1)) { sc.style.background = bgG1; _lastBackgroundMode = 'gradient1'; _lastBackgroundValue = bgG1; }
                        if (deskEl && (_lastBackgroundMode !== 'gradient1' || _lastBackgroundValue !== bgG1)) { deskEl.style.background = bgG1; _lastBackgroundMode = 'gradient1'; _lastBackgroundValue = bgG1; }
                    }
                } else if (s.backgroundMode === 'gradient2') {
                    const g2s = s.backgroundGradient2Start || '#141e30';
                    const g2e = s.backgroundGradient2End || '#243b55';
                    const bgG2 = `linear-gradient(135deg, ${g2s} 0%, ${g2e} 100%)`;
                    if (desktopBgEl) {
                        if (_lastBackgroundMode !== 'gradient2' || _lastBackgroundValue !== bgG2) {
                            desktopBgEl.style.background = bgG2;
                            _lastBackgroundMode = 'gradient2';
                            _lastBackgroundValue = bgG2;
                        }
                        if (sc) sc.style.background = 'none';
                        if (deskEl) deskEl.style.background = 'none';
                    } else {
                        if (sc && (_lastBackgroundMode !== 'gradient2' || _lastBackgroundValue !== bgG2)) { sc.style.background = bgG2; _lastBackgroundMode = 'gradient2'; _lastBackgroundValue = bgG2; }
                        if (deskEl && (_lastBackgroundMode !== 'gradient2' || _lastBackgroundValue !== bgG2)) { deskEl.style.background = bgG2; _lastBackgroundMode = 'gradient2'; _lastBackgroundValue = bgG2; }
                    }
                } else if (s.backgroundMode === 'solid') {
                    const bgSolid = s.backgroundColor || '#0a0a0f';
                    if (desktopBgEl) {
                        if (_lastBackgroundMode !== 'solid' || _lastBackgroundValue !== bgSolid) {
                            desktopBgEl.style.background = bgSolid;
                            _lastBackgroundMode = 'solid';
                            _lastBackgroundValue = bgSolid;
                        }
                        if (sc) sc.style.background = 'none';
                        if (deskEl) deskEl.style.background = 'none';
                    } else {
                        if (sc && (_lastBackgroundMode !== 'solid' || _lastBackgroundValue !== bgSolid)) { sc.style.background = bgSolid; _lastBackgroundMode = 'solid'; _lastBackgroundValue = bgSolid; }
                        if (deskEl && (_lastBackgroundMode !== 'solid' || _lastBackgroundValue !== bgSolid)) { deskEl.style.background = bgSolid; _lastBackgroundMode = 'solid'; _lastBackgroundValue = bgSolid; }
                    }
                } else if (s.backgroundMode === 'image' && s.backgroundImageURL) {
                    const bgImageUrl = `url('${s.backgroundImageURL}') center/cover no-repeat`;
                    if (desktopBgEl) {
                        fadeSetBackground(desktopBgEl, bgImageUrl);
                        if (sc) sc.style.background = 'none';
                        if (deskEl) deskEl.style.background = 'none';
                    } else if (deskEl) {
                        // Fallback: set desktop background directly without fading to avoid fading out UI elements
                        if (_lastBackgroundMode !== 'image' || _lastBackgroundValue !== bgImageUrl) {
                            deskEl.style.background = bgImageUrl;
                            _lastBackgroundMode = 'image';
                            _lastBackgroundValue = bgImageUrl;
                        }
                        if (sc) sc.style.background = 'none';
                    } else if (sc) {
                        // Fallback: just set the simulator container background (no fade)
                        if (_lastBackgroundMode !== 'image' || _lastBackgroundValue !== bgImageUrl) {
                            sc.style.background = bgImageUrl;
                            _lastBackgroundMode = 'image';
                            _lastBackgroundValue = bgImageUrl;
                        }
                    }
                }
                else if (s.backgroundMode === 'video' && s.backgroundVideoURL) {
                    const videoEl = document.getElementById('desktop-video');
                    if (videoEl) {
                        try {
                            // If the value hasn't changed, do nothing
                            if (_lastBackgroundMode !== 'video' || _lastBackgroundValue !== s.backgroundVideoURL) {
                                // Pause & clear src when switching types to avoid audio or network overlap
                                try { if (!videoEl.paused) videoEl.pause(); } catch(e){}
                                videoEl.src = s.backgroundVideoURL;
                                videoEl.muted = true;
                                videoEl.loop = true;
                                videoEl.setAttribute('playsinline', '');
                                // Ensure it updates brightness from var
                                // Keep brightness controlled via CSS var --background-brightness
                                videoEl.style.display = '';
                                try { videoEl.play().catch(e => {}); } catch (e) {}
                                // fade in video background
                                void videoEl.offsetWidth; // reflow
                                videoEl.style.opacity = '1';
                                _lastBackgroundMode = 'video';
                                _lastBackgroundValue = s.backgroundVideoURL;
                            }
                        } catch (err) {
                            console.warn('Failed to apply video background', err);
                        }
                    }
                    if (desktopBgEl) desktopBgEl.style.background = 'none';
                    if (sc) sc.style.background = 'none';
                    if (deskEl) deskEl.style.background = 'none';
                } else {
                    // When mode is not video, hide the video element to avoid visual overlap and stop playback
                    const videoEl = document.getElementById('desktop-video');
                    if (videoEl) {
                        try { videoEl.style.opacity = '0'; setTimeout(() => { try { videoEl.pause(); videoEl.removeAttribute('src'); videoEl.load(); } catch(e){}; videoEl.style.display = 'none'; }, 300); } catch(e){}
                        // revoke any object URL used previously
                        try { if (_lastBackgroundVideoObjectUrl) { URL.revokeObjectURL(_lastBackgroundVideoObjectUrl); _lastBackgroundVideoObjectUrl = null; } } catch(e){}
                    }
                }
                // Ensure video is hidden when not using video mode (this runs regardless of which branch matched above)
                if (s.backgroundMode !== 'video') {
                    const videoEl = document.getElementById('desktop-video');
                    if (videoEl) {
                        try { videoEl.style.opacity = '0'; setTimeout(() => { try { videoEl.pause(); videoEl.removeAttribute('src'); videoEl.load(); } catch(e){}; videoEl.style.display = 'none'; }, 300); } catch(e){}
                        try { if (_lastBackgroundVideoObjectUrl) { URL.revokeObjectURL(_lastBackgroundVideoObjectUrl); _lastBackgroundVideoObjectUrl = null; } } catch(e){}
                        // Only clear the cached mode/value when we were previously using a video
                        // so that unrelated changes (eg. changing brightness or taskbar/icon sizes)
                        // don't cause the background to re-apply and trigger the fade animation.
                        if (_lastBackgroundMode === 'video') {
                            _lastBackgroundMode = null;
                            _lastBackgroundValue = null;
                        }
                    }
                }
                // Update background preview in personalization panel
                try {
                    const bp = document.getElementById('personalization_bgPreview');
                    if (bp) {
                        if (s.backgroundMode === 'default') {
                            bp.style.background = 'radial-gradient(ellipse at bottom, #0a192f 0%, #05080f 100%)';
                        } else if (s.backgroundMode === 'gradient1') {
                            const g1s = s.backgroundGradient1Start || '#0f2027';
                            const g1e = s.backgroundGradient1End || '#2c5364';
                            bp.style.background = `linear-gradient(135deg, ${g1s} 0%, ${g1e} 100%)`;
                        } else if (s.backgroundMode === 'gradient2') {
                            const g2s = s.backgroundGradient2Start || '#141e30';
                            const g2e = s.backgroundGradient2End || '#243b55';
                            bp.style.background = `linear-gradient(135deg, ${g2s} 0%, ${g2e} 100%)`;
                        } else if (s.backgroundMode === 'solid') {
                            bp.style.background = s.backgroundColor || '#0a0a0f';
                        } else if (s.backgroundMode === 'image' && s.backgroundImageURL) {
                            bp.style.background = `url('${s.backgroundImageURL}') center/cover no-repeat`;
                        } else if (s.backgroundMode === 'video' && s.backgroundVideoURL) {
                            // For preview, try to use a small inline <video> element in the personalization preview
                            try {
                                // remove any background image that might have been set
                                bp.style.background = 'none';
                                let pv = document.getElementById('personalization_bgPreviewVideo');
                                if (!pv) {
                                    pv = document.createElement('video');
                                    pv.id = 'personalization_bgPreviewVideo';
                                    pv.className = 'bg-preview-video';
                                    pv.setAttribute('muted', '');
                                    pv.setAttribute('playsinline', '');
                                    pv.setAttribute('loop', '');
                                    pv.setAttribute('preload', 'metadata');
                                    pv.controls = false;
                                    pv.setAttribute('aria-hidden', 'true');
                                    pv.style.display = 'block';
                                    pv.style.opacity = '0';
                                    pv.style.transition = 'opacity 180ms ease';
                                    pv.muted = true;
                                    pv.autoplay = true;
                                    pv.loop = true;
                                    pv.playsInline = true;
                                    pv.preload = 'metadata';
                                    try { pv.crossOrigin = 'anonymous'; } catch (e) {}
                                    try { pv.style.borderRadius = bp.style.borderRadius || '6px'; } catch(e) {}
                                    // clear any existing children and append the video
                                    while (bp.firstChild) bp.removeChild(bp.firstChild);
                                    bp.appendChild(pv);
                                }
                                // Update src and try to play
                                if (pv.src !== s.backgroundVideoURL) {
                                    try { if (!pv.paused) pv.pause(); } catch(e) {}
                                    pv.src = s.backgroundVideoURL;
                                    pv.load();
                                }
                                // If video can play, fade it in; otherwise show fallback bg
                                pv.addEventListener('canplay', function onceCanPlay() {
                                    try { pv.style.opacity = '1'; } catch (e) {}
                                }, { once: true });
                                pv.addEventListener('error', function onceError() {
                                    try { pv.style.opacity = '0'; pv.pause(); } catch (e) {}
                                    // fallback to neutral bg
                                    bp.style.background = 'linear-gradient(90deg, #000000 0%, #111111 100%)';
                                }, { once: true });
                                try { pv.play().catch(()=>{}); } catch(e) {}
                            } catch (err) {
                                // fallback to neutral bg if video preview fails
                                bp.style.background = 'linear-gradient(90deg, #000000 0%, #111111 100%)';
                            }
                            // Could add a small <video> preview element if desired - keep it simple for now.
                        }
                    }
                } catch (err) {}
                        // Ensure video preview is removed/hidden when not in video mode
                        try {
                            if (s.backgroundMode !== 'video') {
                                const pv = document.getElementById('personalization_bgPreviewVideo');
                                if (pv && pv.parentElement) {
                                    try { pv.pause(); } catch(e){}
                                    try { pv.removeAttribute('src'); pv.load(); } catch(e){}
                                    // remove video element entirely so background image remains visible when switching back
                                    pv.parentElement.removeChild(pv);
                                }
                            }
                        } catch (err) {}
                // Background brightness: apply to new desktop background layer and reflect in UI
                try {
                    const bgBrightness = typeof s.backgroundBrightness !== 'undefined' ? s.backgroundBrightness : 100;
                    document.documentElement.style.setProperty('--background-brightness', (bgBrightness / 100).toFixed(3));
                    // For better performance and smoother UI, control a dimming overlay instead of only using filter()
                    const overlayVal = (1 - (bgBrightness / 100));
                    document.documentElement.style.setProperty('--background-overlay', overlayVal.toFixed(3));
                    if (personalizationControls.bgBrightness) {
                        personalizationControls.bgBrightness.value = bgBrightness;
                    }
                    if (personalizationControls.bgBrightnessValue) {
                        personalizationControls.bgBrightnessValue.textContent = `${bgBrightness}%`;
                    }
                } catch (e) { /* ignore */ }
                // start menu suggested/recent
                const recommendedList = document.querySelector('.recommended-list');
                if (recommendedList) {
                    recommendedList.style.display = s.startSuggested ? '' : 'none';
                }
                // TODO: 'recent' may correspond to some UI; hide if present
                const recentEls = document.querySelectorAll('.start-menu .recent-item');
                recentEls.forEach(e => e.style.display = s.startRecent ? '' : 'none');
                // Taskbar position
                const tb = taskbar;
                tb.classList.remove('left','center','right');
                tb.classList.add(s.taskbarPosition);
                // Icon size
                if (s.taskbarIconSize) document.documentElement.style.setProperty('--taskbar-icon-size', `${s.taskbarIconSize}px`);
                // Fonts
                if (s.fontSet) {
                    if (s.fontSet === 'default') {
                        document.documentElement.style.setProperty('--font-display', "'Orbitron', monospace");
                        document.documentElement.style.setProperty('--font-body', "'Rajdhani', sans-serif");
                        document.documentElement.style.setProperty('--font-ui', "'Noto Sans TC', sans-serif");
                    } else if (s.fontSet === 'system') {
                        document.documentElement.style.setProperty('--font-display', 'system-ui, -apple-system, "Segoe UI"');
                        document.documentElement.style.setProperty('--font-body', 'system-ui, -apple-system, "Segoe UI"');
                        document.documentElement.style.setProperty('--font-ui', 'system-ui, -apple-system, "Segoe UI"');
                    } else if (s.fontSet === 'serif') {
                        document.documentElement.style.setProperty('--font-display', 'Georgia, serif');
                        document.documentElement.style.setProperty('--font-body', 'Georgia, serif');
                        document.documentElement.style.setProperty('--font-ui', 'Georgia, serif');
                    } else if (s.fontSet === 'mono') {
                        document.documentElement.style.setProperty('--font-display', 'ui-monospace, SFMono-Regular, Menlo, Monaco, monospace');
                        document.documentElement.style.setProperty('--font-body', 'ui-monospace, SFMono-Regular, Menlo, Monaco, monospace');
                        document.documentElement.style.setProperty('--font-ui', 'ui-monospace, SFMono-Regular, Menlo, Monaco, monospace');
                    }
                }
                // font scale
                if (s.fontScale) {
                    const scale = (s.fontScale / 100).toFixed(2);
                    document.documentElement.style.setProperty('--font-scale', scale);
                }
                // reflect values to controls
                try {
                    if (personalizationControls.themeMode) personalizationControls.themeMode.value = s.theme;
                    if (personalizationControls.accentColor) personalizationControls.accentColor.value = s.accentColor;
                    if (personalizationControls.backgroundMode) personalizationControls.backgroundMode.value = s.backgroundMode;
                    if (personalizationControls.bgColor) personalizationControls.bgColor.value = s.backgroundColor;
                    if (personalizationControls.bgImageUrl) personalizationControls.bgImageUrl.value = s.backgroundImageURL;
                    if (personalizationControls.taskbarPosition) personalizationControls.taskbarPosition.value = s.taskbarPosition;
                    if (personalizationControls.taskbarIconSize) personalizationControls.taskbarIconSize.value = s.taskbarIconSize;
                    if (personalizationControls.taskbarIconSizeValue) personalizationControls.taskbarIconSizeValue.textContent = s.taskbarIconSize + 'px';
                    if (personalizationControls.fontSet) personalizationControls.fontSet.value = s.fontSet;
                    if (personalizationControls.fontScale) personalizationControls.fontScale.value = s.fontScale;
                    if (personalizationControls.fontScaleValue) personalizationControls.fontScaleValue.textContent = s.fontScale + '%';
                    // Also set panel controls when available
                    const fsPanel = document.getElementById('personalization_fontSet_panel'); if (fsPanel) fsPanel.value = s.fontSet;
                    const fsScalePanel = document.getElementById('personalization_fontScale_panel'); if (fsScalePanel) fsScalePanel.value = s.fontScale, (document.getElementById('personalization_fontScaleValue_panel') && (document.getElementById('personalization_fontScaleValue_panel').textContent = s.fontScale + '%'));
                    const bgModePanel = document.getElementById('personalization_backgroundMode'); if (bgModePanel) bgModePanel.value = s.backgroundMode;
                    const bgG1sPanel = document.getElementById('personalization_bgGradient1_start'); if (bgG1sPanel) bgG1sPanel.value = s.backgroundGradient1Start || '#0f2027';
                    const bgG1ePanel = document.getElementById('personalization_bgGradient1_end'); if (bgG1ePanel) bgG1ePanel.value = s.backgroundGradient1End || '#2c5364';
                    const bgG2sPanel = document.getElementById('personalization_bgGradient2_start'); if (bgG2sPanel) bgG2sPanel.value = s.backgroundGradient2Start || '#141e30';
                    const bgG2ePanel = document.getElementById('personalization_bgGradient2_end'); if (bgG2ePanel) bgG2ePanel.value = s.backgroundGradient2End || '#243b55';
                    const bgColorPanel = document.getElementById('personalization_bgColor'); if (bgColorPanel) bgColorPanel.value = s.backgroundColor;
                    const bgImagePanel = document.getElementById('personalization_bgImageUrl'); if (bgImagePanel) bgImagePanel.value = s.backgroundImageURL;
                    const bgVideoPanel = document.getElementById('personalization_bgVideoUrl'); if (bgVideoPanel) bgVideoPanel.value = s.backgroundVideoURL || '';
                } catch (err) { /* ignore UI update errors */ }
                // show/hide bg controls depending on mode
                try {
                    const mode = s.backgroundMode;
                    if (personalizationControls.bgColor) personalizationControls.bgColor.style.display = mode === 'solid' ? '' : 'none';
                    if (personalizationControls.bgImageUrl) personalizationControls.bgImageUrl.style.display = mode === 'image' ? '' : 'none';
                    if (personalizationControls.bgGradient1Start) personalizationControls.bgGradient1Start.style.display = mode === 'gradient1' ? '' : 'none';
                    if (personalizationControls.bgGradient1End) personalizationControls.bgGradient1End.style.display = mode === 'gradient1' ? '' : 'none';
                    if (personalizationControls.bgGradient2Start) personalizationControls.bgGradient2Start.style.display = mode === 'gradient2' ? '' : 'none';
                    if (personalizationControls.bgGradient2End) personalizationControls.bgGradient2End.style.display = mode === 'gradient2' ? '' : 'none';
                    const solidItem = document.getElementById('personalization_background_solid');
                    const imageItem = document.getElementById('personalization_background_image');
                    const gradient1Item = document.getElementById('personalization_background_gradient1');
                    const gradient2Item = document.getElementById('personalization_background_gradient2');
                    const videoItem = document.getElementById('personalization_background_video');
                    if (solidItem) solidItem.style.display = mode === 'solid' ? 'flex' : 'none';
                    if (imageItem) imageItem.style.display = mode === 'image' ? 'flex' : 'none';
                    if (videoItem) videoItem.style.display = mode === 'video' ? 'flex' : 'none';
                    if (gradient1Item) gradient1Item.style.display = mode === 'gradient1' ? 'flex' : 'none';
                    if (gradient2Item) gradient2Item.style.display = mode === 'gradient2' ? 'flex' : 'none';
                    // reflect start menu toggles status
                    if (personalizationControls.startShowSuggested) {
                        if (s.startSuggested) personalizationControls.startShowSuggested.classList.add('active'); else personalizationControls.startShowSuggested.classList.remove('active');
                        personalizationControls.startShowSuggested.setAttribute('aria-checked', s.startSuggested ? 'true' : 'false');
                    }
                    if (personalizationControls.startShowRecent) {
                        if (s.startRecent) personalizationControls.startShowRecent.classList.add('active'); else personalizationControls.startShowRecent.classList.remove('active');
                        personalizationControls.startShowRecent.setAttribute('aria-checked', s.startRecent ? 'true' : 'false');
                    }
                } catch (err) { /* ignore */ }
                // Mirror to window-level controls (if present)
                try {
                    const tmw = document.getElementById('personalization_themeMode_window'); if (tmw) tmw.value = s.theme;
                    const acw = document.getElementById('personalization_accentColor_window'); if (acw) acw.value = s.accentColor;
                    const bmw = document.getElementById('personalization_backgroundMode_window'); if (bmw) bmw.value = s.backgroundMode;
                    const bcw = document.getElementById('personalization_bgColor_window'); if (bcw) bcw.value = s.backgroundColor;
                    const biw = document.getElementById('personalization_bgImageUrl_window'); if (biw) biw.value = s.backgroundImageURL;
                    const taskSizeW = document.getElementById('personalization_taskbarIconSize_window'); if (taskSizeW) taskSizeW.value = s.taskbarIconSize;
                    const taskSizeValW = document.getElementById('personalization_taskbarIconSizeValue_window'); if (taskSizeValW) taskSizeValW.textContent = s.taskbarIconSize + 'px';
                } catch (err) { /* ignore */ }
                // Also sync the general/select themeMode in main display settings if present
                try {
                    const mainThemeSelect = document.getElementById('themeMode');
                    if (mainThemeSelect) mainThemeSelect.value = s.theme;
                } catch (err) {}
            }

            function savePersonalizationSettings(settings) {
                try { localStorage.setItem(PERSONALIZATION_STORAGE_KEY, JSON.stringify(settings)); } catch (e) {}
            }

            function loadPersonalizationSettings() {
                try { return JSON.parse(localStorage.getItem(PERSONALIZATION_STORAGE_KEY) || 'null'); } catch (e) { return null; }
            }

            // Attach events for personalization controls (only if present)
            if (personalizationControls.themeMode) {
                personalizationControls.themeMode.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.theme = e.target.value;
                    // 當主題改變且背景模式為 default 時，強制重新計算背景
                    if (s.backgroundMode === 'default') {
                        _lastBackgroundMode = null;
                        _lastBackgroundValue = null;
                    }
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.accentColor) {
                personalizationControls.accentColor.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.accentColor = e.target.value;
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                    try { updateAccentPreviews(e.target.value); } catch (err) {}
                });
            }

            // Accent color preview helper for main and window-level controls
            function updateAccentPreviews(color) {
                try { document.getElementById('personalization_accentColor_preview').style.backgroundColor = color; } catch(e){}
                try { document.getElementById('personalization_accentColor_window_preview').style.backgroundColor = color; } catch(e){}
            }
            if (personalizationControls.backgroundMode) {
                personalizationControls.backgroundMode.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundMode = e.target.value;
                    // show/hide color or URL inputs
                    if (e.target.value === 'solid') {
                        personalizationControls.bgColor.style.display = '';
                        personalizationControls.bgImageUrl.style.display = 'none';
                    } else if (e.target.value === 'image') {
                        personalizationControls.bgColor.style.display = 'none';
                        personalizationControls.bgImageUrl.style.display = '';
                    } else if (e.target.value === 'video') {
                        personalizationControls.bgColor.style.display = 'none';
                        personalizationControls.bgImageUrl.style.display = 'none';
                        // No direct main input for video here; the bgVideoUrl is available in the panel
                        try { const videoItem = document.getElementById('personalization_background_video'); if (videoItem) videoItem.style.display = 'flex'; } catch(e){}
                    } else if (e.target.value === 'gradient1') {
                        personalizationControls.bgColor.style.display = 'none';
                        personalizationControls.bgImageUrl.style.display = 'none';
                        try { document.getElementById('personalization_background_gradient1').style.display = 'flex'; } catch(e){}
                    } else if (e.target.value === 'gradient2') {
                        personalizationControls.bgColor.style.display = 'none';
                        personalizationControls.bgImageUrl.style.display = 'none';
                        try { document.getElementById('personalization_background_gradient2').style.display = 'flex'; } catch(e){}
                    } else {
                        personalizationControls.bgColor.style.display = 'none';
                        personalizationControls.bgImageUrl.style.display = 'none';
                    }
                    // also control the background panel's specific sections
                    try {
                        const solidItem = document.getElementById('personalization_background_solid');
                        const imageItem = document.getElementById('personalization_background_image');
                        const gradient1Item = document.getElementById('personalization_background_gradient1');
                        const gradient2Item = document.getElementById('personalization_background_gradient2');
                        if (solidItem) solidItem.style.display = e.target.value === 'solid' ? 'flex' : 'none';
                        if (imageItem) imageItem.style.display = e.target.value === 'image' ? 'flex' : 'none';
                        if (gradient1Item) gradient1Item.style.display = e.target.value === 'gradient1' ? 'flex' : 'none';
                        if (gradient2Item) gradient2Item.style.display = e.target.value === 'gradient2' ? 'flex' : 'none';
                    } catch (err) {}
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgColor) {
                personalizationControls.bgColor.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundColor = e.target.value;
                    s.backgroundMode = 'solid';
                    personalizationControls.backgroundMode.value = 'solid';
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgGradient1Start) {
                personalizationControls.bgGradient1Start.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundGradient1Start = e.target.value;
                    s.backgroundMode = 'gradient1';
                    personalizationControls.backgroundMode.value = 'gradient1';
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgGradient1End) {
                personalizationControls.bgGradient1End.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundGradient1End = e.target.value;
                    s.backgroundMode = 'gradient1';
                    personalizationControls.backgroundMode.value = 'gradient1';
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgGradient2Start) {
                personalizationControls.bgGradient2Start.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundGradient2Start = e.target.value;
                    s.backgroundMode = 'gradient2';
                    personalizationControls.backgroundMode.value = 'gradient2';
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgGradient2End) {
                personalizationControls.bgGradient2End.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundGradient2End = e.target.value;
                    s.backgroundMode = 'gradient2';
                    personalizationControls.backgroundMode.value = 'gradient2';
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgImageUrl) {
                personalizationControls.bgImageUrl.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.backgroundImageURL = e.target.value;
                    s.backgroundMode = 'image';
                    personalizationControls.backgroundMode.value = 'image';
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.bgReset) {
                personalizationControls.bgReset.addEventListener('click', () => {
                    const s = Object.assign({}, DEFAULT_PERSONALIZATION);
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.taskbarPosition) {
                personalizationControls.taskbarPosition.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.taskbarPosition = e.target.value;
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.taskbarIconSize) {
                personalizationControls.taskbarIconSize.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.taskbarIconSize = Number(e.target.value);
                    personalizationControls.taskbarIconSizeValue.textContent = s.taskbarIconSize + 'px';
                    // Live preview only: apply settings but don't write to storage on every input event
                    applyPersonalizationSettings(s);
                });
                // Save final user preference on change (when slider released)
                personalizationControls.taskbarIconSize.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.taskbarIconSize = Number(e.target.value);
                    savePersonalizationSettings(s);
                });
            }
                if (personalizationControls.bgBrightness) {
                    // While the user is sliding, only update overlay (cheap compositing change)
                    personalizationControls.bgBrightness.addEventListener('input', (e) => {
                        const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                        const val = Number(e.target.value);
                        s.backgroundBrightness = val;
                        if (personalizationControls.bgBrightnessValue) personalizationControls.bgBrightnessValue.textContent = val + '%';
                        // apply overlay alpha for smoother updates without invoking the full personalization flow
                        // Since brightness changes should not re-apply or re-fade background, update only CSS vars to avoid heavy operations
                        document.documentElement.style.setProperty('--background-overlay', (1 - (val / 100)).toFixed(3));
                        // Do not call applyPersonalizationSettings or save on every input to avoid reflows and localStorage churn
                    });
                    // On release/final change, update the filter and save so other code depending on the final value remains compatible
                    personalizationControls.bgBrightness.addEventListener('change', (e) => {
                        const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                        const val = Number(e.target.value);
                        s.backgroundBrightness = val;
                        if (personalizationControls.bgBrightnessValue) personalizationControls.bgBrightnessValue.textContent = val + '%';
                        // set final filter (less frequent, avoids repeated repainting while dragging)
                        document.documentElement.style.setProperty('--background-brightness', (val / 100).toFixed(3));
                        // keep overlay in sync
                        document.documentElement.style.setProperty('--background-overlay', (1 - (val / 100)).toFixed(3));
                        applyPersonalizationSettings(s);
                        savePersonalizationSettings(s);
                    });
                }
            if (personalizationControls.fontSet) {
                personalizationControls.fontSet.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.fontSet = e.target.value;
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (personalizationControls.fontScale) {
                personalizationControls.fontScale.addEventListener('input', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.fontScale = Number(e.target.value);
                    personalizationControls.fontScaleValue.textContent = s.fontScale + '%';
                    // Live preview only; avoid saving on each slider move
                    applyPersonalizationSettings(s);
                });
                personalizationControls.fontScale.addEventListener('change', (e) => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    s.fontScale = Number(e.target.value);
                    savePersonalizationSettings(s);
                });
            }

            // Initialize personalization at startup
            try {
                const savedPersonalization = loadPersonalizationSettings();
                applyPersonalizationSettings(savedPersonalization || DEFAULT_PERSONALIZATION);
            } catch (err) { /* ignore */ }

            // Setup toggle controls for start suggestions & recent
            const pStartSuggested = document.getElementById('personalization_startShowSuggested');
            const pStartRecent = document.getElementById('personalization_startShowRecent');
            function syncStartToggles() {
                const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                if (pStartSuggested) {
                    if (s.startSuggested) pStartSuggested.classList.add('active'); else pStartSuggested.classList.remove('active');
                }
                if (pStartRecent) {
                    if (s.startRecent) pStartRecent.classList.add('active'); else pStartRecent.classList.remove('active');
                }
            }
            if (pStartSuggested) {
                pStartSuggested.addEventListener('click', () => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    const enabled = pStartSuggested.classList.toggle('active');
                    pStartSuggested.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    s.startSuggested = enabled;
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            if (pStartRecent) {
                pStartRecent.addEventListener('click', () => {
                    const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                    const enabled = pStartRecent.classList.toggle('active');
                    pStartRecent.setAttribute('aria-checked', enabled ? 'true' : 'false');
                    s.startRecent = enabled;
                    applyPersonalizationSettings(s);
                    savePersonalizationSettings(s);
                });
            }
            syncStartToggles();

            // Window-level personalization controls: mirror behavior to main controls
            const themeModeWindow = document.getElementById('personalization_themeMode_window');
            const accentColorWindow = document.getElementById('personalization_accentColor_window');
            const bgModeWindow = document.getElementById('personalization_backgroundMode_window');
            const bgColorWindow = document.getElementById('personalization_bgColor_window');
            const bgImageUrlWindow = document.getElementById('personalization_bgImageUrl_window');
            const taskbarIconSizeWindow = document.getElementById('personalization_taskbarIconSize_window');
            const taskbarIconSizeValueWindow = document.getElementById('personalization_taskbarIconSizeValue_window');
            // When window-level control changes, update the main control (and saved settings)
            function mirrorToMain(mainEl, val) { if (!mainEl) return; try { if (mainEl.tagName === 'SELECT' || mainEl.tagName === 'INPUT') mainEl.value = val; mainEl.dispatchEvent(new Event('input')); mainEl.dispatchEvent(new Event('change')); } catch(e) {} }
            if (themeModeWindow && personalizationControls.themeMode) {
                themeModeWindow.addEventListener('change', (e) => mirrorToMain(personalizationControls.themeMode, e.target.value));
            }
            if (accentColorWindow && personalizationControls.accentColor) {
                accentColorWindow.addEventListener('input', (e) => mirrorToMain(personalizationControls.accentColor, e.target.value));
            }
            if (bgModeWindow && personalizationControls.backgroundMode) {
                bgModeWindow.addEventListener('change', (e) => mirrorToMain(personalizationControls.backgroundMode, e.target.value));
            }
            if (bgColorWindow && personalizationControls.bgColor) {
                bgColorWindow.addEventListener('input', (e) => mirrorToMain(personalizationControls.bgColor, e.target.value));
            }
            if (bgImageUrlWindow && personalizationControls.bgImageUrl) {
                bgImageUrlWindow.addEventListener('change', (e) => mirrorToMain(personalizationControls.bgImageUrl, e.target.value));
            }
            if (taskbarIconSizeWindow && personalizationControls.taskbarIconSize) {
                taskbarIconSizeWindow.addEventListener('input', (e) => {
                    mirrorToMain(personalizationControls.taskbarIconSize, e.target.value);
                    if (taskbarIconSizeValueWindow) taskbarIconSizeValueWindow.textContent = e.target.value + 'px';
                });
            }

            // Sync the main themeMode select to personalization when user changes it
            const themeModeMainSelect = document.getElementById('themeMode');
            if (themeModeMainSelect) {
                themeModeMainSelect.addEventListener('change', (e) => {
                    const val = e.target.value;
                    if (personalizationControls.themeMode) {
                        personalizationControls.themeMode.value = val;
                        personalizationControls.themeMode.dispatchEvent(new Event('change'));
                    }
                });
            }

            // --- Right-side settings panel: open/close panels (background, fonts) ---
            const personalizationSection = document.querySelector('.setting-section h3') && document.querySelector('.setting-section h3').parentElement;
            const personalizationPage = document.getElementById('page-personalization');
            const personalizationSections = personalizationPage ? Array.from(personalizationPage.querySelectorAll('.setting-section')) : [];
            // Find the whole setting-item (background) to act as the open button
            const bgSettingItem = Array.from(document.querySelectorAll('.setting-item')).find(el => el.querySelector('#personalization_bgPreview'));
            const bgPanel = document.getElementById('personalization_background_panel');
            const bgPanelBack = document.getElementById('personalization_background_back');
            if (bgPanel) {
                const localSection = bgPanel.closest('.setting-section') || document.querySelector('.setting-section');
                function hideLocalSettingItems() {
                    try {
                        const items = localSection.querySelectorAll(':scope > .setting-item');
                        if (items && items.length) { items.forEach(i => i.style.display = 'none'); return; }
                    } catch (e) {}
                    // Fallback: filter direct children
                    Array.from(localSection.children).forEach(c => { if (c.classList && c.classList.contains('setting-item')) c.style.display = 'none'; });
                    // Also hide the header/title if present
                    try { const hdr = localSection.querySelector('h3'); if (hdr) hdr.style.display = 'none'; } catch(e) {}
                }
                function showLocalSettingItems() {
                    try {
                        const items = localSection.querySelectorAll(':scope > .setting-item');
                        if (items && items.length) { items.forEach(i => i.style.display = 'flex'); return; }
                    } catch (e) {}
                    Array.from(localSection.children).forEach(c => { if (c.classList && c.classList.contains('setting-item')) c.style.display = 'flex'; });
                    // Also show the header/title if present
                    try { const hdr = localSection.querySelector('h3'); if (hdr) hdr.style.display = ''; } catch(e) {}
                }
                function openBgPanel() {
                    // hide personalization page sections and show the panel (matches Nightlight behavior)
                    personalizationSections.forEach(s => s.style.display = 'none');
                    bgPanel.style.display = 'block';
                    bgPanel.classList.add('active');
                }
                function closeBgPanel() {
                    personalizationSections.forEach(s => s.style.display = 'block');
                    bgPanel.style.display = 'none';
                    bgPanel.classList.remove('active');
                }
                if (bgSettingItem) {
                    // Make the entire .setting-item clickable and keyboard-accessible
                    bgSettingItem.setAttribute('role', 'button');
                    bgSettingItem.setAttribute('tabindex', '0');
                    bgSettingItem.addEventListener('click', (e) => {
                        if (e.target && (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON')) return;
                        openBgPanel();
                    });
                    bgSettingItem.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); bgSettingItem.click(); } });
                }
                if (bgPanelBack) bgPanelBack.addEventListener('click', (e) => { e.preventDefault(); closeBgPanel(); });
                // (previous explicit edit button logic removed; using .setting-item clickable approach above)
                // Setup thumbnail clicks and upload handlers inside bg panel
                try {
                    // Populate thumbnails: use a hard-coded list of wallpaper images (do not use wallpaper_index.json)
                    async function loadWallpaperIndex() {
                        return ['assets/wallpaper/NS-V5-2nd.png', 'assets/wallpaper/NS-V5-D.png', 'assets/wallpaper/NS-V5-E.png', 'assets/wallpaper/NS-V5-W.png'];
                    }
                    const thumbsContainer = document.getElementById('personalization_bgThumbs');
                    if (thumbsContainer) {
                        thumbsContainer.innerHTML = '';
                        // load wallpaper index (if available)
                        loadWallpaperIndex().then(list => {
                            list.forEach(src => {
                            try {
                                const thumb = document.createElement('div');
                                thumb.className = 'bg-thumb';
                                thumb.setAttribute('data-url', src);
                                thumb.style.width = '160px';
                                thumb.style.height = '90px';
                                thumb.style.borderRadius = '6px';
                                thumb.style.background = `url('${src}') center/cover no-repeat`;
                                thumb.style.border = '1px solid rgba(255,255,255,0.06)';
                                thumb.style.cursor = 'pointer';
                                thumbsContainer.appendChild(thumb);
                                thumb.addEventListener('click', (ev) => {
                                    const url = thumb.getAttribute('data-url');
                                    if (personalizationControls.bgImageUrl) {
                                        personalizationControls.bgImageUrl.value = url;
                                        personalizationControls.bgImageUrl.dispatchEvent(new Event('change'));
                                    }
                                });
                            } catch (e) {}
                            });
                        });
                    }
                    const uploadBtn = document.getElementById('personalization_bgUpload');
                    const uploadFile = document.getElementById('personalization_bgUploadFile');
                    if (uploadBtn && uploadFile) {
                        uploadBtn.addEventListener('click', () => uploadFile.click());
                        uploadFile.addEventListener('change', (e) => {
                            const f = e.target.files && e.target.files[0]; if (!f) return;
                            // Limit file size to avoid localStorage overflow (1.5MB)
                            const MAX_UPLOAD_BYTES = 1.5 * 1024 * 1024;
                            if (f.size > MAX_UPLOAD_BYTES) { alert('圖片過大，請選擇小於 1.5MB 的檔案。'); return; }
                            const reader = new FileReader();
                            reader.onload = function(ev){
                                if (personalizationControls.bgImageUrl) {
                                    personalizationControls.bgImageUrl.value = ev.target.result;
                                    personalizationControls.bgImageUrl.dispatchEvent(new Event('change'));
                                }
                            };
                            reader.readAsDataURL(f);
                        });
                    }
                    // Video thumbnails & upload handlers
                    try {
                        async function loadVideoIndex() { return ['assets/videos/test.mp4']; }
                        const vidsContainer = document.getElementById('personalization_bgVideoThumbs');
                        if (vidsContainer) {
                            vidsContainer.innerHTML = '';
                            loadVideoIndex().then(list => {
                                list.forEach(src => {
                                    try {
                                        const thumb = document.createElement('div');
                                        thumb.className = 'bg-thumb';
                                        thumb.setAttribute('data-url', src);
                                        thumb.style.width = '160px';
                                        thumb.style.height = '90px';
                                        thumb.style.borderRadius = '6px';
                                        thumb.style.overflow = 'hidden';
                                        thumb.style.cursor = 'pointer';
                                        // Use a small preview poster using the first frame - fallback to a poster icon
                                        const vid = document.createElement('video');
                                        vid.src = src;
                                        vid.muted = true;
                                        vid.preload = 'metadata';
                                        vid.style.width = '100%';
                                        vid.style.height = '100%';
                                        vid.style.objectFit = 'cover';
                                        // Try to seek a little to get a frame (best-effort)
                                        vid.addEventListener('loadeddata', () => {
                                            try { vid.currentTime = Math.min(0.1, vid.duration || 0); } catch (e) {}
                                        });
                                        thumb.appendChild(vid);
                                        vidsContainer.appendChild(thumb);
                                        thumb.addEventListener('click', () => {
                                            const url = thumb.getAttribute('data-url');
                                            if (personalizationControls.bgVideoUrl) {
                                                personalizationControls.bgVideoUrl.value = url;
                                                personalizationControls.bgVideoUrl.dispatchEvent(new Event('change'));
                                            }
                                        });
                                    } catch (e) {}
                                });
                            });
                        }
                        const uploadVidBtn = document.getElementById('personalization_bgVideoUpload');
                        const uploadVidFile = document.getElementById('personalization_bgVideoUploadFile');
                        const resetVidBtn = document.getElementById('personalization_bgVideoReset');
                        if (uploadVidBtn && uploadVidFile) {
                            uploadVidBtn.addEventListener('click', () => uploadVidFile.click());
                            uploadVidFile.addEventListener('change', (e) => {
                                const f = e.target.files && e.target.files[0]; if (!f) return;
                                const MAX_VIDEO_BYTES = 5 * 1024 * 1024; // 5MB
                                if (f.size > MAX_VIDEO_BYTES) { alert('影片過大，請選擇小於 5MB 的檔案。'); return; }
                                // Use object URL for the video playback and apply it as personalization
                                // Revoke previous uploaded object URL if present
                                try { if (_lastBackgroundVideoObjectUrl) { URL.revokeObjectURL(_lastBackgroundVideoObjectUrl); _lastBackgroundVideoObjectUrl = null; } } catch(e){}
                                const urlObj = URL.createObjectURL(f);
                                if (personalizationControls.bgVideoUrl) {
                                    personalizationControls.bgVideoUrl.value = urlObj;
                                    personalizationControls.bgVideoUrl.dispatchEvent(new Event('change'));
                                }
                                // Store a reference in dataset so we can revoke later if needed
                                uploadVidFile.dataset.objectUrl = urlObj;
                                _lastBackgroundVideoObjectUrl = urlObj;
                            });
                        }
                        if (resetVidBtn) {
                            resetVidBtn.addEventListener('click', () => {
                                try { if (_lastBackgroundVideoObjectUrl) { URL.revokeObjectURL(_lastBackgroundVideoObjectUrl); _lastBackgroundVideoObjectUrl = null; } } catch(e){}
                                const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                                s.backgroundVideoURL = '';
                                s.backgroundMode = 'default';
                                personalizationControls.backgroundMode.value = 'default';
                                applyPersonalizationSettings(s);
                                savePersonalizationSettings(s);
                            });
                        }
                        // url field for background video
                        if (personalizationControls.bgVideoUrl) {
                            personalizationControls.bgVideoUrl.addEventListener('change', (e) => {
                                const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                                s.backgroundVideoURL = e.target.value;
                                s.backgroundMode = 'video';
                                personalizationControls.backgroundMode.value = 'video';
                                applyPersonalizationSettings(s);
                                savePersonalizationSettings(s);
                            });
                        }
                    } catch (err) { /* ignore video initialization errors */ }
                } catch (err) { /* ignore */ }
            }

            // Font subpage open/close
                const fontPanel = document.getElementById('personalization_font_panel');
            const fontBackBtn = document.getElementById('personalization_font_back');
            const fontPanelSet = document.getElementById('personalization_fontSet_panel');
            const fontPanelScale = document.getElementById('personalization_fontScale_panel');
                const fontSetMain = document.getElementById('personalization_fontSet');
            const fontEditBtn = null; // no dedicated edit; open via clicking the main '字型' item
            if (fontPanel) {
                // Use `personalizationSections` (defined earlier) to hide the page sections while showing the subpage
                function openFontPanel() {
                    personalizationSections.forEach(s => s.style.display = 'none');
                    fontPanel.style.display = 'block';
                    fontPanel.classList.add('active');
                }
                function closeFontPanel() {
                    personalizationSections.forEach(s => s.style.display = 'block');
                    fontPanel.style.display = 'none';
                    fontPanel.classList.remove('active');
                }
                if (fontBackBtn) fontBackBtn.addEventListener('click', (e) => { e.preventDefault(); closeFontPanel(); });
                // Open font panel when clicking the main font control area
                const fontItem = Array.from(document.querySelectorAll('.setting-item')).find(el => el.querySelector('#personalization_fontSet'));
                if (fontItem) {
                    fontItem.addEventListener('click', (e) => {
                        // ignore clicks on the select itself - only open when clicking label area
                        if (e.target && (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON')) return;
                        openFontPanel();
                    });
                }
                // Mirror panel controls to main set
                if (fontPanelSet && fontSetMain) {
                    fontPanelSet.addEventListener('change', (e) => {
                        fontSetMain.value = e.target.value;
                        fontSetMain.dispatchEvent(new Event('change'));
                    });
                }
                // When the panel scale changes, update the displayed value if present and
                // ensure the personalization flow triggers (the main control reference may be absent)
                if (fontPanelScale) {
                    fontPanelScale.addEventListener('input', (e) => {
                        // Update displayed value (either main value element or panel value element)
                        const valEl = document.getElementById('personalization_fontScaleValue') || document.getElementById('personalization_fontScaleValue_panel');
                        if (valEl) valEl.textContent = e.target.value + '%';
                        // Trigger the generic handler if it exists on personalizationControls.fontScale
                        if (personalizationControls.fontScale && personalizationControls.fontScale !== fontPanelScale) {
                            personalizationControls.fontScale.value = e.target.value;
                            personalizationControls.fontScale.dispatchEvent(new Event('input'));
                        } else if (!personalizationControls.fontScale) {
                            // No main control - call the same handler logic directly to save/apply
                            // If there is no separate "main" control, handle applying and saving here.
                            const s = loadPersonalizationSettings() || DEFAULT_PERSONALIZATION;
                            s.fontScale = Number(e.target.value);
                            applyPersonalizationSettings(s);
                            savePersonalizationSettings(s);
                        }
                    });
                }
            }

            // Mirror background panel controls to main controls when changed
            const bgMode = document.getElementById('personalization_backgroundMode');
            const bgModeMain = document.getElementById('personalization_backgroundMode');
            if (bgMode) {
                bgMode.addEventListener('change', (e) => {
                    // the main control is the same ID, dispatch will update
                    bgMode.dispatchEvent(new Event('change'));
                });
            }

            // Global drag/resize state (one set of handlers for all windows)
            // Implementation notes:
            // - Uses `actionState` to track the current operation (drag/resize)
            // - Pointer events are supported via pointerdown/pointermove/pointerup
            // - requestAnimationFrame is used to throttle DOM updates for smoother dragging/resizing
            // - When resizing from 'left' or 'top', the opposite edge (right/bottom) is anchored
            //   to prevent the window from shifting its position unexpectedly.
            const actionState = {
                type: null, // 'drag' | 'resize'
                windowEl: null,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0,
                startWidth: 0,
                startHeight: 0,
                direction: ''
                ,pointerId: null,
                captureTarget: null,
                restoreOnDrag: false
            };
            function initBootSequence() {
                const status = document.getElementById('boot-status');
                setTimeout(() => {
                    status.textContent = '載入核心模組...';
                }, 1000);
                setTimeout(() => {
                    status.textContent = '啟動使用者介面...';
                }, 2000);
                setTimeout(() => {
                    bootLoader.style.opacity = '0';
                    setTimeout(() => {
                        bootLoader.remove();
                    }, 500);
                }, 3000);
            }

            // --- 2. 時間與日期 ---
            function updateTime() {
                const now = new Date();
                // Manual 12-hour formatting with localized AM/PM labels (午前/午後).
                const hours24 = now.getHours();
                const minutes = now.getMinutes();
                const isAM = hours24 < 12;
                const ampmLabel = isAM ? '午前' : '午後';
                // Convert to 12-hour clock (show 12 instead of 0)
                let hours12 = hours24 % 12;
                if (hours12 === 0) hours12 = 12;
                const hh = String(hours12).padStart(2, '0');
                const mm = String(minutes).padStart(2, '0');
                // Update the separate elements so we can style them independently and keep spacing consistent.
                if (timeAmpmEl) timeAmpmEl.textContent = ampmLabel;
                if (timeValueEl) timeValueEl.textContent = `${hh}:${mm}`;
                // Keep the date in zh-TW format as before.
                dateEl.textContent = now.toLocaleDateString('zh-TW');
            }
            setInterval(updateTime, 1000);
            updateTime();

            // --- 3. 日曆 ---
            function renderCalendar() {
                calendarGrid.innerHTML = '';
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                calendarMonthYear.textContent = `${year}年 ${month + 1}月`;
                
                // 星期
                const days = ['日', '一', '二', '三', '四', '五', '六'];
                days.forEach(day => {
                    const cell = document.createElement('div');
                    cell.classList.add('calendar-cell', 'day-name');
                    cell.textContent = day;
                    calendarGrid.appendChild(cell);
                });

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const today = new Date();

                // 上個月的日期
                for (let i = 0; i < firstDay; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('calendar-cell', 'other-month');
                    calendarGrid.appendChild(cell);
                }

                // 這個月的日期
                for (let i = 1; i <= daysInMonth; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('calendar-cell');
                    cell.textContent = i;
                    if (i === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
                        cell.classList.add('today');
                    }
                    calendarGrid.appendChild(cell);
                }
            }
            calendarPrev.addEventListener('click', () => {
                calendarDate.setMonth(calendarDate.getMonth() - 1);
                renderCalendar();
            });
            calendarNext.addEventListener('click', () => {
                calendarDate.setMonth(calendarDate.getMonth() + 1);
                renderCalendar();
            });
            taskbarTime.addEventListener('click', (e) => {
                e.stopPropagation();
                calendarFlyout.classList.toggle('show');
                startMenu.classList.remove('show');
                widgetsPanel.classList.remove('show');
            });

            // --- 4. 開始功能表 ---
            startButton.addEventListener('click', (e) => {
                e.stopPropagation();
                startMenu.classList.toggle('show');
                calendarFlyout.classList.remove('show');
                widgetsPanel.classList.remove('show');
            });
            
            // --- 5. 小工具面板 ---
            widgetsButton.addEventListener('click', (e) => {
                e.stopPropagation();
                widgetsPanel.classList.toggle('show');
                startMenu.classList.remove('show');
                calendarFlyout.classList.remove('show');
            });

            // --- 6. 全域點擊 (隱藏彈窗) ---
            // 修改：只在模擬器容器內點擊時觸發
            simulatorContainer.addEventListener('click', (e) => {
                if (!startMenu.contains(e.target) && e.target !== startButton) {
                    startMenu.classList.remove('show');
                }
                if (!calendarFlyout.contains(e.target) && e.target !== taskbarTime) {
                    calendarFlyout.classList.remove('show');
                }
                if (!widgetsPanel.contains(e.target) && e.target !== widgetsButton) {
                    widgetsPanel.classList.remove('show');
                }
                contextMenu.classList.remove('show');
                // Hide start menu context if visible
                const startCtx = document.getElementById('start-context-menu');
                if (startCtx) startCtx.classList.remove('show');
            });
            // 點擊模擬器外部也隱藏
             document.addEventListener('click', (e) => {
                if (!simulatorContainer.contains(e.target)) {
                    startMenu.classList.remove('show');
                    calendarFlyout.classList.remove('show');
                    widgetsPanel.classList.remove('show');
                    contextMenu.classList.remove('show');
                    const startCtx2 = document.getElementById('start-context-menu');
                    if (startCtx2) startCtx2.classList.remove('show');
                }
            });
            
            // --- 7. 右鍵選單 ---
            desktop.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                
                // 修改：計算相對於 desktop 的位置
                const desktopRect = desktop.getBoundingClientRect();
                const styleTop = e.clientY - desktopRect.top;
                const styleLeft = e.clientX - desktopRect.left;
                
                // 邊界檢查，防止選單超出桌面
                const menuWidth = contextMenu.offsetWidth || 200;
                const menuHeight = contextMenu.offsetHeight || 200;
                
                let finalLeft = styleLeft;
                let finalTop = styleTop;

                if (styleLeft + menuWidth > desktop.clientWidth) {
                    finalLeft = desktop.clientWidth - menuWidth;
                }
                if (styleTop + menuHeight > desktop.clientHeight) {
                    finalTop = desktop.clientHeight - menuHeight;
                }

                contextMenu.style.top = `${finalTop}px`;
                contextMenu.style.left = `${finalLeft}px`;
                contextMenu.classList.add('show');
                // Hide any start-context-menu if visible
                const startCtx = document.getElementById('start-context-menu');
                if (startCtx) startCtx.classList.remove('show');
            });

            // Start-menu body right-click: open a start-specific context menu (positioned at mouse location)
            const startMenuBodyEl = document.querySelector('#start-menu .start-menu-body');
            const startContextMenu = document.getElementById('start-context-menu');
            if (startMenuBodyEl && startContextMenu) {
                startMenuBodyEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Position relative to the simulator container (same as desktop context menu)
                    const containerRect = simulatorContainer.getBoundingClientRect();
                    let styleTop = e.clientY - containerRect.top;
                    let styleLeft = e.clientX - containerRect.left;

                    const menuWidth = startContextMenu.offsetWidth || 220;
                    const menuHeight = startContextMenu.offsetHeight || 100;

                    if (styleLeft + menuWidth > simulatorContainer.clientWidth) {
                        styleLeft = simulatorContainer.clientWidth - menuWidth;
                        if (styleLeft < 0) styleLeft = 0;
                    }
                    if (styleTop + menuHeight > simulatorContainer.clientHeight) {
                        styleTop = simulatorContainer.clientHeight - menuHeight;
                        if (styleTop < 0) styleTop = 0;
                    }

                    startContextMenu.style.left = `${styleLeft}px`;
                    startContextMenu.style.top = `${styleTop}px`;
                    startContextMenu.classList.add('show');
                    // ensure we hide the global desktop context menu
                    contextMenu.classList.remove('show');
                });

                // Close it when clicking the Start menu header or anywhere else inside the start menu but not the menu itself
                startMenu.addEventListener('click', (e) => {
                    if (!startContextMenu.contains(e.target)) startContextMenu.classList.remove('show');
                });
            }

            // --- 8. 視窗管理 ---
            
            // 8.1 設為活躍
            function focusWindow(windowEl) {
                // If the window is minimized, restore it first
                if (windowEl && windowEl.classList.contains('minimized')) {
                    openWindow(windowEl.dataset.app);
                    return;
                }
                if (activeWindow === windowEl) return;
                
                // Demote previous active window to the top of inactive stack
                if (activeWindow) {
                    activeWindow.classList.remove('active');
                    highestZIndex++;
                    activeWindow.style.zIndex = highestZIndex;
                }
                windows.forEach(w => w.classList.remove('active'));
                
                activeWindow = windowEl;
                activeWindow.classList.add('active');
                
                // Promote new active window to the dedicated active layer (3000)
                // This ensures it is above snap-preview (2000) but snap-preview is above inactive windows (1000+)
                activeWindow.style.zIndex = 3000;
                
                updateTaskbarActive(activeWindow.dataset.app);
            }

            // 8.2 更新任務欄
            function updateTaskbarActive(appId) {
                getAllTaskbarIcons().forEach(icon => {
                    // Update active-app state (foreground)
                    const isActive = icon.dataset.app === appId;
                    icon.classList.toggle('active-app', isActive);
                    // Accessibility: set aria-pressed for the taskbar button to reflect active state
                    icon.setAttribute('aria-pressed', String(!!isActive));
                    // Update open-app based on whether the window is currently showing (foreground),
                    // or minimized (app still running in background). Treat minimized windows as open-app.
                    const winEl = document.getElementById(`window-${icon.dataset.app}`);
                    if (winEl && (winEl.classList.contains('show') || winEl.classList.contains('minimized'))) {
                        icon.classList.add('open-app');
                    } else {
                        icon.classList.remove('open-app');
                    }
                });
            }

            // Utility: ensure a taskbar icon exists for an app. If not, create a temporary icon for running (non-pinned) apps.
            function createTaskbarIconIfMissing(appId) {
                if (!appId) return null;
                let existing = document.getElementById(`taskbar-icon-${appId}`);
                if (existing) return existing;
                const centerGroup = document.querySelector('#taskbar .taskbar-group.center');
                if (!centerGroup) return null;
                const el = document.createElement('div');
                el.className = 'taskbar-icon';
                el.id = `taskbar-icon-${appId}`;
                el.dataset.app = appId;
                el.setAttribute('role', 'button');
                el.setAttribute('tabindex', '0');
                el.setAttribute('aria-pressed', 'false');
                // mark as temporary (not pinned) so it can be removed on close
                el.setAttribute('data-temporary', 'true');
                // Choose proper icon markup (use image for nagato, otherwise FA icons)
                switch (appId) {
                    case 'nagato':
                        el.innerHTML = `<img src="assets/apps/icon/NS-V2.png" alt="長門櫻" class="app-icon-img icon-nagato" loading="lazy">`;
                        el.title = '長門櫻';
                        break;
                    case 'settings':
                        el.innerHTML = `<i class="fa-solid fa-gear icon-settings"></i>`;
                        el.title = '設定';
                        break;
                    case 'explorer':
                        el.innerHTML = `<i class="fa-solid fa-folder icon-explorer"></i>`;
                        el.title = '檔案總管';
                        break;
                    case 'browser':
                        el.innerHTML = `<i class="fa-brands fa-edge icon-edge"></i>`;
                        el.title = '瀏覽器';
                        break;
                    case 'store':
                        el.innerHTML = `<i class="fa-solid fa-store icon-store"></i>`;
                        el.title = '應用商店';
                        break;
                    case 'calculator':
                        el.innerHTML = `<i class="fa-solid fa-calculator" style="color: #4caf50;"></i>`;
                        el.title = '計算機';
                        break;
                    default:
                        el.innerHTML = `<i class="fa-solid fa-square"></i>`;
                        el.title = appId;
                        break;
                }
                // Insert icons before the right side of center group (i.e., append to center by default)
                centerGroup.appendChild(el);
                return el;
            }

            // 8.3 開啟視窗
            function openWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (!windowEl) return;
                const wasMinimized = windowEl.classList.contains('minimized');
                windowEl.classList.add('show');
                windowEl.classList.remove('minimized');
                // Taskbar icon should be marked as open (background/foreground)
                let tbIcon = document.getElementById(`taskbar-icon-${appId}`);
                if (!tbIcon) tbIcon = createTaskbarIconIfMissing(appId);
                if (tbIcon) tbIcon.classList.add('open-app');
                // If the window has not been placed yet (no inline position), center it within the desktop
                // only when it is not maximized/snapped. This prevents re-centering restorations.
                try {
                    const desktopEl = document.getElementById('desktop');
                    const taskbarEl = document.getElementById('taskbar');
                    if (desktopEl && taskbarEl && !windowEl.dataset.placed && !windowEl.dataset.isSnapped && !windowEl.dataset.isMaximized) {
                        // Ensure the window is shown first so offsetWidth/offsetHeight are reliable
                        const tbHeight = taskbarEl.offsetHeight || 0;
                        const containerWidth = desktopEl.clientWidth;
                        const containerHeight = desktopEl.clientHeight - tbHeight;
                        const winWidth = windowEl.offsetWidth || parseFloat(window.getComputedStyle(windowEl).width) || 400;
                        const winHeight = windowEl.offsetHeight || parseFloat(window.getComputedStyle(windowEl).height) || 300;
                        let left = Math.max(0, Math.round((containerWidth - winWidth) / 2));
                        let top = Math.max(0, Math.round((containerHeight - winHeight) / 2));
                        // If the window was created with top/left inline, don't override
                        const hasInlineLeft = windowEl.style.left && windowEl.style.left !== '' && windowEl.style.left !== 'auto';
                        const hasInlineTop = windowEl.style.top && windowEl.style.top !== '' && windowEl.style.top !== 'auto';
                        if (!hasInlineLeft) windowEl.style.left = `${left}px`;
                        if (!hasInlineTop) windowEl.style.top = `${top}px`;
                        // Mark placed so future opens do not re-center
                        windowEl.dataset.placed = 'true';
                    }
                } catch (err) {
                    console.error('Failed to auto-center window', err);
                }
                focusWindow(windowEl);
                
                if (appId === 'browser') {
                    const iframe = windowEl.querySelector('iframe');
                    // By default, when opening the browser, use the user-customized url if available
                    const desired = (document.getElementById('browser-url-input')?.value || iframe.src || '').trim();
                    const urlToSet = (!desired || desired === 'about:blank') ? 'https://amanoshizukikun.github.io/' : desired;
                    // If we are restoring from minimized state, avoid forcing a reload or pushing history
                    setBrowserUrl(urlToSet, !wasMinimized);
                    // Ensure iframe is visible as it uses the 'show' class to display in Edge-like UI
                    iframe.classList.add('show');
                }
                if (appId === 'nagato') {
                    // Focus input and refresh messages when opening the assistant
                    setTimeout(() => {
                        const inputEl = document.getElementById('nagato-input');
                        if (inputEl) { inputEl.focus(); }
                        try { renderNagatoMessages(); } catch (e) {}
                    }, 50);
                }
                if (appId === 'calculator') {
                    const calcInput = document.getElementById('calc-input');
                    if (calcInput) {
                        // Delay slightly so that the window becomes focusable first
                        setTimeout(() => { calcInput.focus(); }, 0);
                    }
                }
            }
            
            // 8.4 關閉視窗
            function closeWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (windowEl) {
                    windowEl.classList.remove('show');
                }
                const tbIconClose = document.getElementById(`taskbar-icon-${appId}`);
                if (tbIconClose) {
                    // If temporary (creator-created) icon, remove it when the app closes
                    if (tbIconClose.hasAttribute('data-temporary')) {
                        tbIconClose.remove();
                    } else {
                        // pinned: just clear state
                        tbIconClose.classList.remove('active-app');
                        tbIconClose.classList.remove('open-app');
                        tbIconClose.setAttribute('aria-pressed', 'false');
                    }
                }
                if (activeWindow === windowEl) {
                    activeWindow = null;
                    // If there are other visible windows, focus the top-most (highest z-index)
                    const visibleWindows = Array.from(document.querySelectorAll('.window.show')).filter(w => !w.classList.contains('minimized') && w !== windowEl);
                    if (visibleWindows.length > 0) {
                        visibleWindows.sort((a, b) => (parseInt(b.style.zIndex, 10) || 0) - (parseInt(a.style.zIndex, 10) || 0));
                        focusWindow(visibleWindows[0]);
                    }
                }
            }
            
            // 8.5 最小化視窗
            function minimizeWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (windowEl) {
                    windowEl.classList.add('minimized');
                    windowEl.classList.remove('show', 'active');
                    // Keep the taskbar icon as open (app still running in background). Remove 'active-app'.
                    const tbIconMin = document.getElementById(`taskbar-icon-${appId}`);
                    if (tbIconMin) {
                        tbIconMin.classList.remove('active-app');
                        tbIconMin.classList.add('open-app'); // keep as open while minimized
                        tbIconMin.setAttribute('aria-pressed', 'false');
                    }
                }
                if (activeWindow === windowEl) {
                    activeWindow = null;
                }
                // Update taskbar icons to ensure active state is consistent
                updateTaskbarActive(null);
            }

            // 8.6 最大化/還原 視窗
            function maximizeWindow(appId) {
                const windowEl = document.getElementById(`window-${appId}`);
                if (windowEl) {
                    if (!windowEl.dataset.isMaximized) {
                        const cs = window.getComputedStyle(windowEl);
                        windowEl.dataset.oldX = windowEl.style.left || cs.left;
                        windowEl.dataset.oldY = windowEl.style.top || cs.top;
                        windowEl.dataset.oldW = windowEl.style.width || cs.width;
                        windowEl.dataset.oldH = windowEl.style.height || cs.height;
                        
                        windowEl.style.left = '0';
                        windowEl.style.top = '0';
                        windowEl.style.width = '100%';
                        // 高度 100% 減去任務欄高度 (相對於 .simulator-container)
                        windowEl.style.height = `calc(100% - ${taskbar.offsetHeight}px)`;
                        windowEl.dataset.isMaximized = 'true';
                    } else {
                        // 還原
                        windowEl.style.left = windowEl.dataset.oldX || '100px';
                        windowEl.style.top = windowEl.dataset.oldY || '100px';
                        windowEl.style.width = windowEl.dataset.oldW || '700px';
                        windowEl.style.height = windowEl.dataset.oldH || '500px';
                        windowEl.dataset.isMaximized = '';
                    }
                    focusWindow(windowEl);
                }
            }

            // 8.7 Snap windows to left/right or corners
            function snapWindow(windowEl, mode) {
                if (!windowEl) return;
                // save previous rect if not already saved
                if (!windowEl.dataset.oldW) {
                    const cs = window.getComputedStyle(windowEl);
                    windowEl.dataset.oldX = windowEl.style.left || cs.left;
                    windowEl.dataset.oldY = windowEl.style.top || cs.top;
                    windowEl.dataset.oldW = windowEl.style.width || cs.width;
                    windowEl.dataset.oldH = windowEl.style.height || cs.height;
                }
                const contentBoxWidth = desktop.clientWidth;
                const contentBoxHeight = desktop.clientHeight;
                const taskbarHeight = taskbar.offsetHeight;
                let newLeft = 0;
                let newTop = 0;
                let newWidth = windowEl.offsetWidth;
                let newHeight = contentBoxHeight - taskbarHeight;

                switch (mode) {
                    case 'left':
                        newLeft = 0;
                        newWidth = Math.floor(contentBoxWidth / 2);
                        break;
                    case 'right':
                        newLeft = Math.ceil(contentBoxWidth / 2);
                        newWidth = Math.floor(contentBoxWidth / 2);
                        break;
                    case 'left-top':
                        newLeft = 0;
                        newTop = 0;
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    case 'right-top':
                        newLeft = Math.ceil(contentBoxWidth / 2);
                        newTop = 0;
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    case 'left-bottom':
                        newLeft = 0;
                        newTop = Math.ceil((contentBoxHeight - taskbarHeight) / 2);
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    case 'right-bottom':
                        newLeft = Math.ceil(contentBoxWidth / 2);
                        newTop = Math.ceil((contentBoxHeight - taskbarHeight) / 2);
                        newWidth = Math.floor(contentBoxWidth / 2);
                        newHeight = Math.floor((contentBoxHeight - taskbarHeight) / 2);
                        break;
                    default:
                        return;
                }

                windowEl.style.left = `${newLeft}px`;
                windowEl.style.top = `${newTop}px`;
                windowEl.style.width = `${newWidth}px`;
                windowEl.style.height = `${newHeight}px`;
                // mark snapped state
                windowEl.dataset.isSnapped = mode;
                // ensure not maximized
                windowEl.dataset.isMaximized = '';
                focusWindow(windowEl);
            }

            // --- 9. 視窗事件綁定 (拖動, 調整大小, 控制按鈕) ---
            windows.forEach(windowEl => {
                const header = windowEl.querySelector('.window-header');
                const appId = windowEl.dataset.app;

                // 9.1 點擊視窗時設為 Active
                windowEl.addEventListener('mousedown', () => {
                    focusWindow(windowEl);
                }, true);
                windowEl.addEventListener('pointerdown', (e) => {
                    focusWindow(windowEl);
                }, true);

                // 9.2 拖動 (使用全域 actionState)
                header.addEventListener('mousedown', (e) => {
                    // ignore if the click comes from a resize handle that sits above the header
                    if (e.target.closest && e.target.closest('.resize-handle')) return;
                    if (e.target.closest('.window-control-btn')) return;
                    // If the window is maximized, we no longer restore immediately on mousedown.
                    // Instead, enable restore-on-drag: only when user moves the cursor beyond a
                    // small threshold (i.e. starts to drag) do we restore and continue dragging.
                    actionState.restoreOnDrag = (windowEl.dataset.isMaximized === 'true');
                    // Restore if window was snapped
                    if (windowEl.dataset.isSnapped) {
                        const cs = window.getComputedStyle(windowEl);
                        const oldX = parseFloat(windowEl.dataset.oldX) || parseFloat(cs.left) || 100;
                        const oldY = parseFloat(windowEl.dataset.oldY) || parseFloat(cs.top) || 100;
                        const oldW = parseFloat(windowEl.dataset.oldW) || windowEl.offsetWidth;
                        const oldH = parseFloat(windowEl.dataset.oldH) || windowEl.offsetHeight;
                        windowEl.style.width = `${oldW}px`;
                        windowEl.style.height = `${oldH}px`;
                        windowEl.style.left = `${oldX}px`;
                        windowEl.style.top = `${oldY}px`;
                        windowEl.dataset.isSnapped = '';
                    }
                    // If window was snapped (left/right), restoring to previous size so dragging feels natural
                    if (windowEl.dataset.isSnapped) {
                        const cs = window.getComputedStyle(windowEl);
                        const oldX = parseFloat(windowEl.dataset.oldX) || parseFloat(cs.left) || 100;
                        const oldY = parseFloat(windowEl.dataset.oldY) || parseFloat(cs.top) || 100;
                        const oldW = parseFloat(windowEl.dataset.oldW) || windowEl.offsetWidth;
                        const oldH = parseFloat(windowEl.dataset.oldH) || windowEl.offsetHeight;
                        windowEl.style.width = `${oldW}px`;
                        windowEl.style.height = `${oldH}px`;
                        windowEl.style.left = `${oldX}px`;
                        windowEl.style.top = `${oldY}px`;
                        windowEl.dataset.isSnapped = '';
                    }
                    focusWindow(windowEl);
                    const rect = windowEl.getBoundingClientRect();
                    const parentRect = desktop.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(desktop);
                    const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                    const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                    const parentOriginX = parentRect.left + parentPaddingLeft;
                    const parentOriginY = parentRect.top + parentPaddingTop;

                    actionState.type = 'drag';
                    actionState.windowEl = windowEl;
                    actionState.startX = e.clientX;
                    actionState.startY = e.clientY;
                    // Prefer explicit style.left/style.top if present, otherwise compute from rect
                    const explicitLeft = parseFloat(windowEl.style.left);
                    const explicitTop = parseFloat(windowEl.style.top);
                    actionState.startLeft = Number.isFinite(explicitLeft) ? explicitLeft : (rect.left - parentOriginX);
                    actionState.startTop = Number.isFinite(explicitTop) ? explicitTop : (rect.top - parentOriginY);
                    actionState.pointerId = e.pointerId || null;
                    actionState.captureTarget = header || e.target || null;

                    // prevent text selection during drag
                    document.body.style.userSelect = 'none';
                    try { if (e.pointerId) (header.setPointerCapture && header.setPointerCapture(e.pointerId)) || (e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId)); } catch (err) {}
                    e.preventDefault();
                });
                header.addEventListener('pointerdown', (e) => {
                    // ignore if the pointerdown originates from a resize handle
                    if (e.target.closest && e.target.closest('.resize-handle')) return;
                    if (e.target.closest('.window-control-btn')) return;
                    // same as mouse handler: delay restore until actual drag occurs
                    actionState.restoreOnDrag = (windowEl.dataset.isMaximized === 'true');
                    focusWindow(windowEl);
                    const rect = windowEl.getBoundingClientRect();
                    const parentRect = desktop.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(desktop);
                    const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                    const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                    const parentOriginX = parentRect.left + parentPaddingLeft;
                    const parentOriginY = parentRect.top + parentPaddingTop;

                    actionState.type = 'drag';
                    actionState.windowEl = windowEl;
                    actionState.startX = e.clientX;
                    actionState.startY = e.clientY;
                    const explicitLeft2 = parseFloat(windowEl.style.left);
                    const explicitTop2 = parseFloat(windowEl.style.top);
                    actionState.startLeft = Number.isFinite(explicitLeft2) ? explicitLeft2 : (rect.left - parentOriginX);
                    actionState.startTop = Number.isFinite(explicitTop2) ? explicitTop2 : (rect.top - parentOriginY);

                    // prevent text selection during drag
                    document.body.style.userSelect = 'none';
                    try { if (e.pointerId) e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); } catch (err) {}
                    e.preventDefault();
                });
                // Double-click header toggles maximize
                header.addEventListener('dblclick', (e) => {
                    if (e.target.closest('.window-control-btn')) return;
                    maximizeWindow(appId);
                });

                // 9.3 調整大小 (使用 resizewin 函數)
                windowEl.querySelectorAll('.resize-handle').forEach(handle => {
                    const direction = Array.from(handle.classList).find(c => c.length <= 2) || '';
                    let arg = '';
                    if (direction === 'n') arg = 'top';
                    else if (direction === 's') arg = 'bottom';
                    else if (direction === 'e') arg = 'right';
                    else if (direction === 'w') arg = 'left';
                    else if (direction === 'nw') arg = 'top-left';
                    else if (direction === 'ne') arg = 'top-right';
                    else if (direction === 'sw') arg = 'bottom-left';
                    else if (direction === 'se') arg = 'bottom-right';

                    handle.addEventListener('mousedown', (e) => {
                        focusWindow(windowEl);
                        e.stopPropagation();
                        document.body.style.userSelect = 'none';
                        resizewin(windowEl, arg, handle, e);
                        e.preventDefault();
                    });
                    handle.addEventListener('pointerdown', (e) => {
                        focusWindow(windowEl);
                        e.stopPropagation();
                        document.body.style.userSelect = 'none';
                        resizewin(windowEl, arg, handle, e);
                        e.preventDefault();
                    });
                });
                // 9.4 Snap layout option handlers
                const snapOptions = windowEl.querySelectorAll('.snap-layout-option');
                if (snapOptions && snapOptions.length) {
                    snapOptions.forEach((opt, i) => {
                        opt.addEventListener('click', (e) => {
                            e.stopPropagation();
                            switch (i) {
                                case 0: snapWindow(windowEl, 'left-top'); break;
                                case 1: snapWindow(windowEl, 'right-top'); break;
                                case 2: snapWindow(windowEl, 'left-bottom'); break;
                                case 3: snapWindow(windowEl, 'right-bottom'); break;
                            }
                        });
                    });
                }

                // Note: mousemove and mouseup handlers are added globally once below
                
                // 9.5 全域 MouseUp handled globally below

                // 9.6 控制按鈕
                windowEl.querySelector('.close').addEventListener('click', () => closeWindow(appId));
                windowEl.querySelector('.minimize').addEventListener('click', () => minimizeWindow(appId));
                windowEl.querySelector('.maximize').addEventListener('click', () => maximizeWindow(appId));
            });

            // Global mouse handlers for drag/resize (single listener for all windows)
            // Use RAF to throttle updates and support pointer events to avoid stuck state / missing mouseup

            /**
             * - Uses a local `state` to capture start geometry and pointer start coordinates
             * - Throttles layout updates with requestAnimationFrame to reduce layout thrashing
             * - Anchors the opposite edge (right/bottom) when resizing from left/top to avoid
             *   the window 'jumping' or 'sliding' unexpectedly
             * - Supports mouse, touch and pointer events (pointer capture when supported)
             */
            function resizewin(win, arg, resizeElt, ev) {
                const desktop = document.getElementById('desktop');
                const desktopRect = desktop.getBoundingClientRect();
                const taskbar = document.getElementById('taskbar');
                const taskbarHeight = taskbar ? taskbar.offsetHeight : 0;
                const startRect = win.getBoundingClientRect();
                const explicitLeft = parseFloat(win.style.left);
                const explicitTop = parseFloat(win.style.top);
                const startLeft = Number.isFinite(explicitLeft) ? explicitLeft : (startRect.left - desktopRect.left);
                const startTop = Number.isFinite(explicitTop) ? explicitTop : (startRect.top - desktopRect.top);
                const state = {
                    startX: null,
                    startY: null,
                    startLeft: startLeft,
                    startTop: startTop,
                    startWidth: startRect.width,
                    startHeight: startRect.height,
                    rightEdge: startLeft + startRect.width,
                    bottomEdge: startTop + startRect.height,
                    currentX: null,
                    currentY: null,
                    rafId: null,
                    pointerId: null,
                    captureTarget: null
                };

                function applyResize() {
                    if (state.currentX === null || state.currentY === null || state.startX === null) return;
                    const minWidth = win.dataset.minWidth ? parseFloat(win.dataset.minWidth) : 400;
                    const minHeight = win.dataset.minHeight ? parseFloat(win.dataset.minHeight) : 300;
                    const dx = state.currentX - state.startX;
                    const dy = state.currentY - state.startY;

                    let newLeft = state.startLeft;
                    let newTop = state.startTop;
                    let newWidth = state.startWidth;
                    let newHeight = state.startHeight;
                    const viewW = desktop.clientWidth;
                    const viewH = desktop.clientHeight;

                    // Horizontal
                    if (arg.indexOf('right') !== -1 || arg === 'right') {
                        newWidth = Math.max(minWidth, Math.min(viewW - state.startLeft, state.startWidth + dx));
                    }
                    if (arg.indexOf('left') !== -1 || arg === 'left') {
                        // anchor right edge
                        let candidateLeft = state.startLeft + dx;
                        candidateLeft = Math.max(0, Math.min(candidateLeft, state.rightEdge - minWidth));
                        newLeft = candidateLeft;
                        newWidth = state.rightEdge - newLeft;
                    }

                    // Vertical
                    if (arg.indexOf('bottom') !== -1 || arg === 'bottom') {
                        newHeight = Math.max(minHeight, Math.min(viewH - state.startTop, state.startHeight + dy));
                    }
                    if (arg.indexOf('top') !== -1 || arg === 'top') {
                        let candidateTop = state.startTop + dy;
                        candidateTop = Math.max(0, Math.min(candidateTop, state.bottomEdge - minHeight));
                        newTop = candidateTop;
                        newHeight = state.bottomEdge - newTop;
                    }

                    // clamp to view
                    if (newLeft + newWidth > viewW) newWidth = Math.max(minWidth, viewW - newLeft);
                    if (newTop + newHeight > viewH) newHeight = Math.max(minHeight, viewH - newTop);

                    win.style.left = `${newLeft}px`;
                    win.style.top = `${newTop}px`;
                    win.style.width = `${newWidth}px`;
                    win.style.height = `${newHeight}px`;
                }

                function tick() {
                    if (state.rafId) return;
                    state.rafId = requestAnimationFrame(() => { state.rafId = null; applyResize(); });
                }

                function moveHandler(e) {
                    if (e.type.match('mouse')) {
                        state.currentX = e.clientX;
                        state.currentY = e.clientY;
                    } else if (e.type.match('touch')) {
                        state.currentX = e.touches[0].clientX;
                        state.currentY = e.touches[0].clientY;
                    } else if (e.type.match('pointer')) {
                        state.currentX = e.clientX;
                        state.currentY = e.clientY;
                    }
                    tick();
                }

                function up_f() {
                    // release pointer capture if any
                    try { if (state.captureTarget && state.pointerId && state.captureTarget.releasePointerCapture) state.captureTarget.releasePointerCapture(state.pointerId); } catch (err) {}
                    // remove handlers
                    document.onmousedown = null;
                    document.ontouchstart = null;
                    document.onmousemove = null;
                    document.ontouchmove = null;
                    document.ontouchcancel = null;
                    if (window.PointerEvent) {
                        document.removeEventListener('pointermove', moveHandler);
                        document.removeEventListener('pointerup', up_f);
                        document.removeEventListener('pointercancel', up_f);
                    }
                    // cancel RAF
                    if (state.rafId) { cancelAnimationFrame(state.rafId); state.rafId = null; }
                    document.body.style.cursor = 'auto';
                    document.body.style.userSelect = '';
                    try { if (resizeElt && resizeElt._resizeState) delete resizeElt._resizeState; } catch (err) {}
                }

                // set start positions from the event if provided (mousemove/pointerdown/touchstart)
                if (ev) {
                    if (ev.type && ev.type.indexOf('touch') !== -1) {
                        state.startX = ev.touches && ev.touches[0] ? ev.touches[0].clientX : ev.clientX;
                        state.startY = ev.touches && ev.touches[0] ? ev.touches[0].clientY : ev.clientY;
                    } else {
                        state.startX = ev.clientX;
                        state.startY = ev.clientY;
                        state.pointerId = ev.pointerId || null;
                        state.captureTarget = resizeElt || ev.target || null;
                        try { if (ev.pointerId && resizeElt && resizeElt.setPointerCapture) resizeElt.setPointerCapture(ev.pointerId); } catch (err) {}
                        // Prevent text selection while resizing
                        document.body.style.userSelect = 'none';
                    }
                }

                // bind move events
                document.onmousemove = moveHandler;
                document.ontouchmove = moveHandler;
                if (window.PointerEvent) {
                    document.addEventListener('pointermove', moveHandler);
                    document.addEventListener('pointerup', up_f);
                    document.addEventListener('pointercancel', up_f);
                }

                // Touch / mouse cleanup
                document.onmouseup = up_f;
                document.ontouchend = up_f;
                document.ontouchcancel = up_f;

                // reflect cursor style
                document.body.style.cursor = window.getComputedStyle(resizeElt, null).cursor;

                // The mousedown caller should set state.startX/startY to the initial pointer values and set pointer capture
                // We expose the `state` through the element for the mousedown caller to populate these values and capture pointer.
                resizeElt._resizeState = state;
            }

            // Allow windows to be dragged partially under the taskbar for improved dragging space
            const DRAG_UNDER_TASKBAR = 40; // px; how many pixels of overlap are allowed under taskbar
            // Off-screen allowance: this value is configurable via the settings slider (see #offscreenRatio)
            // Default to 90% to allow windows to be dragged more freely off-screen
            let OFFSCREEN_ALLOW_RATIO = 0.9; // ratio (0-1)
            // Hook settings slider if present to change this value dynamically
            try {
                const _offscreenSlider = document.getElementById('offscreenRatio');
                const _offscreenValue = document.getElementById('offscreenRatioValue');
                if (_offscreenSlider && _offscreenValue) {
                    const saved = localStorage.getItem('offscreenRatio');
                    if (saved !== null && !Number.isNaN(Number(saved))) {
                        _offscreenSlider.value = String(Number(saved));
                    }
                    OFFSCREEN_ALLOW_RATIO = Number(_offscreenSlider.value) / 100;
                    _offscreenValue.textContent = `${_offscreenSlider.value}%`;
                    _offscreenSlider.addEventListener('input', (e) => {
                        const v = Number(e.target.value);
                        OFFSCREEN_ALLOW_RATIO = v / 100;
                        _offscreenValue.textContent = `${v}%`;
                    });
                    _offscreenSlider.addEventListener('change', (e) => {
                        localStorage.setItem('offscreenRatio', String(Number(e.target.value)));
                    });
                }
            } catch (err) { console.error(err); }
            let rafId = null;
            // create snap preview element and append to desktop
            let snapPreview = document.getElementById('snap-preview');
            // Hover timer for snap/ maximize preview (wait to show preview to avoid accidental snaps)
            // Delay (ms) before showing the preview while dragging near the edges
            const SNAP_HOVER_DELAY = 30; // 30ms per user's request
            let snapHoverTimer = null;
            let snapHoverMode = '';

            function setSnapHoverMode(mode) {
                // Cancel any pending timer if mode changed
                if (!mode) {
                    if (snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                    snapHoverMode = '';
                    hideSnapPreview();
                    return;
                }
                // If same mode and already showing, do nothing
                if (mode === snapHoverMode && snapPreview && snapPreview.classList.contains('show')) return;
                // If different mode, reset timer
                if (snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                // Start timer to show the preview after SNAP_HOVER_DELAY
                const desiredMode = mode;
                snapHoverTimer = setTimeout(() => {
                    snapHoverTimer = null;
                    snapHoverMode = desiredMode;
                    showSnapPreview(desiredMode);
                }, SNAP_HOVER_DELAY);
            }
            if (!snapPreview) {
                snapPreview = document.createElement('div');
                snapPreview.id = 'snap-preview';
                // Append to simulator container (parent of desktop) to avoid being trapped in desktop's lower z-index stacking context
                // Windows are also children of simulator container (or siblings of desktop), so this allows correct interleaving.
                const container = document.querySelector('.simulator-container') || document.body;
                container.appendChild(snapPreview);
            }
            function requestApply() {
                if (!rafId) rafId = requestAnimationFrame(() => { rafId = null; applyActionState(); });
            }
            function cancelApply() {
                if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
            }
            function applyActionState() {
                if (!actionState.type || !actionState.windowEl) return;
                const windowEl = actionState.windowEl;
                const parentRect = desktop.getBoundingClientRect();
                const parentStyle = window.getComputedStyle(desktop);
                const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                const parentOriginX = parentRect.left + parentPaddingLeft;
                const parentOriginY = parentRect.top + parentPaddingTop;
                const contentBoxWidth = desktop.clientWidth;
                const contentBoxHeight = desktop.clientHeight;
                const taskbarHeight = taskbar.offsetHeight;

                if (actionState.type === 'drag') {
                    const clientX = actionState.currentX || actionState.lastMouseX || actionState.startX;
                    const clientY = actionState.currentY || actionState.lastMouseY || actionState.startY;
                    const dx = clientX - actionState.startX;
                    const dy = clientY - actionState.startY;
                    // If the window was maximized and the user started dragging (not just clicking),
                    // perform a restore to the previous size and continue the drag from there.
                    if (actionState.restoreOnDrag && actionState.windowEl && actionState.windowEl.dataset.isMaximized === 'true') {
                        // threshold to avoid accidental restores on small pointer jitter
                        const restoreThreshold = 6; // px
                        if (Math.abs(dx) > restoreThreshold || Math.abs(dy) > restoreThreshold) {
                            const wEl = actionState.windowEl;
                            const rect = wEl.getBoundingClientRect();
                            const parentRect = desktop.getBoundingClientRect();
                            const parentStyle = window.getComputedStyle(desktop);
                            const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                            const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                            const parentOriginX = parentRect.left + parentPaddingLeft;
                            const parentOriginY = parentRect.top + parentPaddingTop;
                            const pointerX = clientX;
                            const pointerY = clientY;
                            const relX = (pointerX - rect.left) / rect.width;
                            const relY = (pointerY - rect.top) / rect.height;
                            const oldW = parseFloat(wEl.dataset.oldW) || 700;
                            const oldH = parseFloat(wEl.dataset.oldH) || 500;
                            // Calculate new left/top so pointer remains over same relative point
                            let newLeft = pointerX - parentOriginX - (relX * oldW);
                            let newTop = pointerY - parentOriginY - (relY * oldH);
                            const maxLeft = desktop.clientWidth - oldW;
                            const maxTop = desktop.clientHeight - taskbar.offsetHeight - oldH;
                            if (newLeft < 0) newLeft = 0;
                            if (newTop < 0) newTop = 0;
                            if (newLeft > maxLeft) newLeft = maxLeft;
                            if (newTop > maxTop) newTop = maxTop;
                            // Apply restoration and ensure metrics are updated for subsequent drag
                            wEl.style.width = `${oldW}px`;
                            wEl.style.height = `${oldH}px`;
                            wEl.style.left = `${newLeft}px`;
                            wEl.style.top = `${newTop}px`;
                            wEl.dataset.isMaximized = '';
                            actionState.restoreOnDrag = false;
                            // Update start positions for smooth dragging
                            actionState.startLeft = newLeft;
                            actionState.startTop = newTop;
                            actionState.startX = clientX;
                            actionState.startY = clientY;
                            // Recompute dx/dy to reflect the new start position (so the immediate movement continues applying correctly)
                            // No reassign of dx/dy here; let subsequent applyActionState loop pick up new deltas
                        }
                    }
                    let newLeft = actionState.startLeft + dx;
                    let newTop = actionState.startTop + dy;
                    // clamp to desktop bounds, but allow partial off-screen movement when not maximized
                    if (windowEl.dataset.isMaximized === 'true') {
                        // For maximized windows, keep them fully inside the desktop bounds
                        if (newLeft < 0) newLeft = 0;
                        if (newTop < 0) newTop = 0;
                        if (newLeft + windowEl.offsetWidth > contentBoxWidth) newLeft = contentBoxWidth - windowEl.offsetWidth;
                        if (newTop + windowEl.offsetHeight > contentBoxHeight - taskbarHeight) newTop = contentBoxHeight - taskbarHeight - windowEl.offsetHeight;
                    } else {
                        // Non-maximized: allow partially off-screen horizontally and bottom, but not above header (top < 0)
                        const offX = Math.round(windowEl.offsetWidth * OFFSCREEN_ALLOW_RATIO);
                        const offY = Math.round(windowEl.offsetHeight * OFFSCREEN_ALLOW_RATIO);
                        const minLeft = -offX;
                        const maxLeft = contentBoxWidth - windowEl.offsetWidth + offX;
                        const minTop = 0; // prevent moving above header (desktop top)
                        const maxTop = contentBoxHeight - taskbarHeight - windowEl.offsetHeight + offY;

                        if (newLeft < minLeft) newLeft = minLeft;
                        if (newLeft > maxLeft) newLeft = maxLeft;
                        if (newTop < minTop) newTop = minTop;
                        if (newTop > maxTop) newTop = maxTop;
                    }
                    windowEl.style.left = `${newLeft}px`;
                    windowEl.style.top = `${newTop}px`;

                    // Show snap preview while dragging (not when maximized)
                    // NOTE: Use pointer position (cursor) rather than window position so snap triggers
                    // when the mouse is dragged near edges, reducing accidental snaps when the
                    // window itself visually touches the edge because of size/offset.
                    const snapThreshold = 24; // px distance to edge to show preview
                    const cornerThreshold = 120; // px for corner area
                    let previewMode = '';
                    // Use pointer coordinates (clientX/Y) as primary input for snap detection.
                    const parentRectLocal = desktop.getBoundingClientRect();
                    const parentStyleLocal = window.getComputedStyle(desktop);
                    const parentPaddingLeftLocal = parseFloat(parentStyleLocal.paddingLeft) || 0;
                    const parentPaddingTopLocal = parseFloat(parentStyleLocal.paddingTop) || 0;
                    const originXLocal = parentRectLocal.left + parentPaddingLeftLocal;
                    const originYLocal = parentRectLocal.top + parentPaddingTopLocal;
                    const pointerX = clientX - originXLocal; // local to desktop
                    const pointerY = clientY - originYLocal; // local to desktop
                    // Check corners and top first
                    if (pointerY <= snapThreshold && pointerX <= cornerThreshold) {
                        previewMode = 'left-top';
                    } else if (pointerY <= snapThreshold && pointerX >= contentBoxWidth - cornerThreshold) {
                        previewMode = 'right-top';
                    } else if (pointerY <= snapThreshold) {
                        previewMode = 'max';
                    } else if (pointerY >= contentBoxHeight - taskbarHeight - snapThreshold && pointerX <= cornerThreshold) {
                        // bottom-left corner
                        previewMode = 'left-bottom';
                    } else if (pointerY >= contentBoxHeight - taskbarHeight - snapThreshold && pointerX >= contentBoxWidth - cornerThreshold) {
                        // bottom-right corner
                        previewMode = 'right-bottom';
                    } else if (pointerX <= snapThreshold) {
                        previewMode = 'left';
                    } else if (pointerX >= contentBoxWidth - snapThreshold) {
                        previewMode = 'right';
                    } else {
                        previewMode = '';
                    }
                    if (previewMode) setSnapHoverMode(previewMode); else setSnapHoverMode('');
                }
                // Resize logic moved to resizewin function
            }
            document.addEventListener('mousemove', (e) => {
                if (!actionState.type || !actionState.windowEl) return;
                actionState.lastMouseX = e.clientX;
                actionState.lastMouseY = e.clientY;
                actionState.currentX = e.clientX;
                actionState.currentY = e.clientY;
                requestApply();
                e.preventDefault();
            });

            // Pointer move uses the same logic as mousemove for better capture across devices
            document.addEventListener('pointermove', (e) => {
                if (!actionState.type || !actionState.windowEl) return;
                actionState.lastMouseX = e.clientX;
                actionState.lastMouseY = e.clientY;
                actionState.currentX = e.clientX;
                actionState.currentY = e.clientY;
                requestApply();
                e.preventDefault();
            });

            function clearActionState(e) {
                cancelApply();
                const hadAction = !!actionState.type;
                // If there's a pending hover timer, cancel it
                if (typeof snapHoverTimer !== 'undefined' && snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                // Determine whether a snap preview is currently visible (and what mode)
                const previewShown = snapPreview && snapPreview.classList.contains('show');
                const previewMode = previewShown && snapPreview.dataset ? snapPreview.dataset.mode : '';
                // If drag ended, evaluate snap based on preview being displayed
                if (hadAction && actionState.type === 'drag' && actionState.windowEl) {
                    const windowEl = actionState.windowEl;
                    const contentBoxWidth = desktop.clientWidth;
                    const contentBoxHeight = desktop.clientHeight;
                    const taskbarHeight = taskbar.offsetHeight;
                    const left = parseFloat(windowEl.style.left) || windowEl.offsetLeft || 0;
                    const top = parseFloat(windowEl.style.top) || windowEl.offsetTop || 0;
                    const width = windowEl.offsetWidth;
                    const height = windowEl.offsetHeight;
                    // Use pointer position for final snap detection (less false positives)
                    const parentRect = desktop.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(desktop);
                    const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
                    const parentPaddingTop = parseFloat(parentStyle.paddingTop) || 0;
                    const originX = parentRect.left + parentPaddingLeft;
                    const originY = parentRect.top + parentPaddingTop;
                    const clientX = actionState.currentX || actionState.lastMouseX || actionState.startX;
                    const clientY = actionState.currentY || actionState.lastMouseY || actionState.startY;
                    const pointerX = clientX - originX; // pointer relative to desktop
                    const pointerY = clientY - originY; // pointer relative to desktop
                    const threshold = 24; // px threshold to consider snapped by pointer

                    // Only perform snap/maximize if the hover preview was actually shown
                    if (previewShown && previewMode) {
                        const appId = windowEl.dataset.app;
                        switch (previewMode) {
                            case 'max':
                                maximizeWindow(appId);
                                break;
                            case 'left':
                            case 'right':
                            case 'left-top':
                            case 'right-top':
                            case 'left-bottom':
                            case 'right-bottom':
                                snapWindow(windowEl, previewMode);
                                break;
                        }
                    }
                    // Hide the preview once we acted
                    if (previewShown) hideSnapPreview();
                }
                // try to release pointer capture if used
                try {
                    if (actionState.captureTarget && actionState.pointerId && actionState.captureTarget.releasePointerCapture) {
                        actionState.captureTarget.releasePointerCapture(actionState.pointerId);
                    }
                } catch (err) {}
                if (actionState.type) {
                    actionState.type = null;
                        actionState.windowEl = null;
                        actionState.direction = '';
                        actionState.startX = null;
                        actionState.startY = null;
                        actionState.startLeft = null;
                        actionState.startTop = null;
                        actionState.startWidth = null;
                        actionState.startHeight = null;
                        actionState.currentX = null;
                        actionState.currentX = null;
                        actionState.currentY = null;
                        // Clear any hover-mode state
                        if (typeof snapHoverTimer !== 'undefined' && snapHoverTimer) { clearTimeout(snapHoverTimer); snapHoverTimer = null; }
                        snapHoverMode = '';
                        // Ensure preview hidden as part of cleanup
                        hideSnapPreview();
                }
                // re-enable user selection and clear any selection left over from a drag
                // Only do this if we actually had an active action (drag/resize)
                // Determine whether the event target is an editable element (input/textarea/contenteditable)
                const target = e && e.target;
                const isEditable = target && ((target.matches && (target.matches('input, textarea'))) || target.isContentEditable || (target.closest && (target.closest('input, textarea, [contenteditable]'))));
                // Only clear selection if we had an active action (drag/resize) OR the mouseup occurred outside an editable element
                if (hadAction || !isEditable) {
                    document.body.style.userSelect = '';
                    const sel = window.getSelection && window.getSelection();
                    if (sel && sel.removeAllRanges) sel.removeAllRanges();
                }
                actionState.pointerId = null;
                actionState.captureTarget = null;
            }

            // --- Snap preview helpers ---
            function showSnapPreview(mode) {
                if (!snapPreview) return;
                const contentBoxWidth = desktop.clientWidth;
                const contentBoxHeight = desktop.clientHeight;
                const taskbarHeight = taskbar.offsetHeight;
                let left = 0, top = 0, width = contentBoxWidth, height = contentBoxHeight - taskbarHeight;
                switch (mode) {
                    case 'max':
                        left = 0; top = 0; width = contentBoxWidth; height = contentBoxHeight - taskbarHeight; break;
                    case 'left':
                        left = 0; top = 0; width = Math.floor(contentBoxWidth / 2); height = contentBoxHeight - taskbarHeight; break;
                    case 'right':
                        left = Math.ceil(contentBoxWidth / 2); top = 0; width = Math.floor(contentBoxWidth / 2); height = contentBoxHeight - taskbarHeight; break;
                    case 'left-top':
                        left = 0; top = 0; width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                    case 'right-top':
                        left = Math.ceil(contentBoxWidth / 2); top = 0; width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                    case 'left-bottom':
                        left = 0; top = Math.ceil((contentBoxHeight - taskbarHeight) / 2); width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                    case 'right-bottom':
                        left = Math.ceil(contentBoxWidth / 2); top = Math.ceil((contentBoxHeight - taskbarHeight) / 2); width = Math.floor(contentBoxWidth / 2); height = Math.floor((contentBoxHeight - taskbarHeight) / 2); break;
                }
                snapPreview.style.left = `${left}px`;
                snapPreview.style.top = `${top}px`;
                snapPreview.style.width = `${width}px`;
                snapPreview.style.height = `${height}px`;
                snapPreview.classList.add('show');
                snapPreview.dataset.mode = mode;
            }
            function hideSnapPreview() {
                if (!snapPreview) return;
                snapPreview.classList.remove('show');
                snapPreview.dataset.mode = '';
            }
            document.addEventListener('mouseup', (e) => {
                clearActionState(e);
            });
            document.addEventListener('pointerup', (e) => {
                clearActionState(e);
            });
            document.addEventListener('pointercancel', (e) => {
                clearActionState(e);
            });
            window.addEventListener('blur', () => { clearActionState(); });

            // --- 10. 應用程式開啟邏輯 ---
            
            // 10.1 從桌面圖示開啟 (雙擊)
            desktopIcons.forEach(icon => {
                icon.addEventListener('dblclick', () => {
                    openWindow(icon.dataset.app);
                });
            });

            // 10.2 從任務欄圖示開啟/切換
            // We use event delegation so dynamically created temporary icons are handled too.
            const taskbarCenterGroup = document.querySelector('#taskbar .taskbar-group.center');
            if (taskbarCenterGroup) {
                taskbarCenterGroup.addEventListener('click', (e) => {
                    const icon = e.target.closest('.taskbar-icon');
                    if (!icon) return;
                    const appId = icon.dataset.app;
                    const windowEl = document.getElementById(`window-${appId}`);
                    if (!windowEl) return;
                    if (windowEl.classList.contains('minimized')) {
                        openWindow(appId);
                    } else if (windowEl.classList.contains('show') && windowEl.classList.contains('active')) {
                        minimizeWindow(appId);
                    } else if (windowEl.classList.contains('show')) {
                        focusWindow(windowEl);
                    } else {
                        openWindow(appId);
                    }
                });
                // keyboard accessibility: handle Enter/Space on focused icon
                taskbarCenterGroup.addEventListener('keydown', (e) => {
                    const icon = e.target.closest && e.target.closest('.taskbar-icon') ? e.target.closest('.taskbar-icon') : null;
                    if (!icon) return;
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        icon.click();
                    }
                });
            }
            
            // 10.3 從開始功能表開啟
            startMenu.querySelectorAll('.app-icon[data-app]').forEach(icon => {
                icon.addEventListener('click', () => {
                    openWindow(icon.dataset.app);
                    startMenu.classList.remove('show');
                });
            });
            // Bind click action to start menu '開始設定' context item
            const startMenuSettingsItem = document.getElementById('start-menu-settings');
            if (startMenuSettingsItem) {
                startMenuSettingsItem.addEventListener('click', () => {
                    openWindow('settings');
                    // close start menu and its context menu
                    startMenu.classList.remove('show');
                    startMenuSettingsItem.closest('#start-context-menu').classList.remove('show');
                });
            }

            // --- 11. 長門櫻 (模擬的對話助理，功能增強) ---
            const nagatoWindow = document.getElementById('window-nagato');
            const nagatoMessages = nagatoWindow.querySelector('.nagato-messages');
            const nagatoInput = nagatoWindow.querySelector('#nagato-input');
            const nagatoSend = nagatoWindow.querySelector('#nagato-send');
            const NAGATO_KEY = 'nagato_conversation_v1';

            // Load conversation from localStorage and render
            function loadNagatoConversation() {
                try {
                    const raw = localStorage.getItem(NAGATO_KEY);
                    if (!raw) return [];
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) return [];
                    return parsed;
                } catch (e) { return []; }
            }
            function saveNagatoConversation(arr) {
                try { localStorage.setItem(NAGATO_KEY, JSON.stringify(arr)); } catch (e) { console.warn(e); }
            }
            function renderNagatoMessages() {
                let list = loadNagatoConversation();
                // Seed a friendly greeting if no previous conversation found
                if (!list || !list.length) {
                    list = [{ role: 'ai', text: '主人您好！我叫長門櫻，您的專屬女僕。請問您有什麼需要長門櫻為您效勞的嗎？', ts: Date.now() }];
                    saveNagatoConversation(list);
                }
                nagatoMessages.innerHTML = '';
                list.forEach(msg => {
                    const el = document.createElement('div');
                    el.classList.add('message', msg.role === 'user' ? 'user' : 'ai');
                    el.textContent = msg.text;
                    nagatoMessages.appendChild(el);
                });
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }

            function showTypingIndicator() {
                const typing = document.createElement('div');
                typing.classList.add('message', 'ai', 'typing');
                typing.innerHTML = '<span class="typing-dots"><span></span><span></span><span></span></span>';
                typing.id = 'nagato-typing';
                nagatoMessages.appendChild(typing);
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }
            function hideTypingIndicator() {
                const el = document.getElementById('nagato-typing');
                if (el) el.remove();
            }

            function generateNagatoResponse(userText) {
                const txt = userText.toLowerCase();
                if (/^(hi|hello|嘿|嗨|你好|您 好)/i.test(userText)) {
                    return '主人您好！請問您有什麼需要長門櫻為您效勞的嗎？';
                }
                if (txt.includes('時間')) {
                    const now = new Date();
                    const hh = String(now.getHours()).padStart(2, '0');
                    const mm = String(now.getMinutes()).padStart(2, '0');
                    return `主人現在是 ${hh}:${mm}`;
                }
                if (txt.includes('日期')) return `今天是 ${new Date().toLocaleDateString('zh-TW')}`;
                if (txt.includes('開啟') && txt.includes('設定')) return '好的，即將開啟設定。';
                if (txt.includes('開啟') && txt.includes('瀏覽')) return '好的，正在開啟瀏覽器。';
                if (txt.includes('我的網站') || txt.includes('網站')) return '你可以查看你的網站: https://amanoshizukikun.github.io/';
                if (txt.includes('幫助')) return '我能提供時間、日期、打開應用程式，或簡單回答一般問題。你可以試試說 "告訴我今天的時間"。';
                // fallback: summarize / echo back a short reply
                const truncated = userText.length > 120 ? userText.slice(0, 117) + '…' : userText;
                return `收到："${truncated}"。你想要我怎麼處理？`;
            }

            function appendNagatoMessage(role, text) {
                const el = document.createElement('div');
                el.classList.add('message', role === 'user' ? 'user' : 'ai');
                el.textContent = text;
                nagatoMessages.appendChild(el);
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }

            function sendNagatoMessage() {
                const message = nagatoInput.value.trim();
                if (!message) return;
                // store
                const conv = loadNagatoConversation();
                conv.push({ role: 'user', text: message, ts: Date.now() });
                saveNagatoConversation(conv);

                appendNagatoMessage('user', message);
                nagatoInput.value = '';
                showTypingIndicator();

                // Simulate AI latency based on message length
                const delay = Math.min(1400 + message.length * 5, 2200);
                setTimeout(() => {
                    hideTypingIndicator();
                    const resp = generateNagatoResponse(message);
                    appendNagatoMessage('ai', resp);
                    // store AI response
                    const conv2 = loadNagatoConversation();
                    conv2.push({ role: 'ai', text: resp, ts: Date.now() });
                    saveNagatoConversation(conv2);
                    // optionally include quick actions
                    addNagatoQuickActions(resp);
                }, delay);
            }

            function addNagatoQuickActions(respText) {
                // remove previous suggestions
                nagatoMessages.querySelectorAll('.message-suggestions').forEach(el => el.remove());
                // Suggest a couple quick actions based on the response
                const container = document.createElement('div');
                container.className = 'message-suggestions';
                // Basic actions
                const suggestions = [
                    { label: '開啟設定', action: () => openWindow('settings') },
                    { label: '開啟瀏覽器', action: () => openWindow('browser') },
                    { label: '顯示時間', action: () => { sendNagatoMessageFromBtn('現在時間是多少？'); } }
                ];
                suggestions.forEach(s => {
                    const b = document.createElement('button');
                    b.className = 'suggestion-btn';
                    b.textContent = s.label;
                    b.addEventListener('click', (e) => { e.stopPropagation(); s.action(); });
                    container.appendChild(b);
                });
                nagatoMessages.appendChild(container);
                nagatoMessages.scrollTop = nagatoMessages.scrollHeight;
            }

            function sendNagatoMessageFromBtn(text) {
                nagatoInput.value = text;
                sendNagatoMessage();
            }

            // Event bindings
            nagatoSend.addEventListener('click', sendNagatoMessage);
            nagatoInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendNagatoMessage(); }
            });
            // Auto-resize textarea for better UX
            function autoResizeNagatoInput() {
                nagatoInput.style.height = 'auto';
                nagatoInput.style.height = (nagatoInput.scrollHeight) + 'px';
            }
            nagatoInput.addEventListener('input', autoResizeNagatoInput);
            autoResizeNagatoInput();
            // initialize messages
            renderNagatoMessages();
            // Bind clear button
            const nagatoClearBtn = document.getElementById('nagato-clear');
            if (nagatoClearBtn) {
                nagatoClearBtn.addEventListener('click', () => {
                    if (!confirm('確認要清除長門櫻的聊天紀錄嗎？')) return;
                    saveNagatoConversation([]);
                    renderNagatoMessages();
                });
            }
            
            // --- 12. 初始化 ---
            // Calculator initialization and enhancements
            try {
                // instantiate app calculator (if element exists)
                if (document.querySelector('#win-calc')) {
                    window.appCalculator = new Calculator('#calc-input', '#win-calc>.keyb');
                }
                // Make calc buttons accessible and attach keyboard (Enter/Space) handlers
                document.querySelectorAll('#win-calc .b').forEach(btn => {
                    btn.setAttribute('role', 'button');
                    btn.setAttribute('tabindex', '0');
                    if (!btn.hasAttribute('aria-label')) btn.setAttribute('aria-label', btn.textContent.trim());
                    btn.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); } });
                });

                // Global keyboard handler while calculator is focused/active
                document.addEventListener('keydown', (e) => {
                    try {
                        const active = activeWindow; // var from earlier
                        if (!active || active.id !== 'window-calculator') return;
                        if (!window.appCalculator) return;
                        const key = e.key;
                        if (/^[0-9]$/.test(key)) { window.appCalculator.number_key(Number(key)); e.preventDefault(); return; }
                        if (key === '.') { window.appCalculator.point(); e.preventDefault(); return; }
                        if (key === '+' || key === '-') { window.appCalculator.func_key(key === '+' ? 1 : 2); 
                            // set visual checked
                            const el = document.querySelector(key === '+' ? '#win-calc>.keyb>.jia' : '#win-calc>.keyb>.jian');
                            if (el) window.appCalculator.check(el);
                            e.preventDefault();
                            return;
                        }
                        if (key === '*' || key === 'x' || key === 'X') { window.appCalculator.func_key(3); const el = document.querySelector('#win-calc>.keyb>.cheng'); if (el) window.appCalculator.check(el); e.preventDefault(); return; }
                        if (key === '/') { window.appCalculator.func_key(4); const el = document.querySelector('#win-calc>.keyb>.chu'); if (el) window.appCalculator.check(el); e.preventDefault(); return; }
                        if (key === 'Enter' || key === '=') { window.appCalculator.eq(); e.preventDefault(); return; }
                        if (key === 'Backspace') { window.appCalculator.backspace(); e.preventDefault(); return; }
                        if (key === 'Escape') { window.appCalculator.clear_num(); e.preventDefault(); return; }
                    } catch (error) { console.error('Calculator keyboard handler error', error); }
                });
            } catch (err) { console.warn('Calculator init failed', err); }
            initBootSequence();
            renderCalendar();
            // Ensure taskbar icon states (open-app / active-app) are synced to current windows
            function syncTaskbarWithWindows() {
                getAllTaskbarIcons().forEach(icon => {
                    const appId = icon.dataset.app;
                    const winEl = document.getElementById(`window-${appId}`);
                    // Keep open-app if showing or minimized
                    if (winEl && (winEl.classList.contains('show') || winEl.classList.contains('minimized'))) {
                        icon.classList.add('open-app');
                    } else {
                        icon.classList.remove('open-app');
                    }
                    if (winEl && winEl.classList.contains('active')) {
                        icon.classList.add('active-app');
                        icon.setAttribute('aria-pressed', 'true');
                    } else {
                        icon.classList.remove('active-app');
                        icon.setAttribute('aria-pressed', 'false');
                    }
                });
            }
            syncTaskbarWithWindows();
            // 全域初始化 (背景、導航、動畫)
            if (typeof Core !== 'undefined' && typeof Core.initBackground === 'function') Core.initBackground();
            if (typeof Navigation !== 'undefined' && typeof Navigation.init === 'function') Navigation.init();
            if (typeof Animations !== 'undefined' && typeof Animations.init === 'function') Animations.init();
            
            // 處理窗口大小變化 (用於最大化視窗)
            // 監聽 window resize 事件，以確保在瀏覽器大小變化時，最大化的視窗能正確調整高度
            window.addEventListener('resize', () => {
                document.querySelectorAll('.window[data-is-maximized="true"]').forEach(window => {
                    window.style.height = `calc(100% - ${taskbar.offsetHeight}px)`;
                });
            });

            // --- Browser Favorites (最愛/書籤) ---
            const favoritesKey = 'sim_favorites_v1';
            const favoritesBar = document.getElementById('favorites-bar');
            const browserBack = document.getElementById('browser-back');
            const browserForward = document.getElementById('browser-forward');
            const browserRefresh = document.getElementById('browser-refresh');
            const browserUrlInput = document.getElementById('browser-url-input');
            const bookmarkToggle = document.getElementById('bookmark-toggle');
            const browserWindow = document.getElementById('window-browser');
            const browserIframe = browserWindow.querySelector('iframe');

            // Basic history implemented client-side (for navigation via this UI only)
            let browserHistory = [];
            let browserHistoryIndex = -1;

            const defaultFavorites = [
                { title: '我的網站', url: 'https://amanoshizukikun.github.io/' }
            ];

            function loadFavorites() {
                try {
                    const raw = localStorage.getItem(favoritesKey);
                    if (!raw) return defaultFavorites.slice();
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) return defaultFavorites.slice();
                    return parsed;
                } catch (e) {
                    console.warn('Failed to load favorites', e);
                    return defaultFavorites.slice();
                }
            }

            function saveFavorites(list) {
                try {
                    localStorage.setItem(favoritesKey, JSON.stringify(list));
                } catch (e) {
                    console.warn('Failed to save favorites', e);
                }
            }

            function renderFavorites() {
                const list = loadFavorites();
                favoritesBar.innerHTML = '';
                list.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'fav-item';
                    el.setAttribute('role', 'button');
                    el.setAttribute('tabindex', '0');
                    el.setAttribute('title', item.url);
                    el.innerHTML = `<img class="favicon" src="https://www.google.com/s2/favicons?sz=64&domain_url=${encodeURIComponent(item.url)}" alt=""> <span class="title">${item.title}</span>`;
                    el.addEventListener('click', (e) => {
                        e.preventDefault();
                        openWindow('browser');
                        setBrowserUrl(item.url, true);
                    });
                    el.addEventListener('keydown', (e) => { if (e.key === 'Enter') el.click(); });
                    favoritesBar.appendChild(el);
                });
            }

            function isFavorite(url) {
                const list = loadFavorites();
                return list.some(item => item.url === url);
            }

            function addFavorite(obj) {
                if (!obj || !obj.url) return;
                const list = loadFavorites();
                if (list.some(i => i.url === obj.url)) return;
                list.unshift(obj);
                saveFavorites(list);
                renderFavorites();
            }

            function removeFavoriteByUrl(url) {
                let list = loadFavorites();
                list = list.filter(i => i.url !== url);
                saveFavorites(list);
                renderFavorites();
            }

            function setBrowserUrl(url, pushHistory = true) {
                if (!url) return;
                // Ensure protocol for local relative paths
                // Normalize the urls to absolute for a robust comparison
                const normalize = (u) => {
                    try { return new URL(u, window.location.href).href; } catch (e) { return u; }
                };
                const normalized = normalize(url);
                const current = browserIframe ? browserIframe.src : '';
                // If the normalized URL is the same as current iframe src, avoid resetting it (prevents reload/reset when restoring from minimized state)
                if (current && normalized === current) {
                    // Still update UI states
                    browserUrlInput.value = url;
                    updateNavigationButtons();
                    updateBookmarkButton(url);
                    return;
                }
                browserUrlInput.value = url;
                browserIframe.src = url;
                // Show iframe (Edge style uses .show class)
                browserIframe.classList.add('show');
                // Add to internal history
                if (pushHistory) {
                    // If we navigate to a new URL while not at the end of history, discard the forward
                    if (browserHistoryIndex < browserHistory.length - 1) {
                        browserHistory = browserHistory.slice(0, browserHistoryIndex + 1);
                    }
                    browserHistory.push(url);
                    browserHistoryIndex = browserHistory.length - 1;
                }
                updateNavigationButtons();
                updateBookmarkButton(url);
            }

            function updateNavigationButtons() {
                browserBack.classList.toggle('disabled', browserHistoryIndex <= 0);
                browserForward.classList.toggle('disabled', browserHistoryIndex >= browserHistory.length - 1);
                // Add a11y attributes
                browserBack.setAttribute('aria-disabled', String(browserHistoryIndex <= 0));
                browserForward.setAttribute('aria-disabled', String(browserHistoryIndex >= browserHistory.length - 1));
            }

            browserBack.addEventListener('click', () => {
                if (browserHistoryIndex <= 0) return;
                browserHistoryIndex -= 1;
                setBrowserUrl(browserHistory[browserHistoryIndex], false);
            });
            browserForward.addEventListener('click', () => {
                if (browserHistoryIndex >= browserHistory.length - 1) return;
                browserHistoryIndex += 1;
                setBrowserUrl(browserHistory[browserHistoryIndex], false);
            });
            browserRefresh.addEventListener('click', () => {
                try { browserIframe.contentWindow.location.reload(); } catch (e) { browserIframe.src = browserUrlInput.value; }
            });

            bookmarkToggle.addEventListener('click', () => {
                const url = browserUrlInput.value;
                if (!url) return;
                if (isFavorite(url)) removeFavoriteByUrl(url);
                else addFavorite({ title: url.replace(/https?:\/\//, '').replace(/\/.*$/, ''), url: url });
                updateBookmarkButton(url);
            });

            function updateBookmarkButton(url) {
                const icon = bookmarkToggle.querySelector('i');
                if (isFavorite(url)) {
                    icon.classList.remove('fa-regular');
                    icon.classList.add('fa-solid');
                    bookmarkToggle.setAttribute('aria-pressed', 'true');
                }
                // Not favorite -> show regular style
                if (!isFavorite(url)) {
                    icon.classList.remove('fa-solid');
                    icon.classList.add('fa-regular');
                    bookmarkToggle.setAttribute('aria-pressed', 'false');
                }
            }

            // Initialize: render favorites and load default homepage if needed
            renderFavorites();
            // If the iframe is blank, set a friendly default
            const initialUrl = 'https://amanoshizukikun.github.io/';
            if (browserIframe && (browserIframe.src === 'about:blank' || !browserIframe.src)) {
                setBrowserUrl(initialUrl, true);
            } else if (browserIframe && browserIframe.src && browserIframe.src !== 'about:blank') {
                setBrowserUrl(browserIframe.src, true);
            }

            // When the browser window receives focus (is opened/activated), update bookmark status for current URL
            // Hook into openWindow by wrapping a reference to previous openWindow behavior is already used. We'll listen for focus changes.
            document.addEventListener('click', (e) => {
                // If a browser taskbar icon was clicked and it's showing then update
                const openIcon = document.getElementById('taskbar-icon-browser');
                if (openIcon && openIcon.classList.contains('open-app')) {
                    updateBookmarkButton(browserUrlInput.value);
                }
            });

            // Allow pressing Enter on url input to open
            browserUrlInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const url = browserUrlInput.value.trim() || initialUrl;
                    setBrowserUrl(url, true);
                }
            });
            // Ensure clicking or mousedown on the URL input doesn't let parent handlers steal focus
            browserUrlInput.addEventListener('mousedown', (e) => {
                // Prevent any simulator-level click handlers from hiding menus or stealing focus
                e.stopPropagation();
            });
            browserUrlInput.addEventListener('click', (e) => {
                e.stopPropagation();
                browserUrlInput.focus();
            });
        });
    </script>

    <!-- Weather widget script -->
    <script>
    (function (){
        const DEFAULT_CITY = '台北';
        const CACHE_KEY = 'webos_weather_cache_v1';
        const CACHE_TTL = 10 * 60 * 1000; // 10 minutes
        const weatherInput = document.getElementById('weather-city-input');
        const weatherRefresh = document.getElementById('weather-refresh');
        const weatherGeo = document.getElementById('weather-geolocate');
        const weatherIcon = document.getElementById('weather-icon');
        const weatherTemp = document.getElementById('weather-temp');
        const weatherDesc = document.getElementById('weather-desc');
        const weatherHumidity = document.getElementById('weather-humidity');
        const weatherFeels = document.getElementById('weather-feels');
        const weatherForecast = document.getElementById('weather-forecast');
        const weatherLocSpan = document.getElementById('weather-location');
        const weatherUpdatedElem = document.getElementById('weather-updated');

        function _getCache(){
            try{ return JSON.parse(localStorage.getItem(CACHE_KEY)); }catch(e){return null}
        }
        function _setCache(city, data){
            localStorage.setItem(CACHE_KEY, JSON.stringify({city, ts: Date.now(), data}));
        }
        function _checkCache(city){
            const c = _getCache();
            if(!c || c.city !== city) return null;
            if(Date.now() - c.ts > CACHE_TTL) return null;
            return c.data;
        }

        async function fetchWeatherData(city){
            // Primary: wttr.in JSON
            const wttrUrl = `https://wttr.in/${encodeURIComponent(city)}?format=j1`;
            try{
                const resp = await fetch(wttrUrl);
                if(resp.ok){
                    return await resp.json();
                }
                // fallback via allorigins to avoid CORS issues
                const fallback = `https://api.allorigins.win/raw?url=${encodeURIComponent(wttrUrl)}`;
                const alt = await fetch(fallback);
                if(alt.ok) return await alt.json();
                throw new Error('無法從 wttr.in 獲取資料');
            }catch(e){
                // Try allorigins if first failed
                try{
                    const fallback = `https://api.allorigins.win/raw?url=${encodeURIComponent(wttrUrl)}`;
                    const alt = await fetch(fallback);
                    if(alt.ok) return await alt.json();
                }catch(err){ }
                throw e;
            }
        }

        function getIconForDesc(desc){
            if(!desc) return 'fa-cloud-sun';
            const d = desc.toLowerCase();
            if(d.includes('rain') || d.includes('雨') || d.includes('shower') || d.includes('drizzle') || d.includes('thunder')) return 'fa-cloud-showers-heavy';
            if(d.includes('snow') || d.includes('snow') || d.includes('flake') || d.includes('雪')) return 'fa-snowflake';
            if(d.includes('cloud') || d.includes('cloudy') || d.includes('多雲') || d.includes('陰')) return 'fa-cloud';
            if(d.includes('clear') || d.includes('sun') || d.includes('晴') || d.includes('晴時')) return 'fa-sun';
            if(d.includes('mist') || d.includes('fog') || d.includes('霧')) return 'fa-smog';
            return 'fa-cloud-sun';
        }

        function render(data, city){
            try{
                const current = data.current_condition && data.current_condition[0];
                const nearest = (data.nearest_area && data.nearest_area[0]) || null;
                const locName = nearest && (nearest.areaName && nearest.areaName[0] && nearest.areaName[0].value) ? nearest.areaName[0].value : city;
                weatherLocSpan.innerText = locName;
                // icon
                const desc = (current && current.weatherDesc && current.weatherDesc[0] && current.weatherDesc[0].value) || '';
                const iconClass = getIconForDesc(desc);
                // using font awesome classes on <i>
                // Replace icon element classes
                weatherIcon.className = `fa-solid ${iconClass}`;
                // temps
                weatherTemp.innerText = `${current.temp_C}°C`;
                weatherDesc.innerText = desc;
                weatherHumidity.innerText = `濕度: ${current.humidity}%`;
                weatherFeels.innerText = `體感: ${current.FeelsLikeC}°C`;
                // forecast
                weatherForecast.innerHTML = '';
                if(Array.isArray(data.weather)){
                    for(let i=0;i<data.weather.length && i<3;i++){
                        const d = data.weather[i];
                        const date = d.date;
                        const high = d.maxtempC;
                        const low = d.mintempC;
                        const midday = (d.hourly && d.hourly[4] && d.hourly[4].weatherDesc && d.hourly[4].weatherDesc[0] && d.hourly[4].weatherDesc[0].value) ? d.hourly[4].weatherDesc[0].value : '';
                        const ic = getIconForDesc(midday);
                        const item = document.createElement('div');
                        item.className = 'forecast-item';
                        item.innerHTML = `
                            <div class="date">${date}</div>
                            <div class="icon"><i class="fa-solid ${ic}"></i></div>
                            <div class="temp">${high}° / ${low}°</div>
                            <div class="desc" style="font-size:0.8rem;color:#bbb">${midday}</div>
                        `;
                        weatherForecast.appendChild(item);
                    }
                }
                // Update last refreshed time
                try{ weatherUpdatedElem.innerText = '更新: ' + new Date().toLocaleTimeString(); }catch(e){}
            }catch(e){
                weatherDesc.innerText = '解析資料時發生錯誤';
                weatherForecast.innerHTML = '';
            }
        }

        async function updateWeather(city){
            if(!city) city = DEFAULT_CITY;
            // show loading
            weatherDesc.innerText = '載入中...';
            // UI feedback - disable buttons and animate refresh icon
            try{ weatherRefresh.disabled = true; weatherRefresh.style.opacity = '0.6'; weatherRefresh.querySelector('i')?.classList.add('fa-spin'); }catch(e){}
            try{
                const cached = _checkCache(city);
                let data = cached;
                if(!data){
                    data = await fetchWeatherData(city);
                    _setCache(city, data);
                }
                render(data, city);
            }catch(e){
                console.error(e);
                weatherDesc.innerText = '無法獲取天氣資料';
                weatherForecast.innerHTML = '';
            }
            try{ weatherRefresh.disabled = false; weatherRefresh.style.opacity = '1'; weatherRefresh.querySelector('i')?.classList.remove('fa-spin'); }catch(e){}
        }

        async function detectLocationAndUpdate(){
            if(!navigator.geolocation){
                return updateWeather(DEFAULT_CITY);
            }
            weatherDesc.innerText = '獲取定位中...';
            navigator.geolocation.getCurrentPosition(async pos => {
                try{
                    const {latitude, longitude} = pos.coords;
                    const nomUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`;
                    const r = await fetch(nomUrl);
                    if(r.ok){
                        const rjson = await r.json();
                        const city = rjson.address.city || rjson.address.town || rjson.address.village || rjson.address.county || rjson.address.state || DEFAULT_CITY;
                        weatherInput.value = city;
                        updateWeather(city);
                    }else{
                        updateWeather(DEFAULT_CITY);
                    }
                }catch(e){
                    updateWeather(DEFAULT_CITY);
                }
            }, err => {
                updateWeather(DEFAULT_CITY);
            }, {timeout: 8000});
        }

        // Initialize: populate input and run first fetch
            (function init(){
            weatherInput.value = DEFAULT_CITY;
            weatherInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') updateWeather(weatherInput.value.trim()); });
            weatherRefresh.addEventListener('click', () => { updateWeather(weatherInput.value.trim() || DEFAULT_CITY); });
            weatherGeo.addEventListener('click', () => { detectLocationAndUpdate(); });
            // auto populate from cache or run update
            const cache = _getCache();
            const city = (cache && cache.city) ? cache.city : DEFAULT_CITY;
            if(cache && cache.ts && (Date.now() - cache.ts) < CACHE_TTL && cache.data){
                render(cache.data, city);
            }else{
                updateWeather(city);
            }
            })();
            // Auto refresh every 10 minutes (cache TTL)
            setInterval(() => { updateWeather(weatherInput.value.trim() || DEFAULT_CITY); }, CACHE_TTL);

    })();
    </script>

    <script>
        // About page helpers: populate info & actions
        (function () {
            function formatDateTime(d) {
                if (!d) return '--';
                const opts = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
                return new Intl.DateTimeFormat('zh-TW', opts).format(d);
            }

            document.addEventListener('DOMContentLoaded', () => {
                const verEl = document.getElementById('about-version');
                const version = verEl ? verEl.textContent.trim() : 'v?';
                const buildDateEl = document.getElementById('about-build-date');
                const bootTimeEl = document.getElementById('about-boot-time');
                const browserEl = document.getElementById('about-browser');
                const resolutionEl = document.getElementById('about-resolution');
                const langEl = document.getElementById('about-language');
                // About page no longer exposes copy/check buttons; Update page handles updates.
                const updateCheckBtn = document.getElementById('update-check-btn');
                const updateOpenReleaseBtn = document.getElementById('update-open-release-btn');
                const updateAutoToggle = document.getElementById('update-auto-toggle');
                const updateLatestVersionEl = document.getElementById('update-latest-version');
                const updateReleaseNotesEl = document.getElementById('update-release-notes');
                const updateLastCheckedEl = document.getElementById('update-last-checked');
                const updateStatusEl = document.getElementById('update-status');
                // updateStatus handled as updateStatusEl for the Update page

                // populate system info
                if (browserEl) browserEl.textContent = navigator.userAgent || navigator.appVersion || '未知瀏覽器';
                if (resolutionEl) resolutionEl.textContent = `${window.screen.width} x ${window.screen.height}`;
                if (langEl) langEl.textContent = navigator.language || navigator.languages[0] || '未知';

                // set boot time as page load origin
                try {
                    const timeOrigin = performance.timeOrigin || performance.timing?.navigationStart || Date.now();
                    const d = new Date(timeOrigin);
                    if (bootTimeEl) bootTimeEl.textContent = formatDateTime(d);
                } catch (e) {
                    if (bootTimeEl) bootTimeEl.textContent = '--';
                }

                // About page no longer provides copy version functionality; handled in Update page if needed.

                // Update helper: get latest release from GitHub
                async function fetchLatestRelease(repo) {
                    const res = await fetch(`https://api.github.com/repos/${repo}/releases/latest`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();
                    return data;
                }

                async function doCheckUpdatesUI(opts = {}) {
                    // opts: { repo, currentVersion, btn, statusEl, latestEl, releaseNotesEl, openBtn, lastCheckedEl }
                    const { repo, currentVersion, btn, statusEl, latestEl, releaseNotesEl, openBtn, lastCheckedEl } = opts;
                    if (!repo) return null;
                    const uiBtn = btn;
                    if (uiBtn) { uiBtn.disabled = true; uiBtn._prevText = uiBtn.textContent; uiBtn.textContent = '檢查中...'; }
                    if (statusEl) statusEl.textContent = '正在查詢 GitHub Releases...';
                    try {
                        const data = await fetchLatestRelease(repo);
                        const latestTag = data.tag_name || data.name || '';
                        const htmlUrl = data.html_url || `https://github.com/${repo}/releases`;
                        if (latestEl) latestEl.textContent = latestTag || '無發行內容';
                        if (releaseNotesEl) releaseNotesEl.textContent = data.body ? data.body.trim() : '無發布說明';
                        if (openBtn) { openBtn.disabled = false; openBtn.onclick = () => window.open(htmlUrl, '_blank', 'noopener'); }
                        if (latestTag && latestTag !== currentVersion) {
                            if (statusEl) statusEl.innerHTML = `有新版本可用：${latestTag} · <a href="${htmlUrl}" target="_blank" rel="noopener">檢視</a>`;
                        } else {
                            if (statusEl) statusEl.textContent = `已是最新版本 (${currentVersion})`;
                        }
                        if (lastCheckedEl) lastCheckedEl.textContent = formatDateTime(new Date());
                        // Return data
                        return { success: true, data };
                    } catch (err) {
                        if (statusEl) statusEl.textContent = '檢查更新失敗（可能被 GitHub API 限制或無網路）';
                        console.warn('check updates error', err);
                        return { success: false, error: err };
                    } finally {
                        if (uiBtn) { uiBtn.disabled = false; uiBtn.textContent = uiBtn._prevText || '檢查更新'; }
                    }
                }

                // About page no longer has an update button; Update page controls handle check/update UI.

                // Hook up Update page controls: button and auto toggle
                // Get current version for update page
                const updateCurrentVersionEl = document.getElementById('update-current-version');
                const currentVersionText = updateCurrentVersionEl ? updateCurrentVersionEl.textContent.trim() : version;
                // Ensure initial state for open button
                if (updateOpenReleaseBtn) updateOpenReleaseBtn.disabled = true;
                if (updateCheckBtn) {
                    updateCheckBtn.addEventListener('click', async () => {
                        await doCheckUpdatesUI({ repo: 'AmanoShizukikun/AmanoShizukikun.github.io', currentVersion: currentVersionText, btn: updateCheckBtn, statusEl: updateStatusEl, latestEl: updateLatestVersionEl, releaseNotesEl: updateReleaseNotesEl, openBtn: updateOpenReleaseBtn, lastCheckedEl: updateLastCheckedEl });
                    });
                }

                // Auto-check toggle
                const AUTO_KEY = 'webos_update_auto_check_v1';
                function getAutoCheck() {
                    try { return JSON.parse(localStorage.getItem(AUTO_KEY) || 'null') || { enabled: false, interval: 86400000, lastChecked: null }; } catch (e) { return { enabled: false, interval: 86400000, lastChecked: null }; }
                }
                function setAutoCheck(obj) { try { localStorage.setItem(AUTO_KEY, JSON.stringify(obj)); } catch (e) {} }
                // Restore toggle
                if (updateAutoToggle) {
                    const obj = getAutoCheck();
                    if (obj.enabled) { updateAutoToggle.classList.add('active'); updateAutoToggle.setAttribute('aria-checked', 'true'); }
                    updateAutoToggle.addEventListener('click', () => {
                        const enabled = updateAutoToggle.classList.toggle('active');
                        updateAutoToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
                        setAutoCheck(Object.assign(getAutoCheck(), { enabled }));
                        if (enabled) { /* immediate check on enable */ if (updateCheckBtn) updateCheckBtn.click(); }
                    });
                    updateAutoToggle.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); updateAutoToggle.click(); } });
                }

                // Auto check interval scheduler (every 5 minutes ping to test if lastChecked expired)
                setInterval(async () => {
                    const obj = getAutoCheck();
                    if (!obj.enabled) return;
                    const last = obj.lastChecked ? (new Date(obj.lastChecked)).getTime() : 0;
                    const now = Date.now();
                    if (now - last > (obj.interval || 86400000)) {
                        if (updateCheckBtn) await updateCheckBtn.click();
                        obj.lastChecked = new Date().toISOString();
                        setAutoCheck(obj);
                    }
                }, 5 * 60 * 1000);

            });
        })();
    </script>